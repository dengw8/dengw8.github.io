

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="dengw">
  <meta name="keywords" content="">
  
  <title>图解HTTP学习笔记—第五章 - dengw‘s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Kelo</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="图解HTTP学习笔记—第五章">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2018-08-14 00:23" pubdate>
        2018年8月14日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      118
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">图解HTTP学习笔记—第五章</h1>
            
            <div class="markdown-body">
              <h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>今天继续我们HTTP的学习，今天的内容是HTTP报文中一个重要的组成部分—HTTP 首部字段；</p>
<p>前面我们分析HTTP报文的时候说到HTTP报文就由首部和实体两个部分组成，而首部字段就是首部的组要组成成分之一，可以说首部字段包含了HTTP报文丰富的信息，是构成HTTP的重要要素，下面详细介绍一下：</p>
<h2 id="HTTP-首部字段的通用结构"><a href="#HTTP-首部字段的通用结构" class="headerlink" title="HTTP 首部字段的通用结构"></a>HTTP 首部字段的通用结构</h2><p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。<br><code>首部字段名: 字段值</code></p>
<p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。<br><code>Content-Type: text/html</code><br>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。</p>
<p>另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。<br><code>Keep-Alive: timeout=15, max=100</code></p>
<h2 id="HTTP-首部字段的分类"><a href="#HTTP-首部字段的分类" class="headerlink" title="HTTP 首部字段的分类"></a>HTTP 首部字段的分类</h2><ul>
<li><p><strong>通用首部字段</strong><br>请求报文和响应报文两方都会使用的首部字段。</p>
</li>
<li><p><strong>请求首部字段</strong><br>从客户端向服务器端发送请求报文时使用的首部字段。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
</li>
<li><p><strong>相应首部字段</strong><br>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>
</li>
<li><p><strong>实体首部字段</strong><br>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>
</li>
</ul>
<p>下面就详细介绍一下 HTTP/1.1 版本中各类型都包含了哪些首部字段以及各自的含义：</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。</p>
<h5 id="Cache-Control-指令一览"><a href="#Cache-Control-指令一览" class="headerlink" title="Cache-Control 指令一览"></a>Cache-Control 指令一览</h5><p>可用的指令按请求和响应分类如下所示。</p>
<p>缓存请求指令：<br><img src="http://dengw.xyz/blog/180814/GjlklGhAdI.png?imageslim" srcset="/img/loading.gif" lazyload alt="缓存请求指令"></p>
<p>缓存响应指令：<br><img src="http://dengw.xyz/blog/180814/LHeemC3Ihk.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<h6 id="表示是否能缓存的指令包括："><a href="#表示是否能缓存的指令包括：" class="headerlink" title="表示是否能缓存的指令包括："></a>表示是否能缓存的指令包括：</h6><ul>
<li><p>public 指令</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">public</span><br></code></pre></td></tr></table></figure>
<p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。 </p>
</li>
<li><p>private 指令</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">private</span><br></code></pre></td></tr></table></figure>
<p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。<br>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。</p>
</li>
<li><p>no-cache 指令</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Cache</span>-Control: no-<span class="hljs-keyword">cache</span><br></code></pre></td></tr></table></figure>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。<br>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Cache</span>-Control: no-<span class="hljs-keyword">cache</span>=Location<br></code></pre></td></tr></table></figure>
<p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数。</p>
<ul>
<li>no-store 指令<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal">no</span><span class="hljs-string">-store</span> <br></code></pre></td></tr></table></figure>
当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。</li>
</ul>
<p>从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓 存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存。</p>
<h6 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h6><ul>
<li><p>s-maxage 指令</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Cache-Control: <span class="hljs-attribute">s-maxage</span>=604800（单位 ：秒）<br></code></pre></td></tr></table></figure>
<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何 作用。另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。 </p>
</li>
<li><p>max-age 指令</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-age</span>=<span class="hljs-number">604800</span>（单位：秒）<br></code></pre></td></tr></table></figure>
<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器。<br>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时 间。<br>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略。</p>
</li>
<li><p>min-fresh 指令</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">min</span><span class="hljs-params">-fresh</span>=<span class="hljs-number">60</span>（单位：秒）<br></code></pre></td></tr></table></figure>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。 比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。</p>
</li>
<li><p>max-stale 指令</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">Cache</span><span class="hljs-params">-Control</span>: <span class="hljs-keyword">max</span><span class="hljs-params">-stale</span>=<span class="hljs-number">3600</span>（单位：秒）<br></code></pre></td></tr></table></figure>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。<br>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收</p>
</li>
<li><p>only-if-cached 指令</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">Cache-Contro<span class="hljs-variable">l:</span> <span class="hljs-keyword">only</span>-<span class="hljs-keyword">if</span>-cached<br></code></pre></td></tr></table></figure>
<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
</li>
<li><p>must-revalidate 指令</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>must-revalidate<br></code></pre></td></tr></table></figure>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。<br>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。</p>
</li>
<li><p>proxy-revalidate 指令</p>
</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>proxy-revalidate<br></code></pre></td></tr></table></figure>

<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<ul>
<li>no-transform 指令<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal">no</span><span class="hljs-string">-transform</span><br></code></pre></td></tr></table></figure>
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</li>
</ul>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>Connection 首部字段具备如下两个作用。</p>
<ul>
<li><p>控制不再转发给代理的首部字段<br><img src="http://dengw.xyz/blog/180814/gDAj4083Dm.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Connection:</span> 不再转发的首部字段名<br></code></pre></td></tr></table></figure>
<p>在客户端发送请求和服务器返回响应内，使用 Connection 首部字 段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。</p>
</li>
<li><p>管理持久连接<br><img src="http://dengw.xyz/blog/180814/6dKcfJ4DlG.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p>
</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Connection:</span> <span class="hljs-meta">Keep</span>-Alive<br></code></pre></td></tr></table></figure>
<p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。<br>如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回 响应。</p>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。<br>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下 示 例。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: Tue, <span class="hljs-number">03</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">04</span>:<span class="hljs-number">40</span>:<span class="hljs-number">59</span> GMT<br></code></pre></td></tr></table></figure>
<p>之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: Tue, <span class="hljs-number">03</span>-Jul-<span class="hljs-number">12</span> <span class="hljs-number">04</span>:<span class="hljs-number">40</span>:<span class="hljs-number">59</span> GMT<br></code></pre></td></tr></table></figure>
<p>除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出 格式一致。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Date</span>: Tue Jul <span class="hljs-number">03</span> <span class="hljs-number">04</span>:<span class="hljs-number">40</span>:<span class="hljs-number">59</span> <span class="hljs-number">2012</span><br></code></pre></td></tr></table></figure>

<h4 id="Pragma-Pragma"><a href="#Pragma-Pragma" class="headerlink" title="Pragma Pragma"></a>Pragma Pragma</h4><p>是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br>规范定义的形式唯一，如下所示。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Pragma: <span class="hljs-keyword">no</span>-<span class="hljs-keyword">cache</span><br></code></pre></td></tr></table></figure>
<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p>
<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握 全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的 请求会同时含有下面两个首部字段。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Cache-Control:</span> <span class="hljs-literal">no</span><span class="hljs-string">-cache</span> <br><span class="hljs-attr">Pragma:</span> <span class="hljs-literal">no</span><span class="hljs-string">-cache</span><br></code></pre></td></tr></table></figure>

<h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p><img src="http://dengw.xyz/blog/180814/CbHA8jjk5b.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span> <br><span class="hljs-attr">Date:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">03</span> <span class="hljs-string">Jul</span> <span class="hljs-number">2012 04:40:56 </span><span class="hljs-string">GMT</span> <br><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html</span><br> <span class="hljs-string">...</span> <br><span class="hljs-attr">Transfer-Encoding:</span> <span class="hljs-string">chunked</span> <br><span class="hljs-attr">Trailer:</span> <span class="hljs-string">Expires</span> <span class="hljs-string">...(报文主体)...</span> <span class="hljs-number">0</span><br><span class="hljs-attr">Expires:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">28</span> <span class="hljs-string">Sep</span> <span class="hljs-number">2004 23:59:59 </span><span class="hljs-string">GMT</span> <br></code></pre></td></tr></table></figure>
<p> 以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后 （分块长度 0 之后）出现了首部字段 Expires。 </p>
<h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span> <br><span class="hljs-attr">Date:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">03</span> <span class="hljs-string">Jul</span> <span class="hljs-number">2012 04:40:56 </span><span class="hljs-string">GMT</span> <br><span class="hljs-attr">Cache-Control:</span> <span class="hljs-string">public,</span> <span class="hljs-string">max-age=604800</span> <br><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/javascript;</span> <span class="hljs-string">charset=utf-8</span><br><span class="hljs-attr">Expires:</span> <span class="hljs-string">Tue,</span> <span class="hljs-number">10</span> <span class="hljs-string">Jul</span> <span class="hljs-number">2012 04:40:56 </span><span class="hljs-string">GMT</span> <br><span class="hljs-attr">X-Frame-Options: DENY X-XSS-Protection:</span> <span class="hljs-number">1</span><span class="hljs-string">;</span> <span class="hljs-string">mode=block</span> <br><span class="hljs-attr">Content-Encoding:</span> <span class="hljs-string">gzip</span> <br><span class="hljs-attr">Transfer-Encoding:</span> <span class="hljs-string">chunked</span> <br><span class="hljs-attr">Connection:</span> <span class="hljs-string">keep-alive</span> <br><span class="hljs-string">cf0</span>    <span class="hljs-string">←16进制(10进制为3312)</span> <br><span class="hljs-string">...3312字节分块数据...</span> <br><span class="hljs-number">392</span>    <span class="hljs-string">←16进制(10进制为914)</span> <br><span class="hljs-string">...914字节分块数据...</span> <br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据</p>
<h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。<br><img src="http://dengw.xyz/blog/180814/2hhFg4e9if.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 <code>Connection:Upgrade</code>。 对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p>
<h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。</p>
<p>报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。</p>
<p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容。<br><img src="http://dengw.xyz/blog/180814/FbKhJEBha2.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<p>上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如 此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服 务器信息。</p>
<p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使 用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况 下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响 应。</p>
<h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演 变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Warning</span>: <span class="hljs-number">113</span> gw.hackr.jp:<span class="hljs-number">8080</span> <span class="hljs-string">&quot;Heuristic expiration&quot;</span> Tue, <span class="hljs-number">03</span> Jul <span class="hljs-number">2012</span> <br></code></pre></td></tr></table></figure>
<p>Warning 首部的格式如下。最后的日期时间部分可省略。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">Warning: <span class="hljs-comment">[警告码]</span><span class="hljs-comment">[警告的主机:端口号]</span>“<span class="hljs-comment">[警告内容]</span>”(<span class="hljs-comment">[日期时间]</span>)<br></code></pre></td></tr></table></figure>
<p>HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。 另外，警告码具备扩展性，今后有可能追加新的警告码。</p>
<p>HTTP/1.1 警告码<br><img src="http://dengw.xyz/blog/180814/9kfjGdCIb8.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p><img src="http://dengw.xyz/blog/180814/edHDf3hm1h.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Accept: text<span class="hljs-regexp">/html,application/</span>xhtml+xml,application<span class="hljs-regexp">/xml;q=0.9,*/</span>*;q=<span class="hljs-number">0</span>.<br></code></pre></td></tr></table></figure>

<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒 体类型。</p>
<p>下面我们试举几个媒体类型的例子。</p>
<ul>
<li>文本文件<br>text/html, text/plain, text/css … application/xhtml+xml, application/xml …</li>
<li>图片文件<br>image/jpeg, image/gif, image/png …</li>
<li>视频文件<br>video/mpeg, video/quicktime …</li>
<li>应用程序使用的二进制文件<br>application/octet-stream, application/zip …</li>
</ul>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。 </p>
<p>若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点 后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p><img src="http://dengw.xyz/blog/180814/ff5fad71C2.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Accept</span>-Charset: iso-<span class="hljs-number">8859</span>-<span class="hljs-number">5</span>, unicode-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>;q=<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。</p>
<p>该首部字段应用于内容协商机制的服务器驱动协商。</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p><img src="http://dengw.xyz/blog/180814/g6fJLcg1Jm.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Encoding: gzip, deflate<br></code></pre></td></tr></table></figure>
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。</p>
<p>下面试举出几个内容编码的例子。</p>
<ul>
<li>gzip<br>由文件压缩程序 gzip（GNU zip）生成的编码格式 （RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余 校验（Cyclic Redundancy Check，通称 CRC）。 </li>
<li>compress<br>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 LempelZiv-Welch 算法（LZW）。</li>
<li>deflate 组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法 （RFC1951）生成的编码格式。 </li>
<li>identity<br>不执行压缩或不会变化的默认编码格式</li>
</ul>
<p>采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另 外，也可使用星号（*）作为通配符，指定任意的编码格式。</p>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">Accept-Language: zh-cn,zh;q=<span class="hljs-number">0.7</span>,en-us,en;q=<span class="hljs-number">0.3</span><br>````<br>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级。可一次 指定多种自然语言集。<br><br>和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图 例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版 对应的响应，没有中文版时，则请求返回英文版响应。 <br><br><span class="hljs-comment">#### Authorization</span><br>![enter image description here](http:<span class="hljs-regexp">//</span>dengw.xyz<span class="hljs-regexp">/blog/</span><span class="hljs-number">180814</span>/lCihFcF7CJ.png?imageslim)<br><br></code></pre></td></tr></table></figure>
<p>Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 <span class="hljs-number">401</span> 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存 在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。<br><br>#### Expect<br></code></pre></td></tr></table></figure>
<p>Expect: 100-continue</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行 为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回 状态码 <span class="hljs-number">417</span> Expectation Failed。 <br><br>客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/<span class="hljs-number">1.1</span> 规 范只定义了 <span class="hljs-number">100</span>-continue（状态码 <span class="hljs-number">100</span> Continue 之意）。 <br><br>等待状态码 <span class="hljs-number">100</span> 响应的客户端在发生请求时，需要指定 Expect:<span class="hljs-number">100</span>continue。 <br><br>#### From<br>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的 电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但 可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段 内）。<br><br>#### Host<br>![enter image description here](http:<span class="hljs-comment">//dengw.xyz/blog/180814/GkGBgE5gLB.png?imageslim)</span><br>图：虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以 区分<br></code></pre></td></tr></table></figure>
<p>Host: <a target="_blank" rel="noopener" href="http://www.hackr.jp/">www.hackr.jp</a></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm">首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端 口号。Host 首部字段在 HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> 规范内是唯一一个必须被包含在请 求内的首部字段。<br><br>首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制 有很密切的关联，这是首部字段 Host 必须存在的意义。 <br><br>请求被发送至服务器时，请求中的主机名会用 <span class="hljs-built_in">IP</span> 地址直接替换解 决。但如果这时，相同的 <span class="hljs-built_in">IP</span> 地址下部署运行着多个域名，那么服务 器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部 字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直 接发送一个空值即可。如下所示。<br></code></pre></td></tr></table></figure>
<p>Host:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#### If-Match</span><br>![enter image description here](http:<span class="hljs-regexp">//</span>dengw.xyz<span class="hljs-regexp">/blog/</span><span class="hljs-number">180814</span>/<span class="hljs-number">8</span>d828JcJK6.png?imageslim)<br>附带条件请求<br><br>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br>![enter image description here](http:<span class="hljs-regexp">//</span>dengw.xyz<span class="hljs-regexp">/blog/</span><span class="hljs-number">180814</span>/haFIJHdbC8.png?imageslim)<br>图：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求<br><br></code></pre></td></tr></table></figure>
<p>If-Match: “123456”</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用 的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。<br><br>服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致 时，才会执行请求。反之，则返回状态码 <span class="hljs-number">412</span> Precondition Failed 的响 应。<br><br>还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务 器将会忽略 ETag 的值，只要资源存在就处理请求。 <br><br><span class="hljs-comment">#### If-Modified-Since</span><br>![enter image description here](http:<span class="hljs-regexp">//</span>dengw.xyz<span class="hljs-regexp">/blog/</span><span class="hljs-number">180814</span>/<span class="hljs-number">3</span>B3clL8Bc9.png?imageslim)<br>图：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了 更新，服务器会接受请求<br></code></pre></td></tr></table></figure>
<p>If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span>，属附带条件之一，它会告知服务器若 <span class="hljs-variable">IfModified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span> 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span> 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 <span class="hljs-number">304</span> <span class="hljs-built_in">Not</span> <span class="hljs-variable">Modified</span> 的响应。<br><br> <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span> 用于确认代理或客户端拥有的本地资源的有效性。 获取资源的更新日期时间，可通过确认首部字段 <span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span> 来确 定。<br><br><span class="hljs-type">####</span> <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span><br><span class="hljs-operator">!</span><span class="hljs-punctuation">[</span><span class="hljs-variable">enter</span> <span class="hljs-variable">image</span> <span class="hljs-variable">description</span> <span class="hljs-variable">here</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-variable">http</span><span class="hljs-operator">://</span><span class="hljs-variable">dengw</span><span class="hljs-operator">.</span><span class="hljs-variable">xyz</span><span class="hljs-operator">/</span><span class="hljs-variable">blog</span><span class="hljs-operator">/</span><span class="hljs-number">180814</span><span class="hljs-operator">/</span><span class="hljs-variable">I8C1lchidL</span><span class="hljs-operator">.</span><span class="hljs-variable">png</span><span class="hljs-operator">?</span><span class="hljs-variable">imageslim</span><span class="hljs-punctuation">)</span><br>图：只有在 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 的字段值与 <span class="hljs-variable">ETag</span> 值不一致时，可处理 该请求。与 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 首部字段的作用相反<br><br>首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 属于附带条件之一。它和首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 作用相反。用于指定 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 字段值的实体标记（<span class="hljs-variable">ETag</span>）值与 请求资源的 <span class="hljs-variable">ETag</span> 不一致时，它就告知服务器处理该请求。 <br><br>在 <span class="hljs-variable">GET</span> 或 <span class="hljs-variable">HEAD</span> 方法中使用首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span> 可获取最新的资 源。因此，这与使用首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span> 时有些类似。 <br><br><span class="hljs-type">####</span> <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">Range</span><br><span class="hljs-operator">!</span><span class="hljs-punctuation">[</span><span class="hljs-variable">enter</span> <span class="hljs-variable">image</span> <span class="hljs-variable">description</span> <span class="hljs-variable">here</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-variable">http</span><span class="hljs-operator">://</span><span class="hljs-variable">dengw</span><span class="hljs-operator">.</span><span class="hljs-variable">xyz</span><span class="hljs-operator">/</span><span class="hljs-variable">blog</span><span class="hljs-operator">/</span><span class="hljs-number">180814</span><span class="hljs-operator">/</span><span class="hljs-variable">fDA2m8E1gB</span><span class="hljs-operator">.</span><span class="hljs-variable">png</span><span class="hljs-operator">?</span><span class="hljs-variable">imageslim</span><span class="hljs-punctuation">)</span><br><br>首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">Range</span> 属于附带条件之一。它告知服务器若指定的 <span class="hljs-variable">IfRange</span> 字段值（<span class="hljs-variable">ETag</span> 值或者时间）和请求资源的 <span class="hljs-variable">ETag</span> 值或时间相一 致时，则作为范围请求处理。反之，则返回全体资源。<br><br><span class="hljs-operator">!</span><span class="hljs-punctuation">[</span><span class="hljs-variable">enter</span> <span class="hljs-variable">image</span> <span class="hljs-variable">description</span> <span class="hljs-variable">here</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">(</span><span class="hljs-variable">http</span><span class="hljs-operator">://</span><span class="hljs-variable">dengw</span><span class="hljs-operator">.</span><span class="hljs-variable">xyz</span><span class="hljs-operator">/</span><span class="hljs-variable">blog</span><span class="hljs-operator">/</span><span class="hljs-number">180814</span><span class="hljs-operator">/</span><span class="hljs-variable">eAkI5LiHHH</span><span class="hljs-operator">.</span><span class="hljs-variable">png</span><span class="hljs-operator">?</span><span class="hljs-variable">imageslim</span><span class="hljs-punctuation">)</span><br><br>下面我们思考一下不使用首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">Range</span> 发送请求的情况。服务器 端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当 然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 <span class="hljs-number">412</span> <span class="hljs-variable">Precondition</span> <span class="hljs-variable">Failed</span> 作为响应返回，其目的是催促客户端再次发送请 求。这样一来，与使用首部字段 <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">Range</span> 比起来，就需要花费两倍的 功夫。<br><br><span class="hljs-type">####</span> <span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Unmodified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span><br><span class="hljs-operator">````</span><br><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Unmodified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span><span class="hljs-operator">:</span> <span class="hljs-variable">Thu</span><span class="hljs-operator">,</span> <span class="hljs-number">03</span> <span class="hljs-variable">Jul</span> <span class="hljs-number">2012</span> <span class="hljs-number">00</span><span class="hljs-operator">:</span><span class="hljs-number">00</span><span class="hljs-operator">:</span><span class="hljs-number">00</span> <span class="hljs-variable">GMT</span><br></code></pre></td></tr></table></figure>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相 反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定 日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。</p>
<h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><p><img src="http://dengw.xyz/blog/180814/bKi3fcK210.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>图：每次转发数值减 1。当数值变 0 时返回响应</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Max</span>-Forwards: <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最 大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的 值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。</p>
<p>使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中， 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到 服务器返回的响应了。对此，我们无从可知。</p>
<p>可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展 开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回 响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状 况有所把握。<br><img src="http://dengw.xyz/blog/180814/2bBGldEkff.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<p>图：代理 B 到源服务器的请求失败了，但客户端不知道<br><img src="http://dengw.xyz/blog/180814/FB6KL0eLjK.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>图：由于未知原因，导致请求陷入代理之间的循环，但客户端不 知道</p>
<h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Proxy</span>-Authorization: Basic dGlwOjkpNLAGfFY<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 </p>
<p>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同 之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间 的认证，使用首部字段 Authorization 可起到相同作用。</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Range</span>: bytes=<span class="hljs-number">5001</span>-<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。</p>
<p>上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。</p>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p><img src="http://dengw.xyz/blog/180814/e9b450hJ3I.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Referer: http:<span class="hljs-regexp">//</span>www.hackr.jp/index.htm<br></code></pre></td></tr></table></figure>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。 客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器 的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字 段。</p>
<p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信 息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的 泄露。</p>
<p>另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直 沿用这个错误的拼写。</p>
<h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">TE</span>: gzip, deflate;q=<span class="hljs-number">0</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相 对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于 传输编码。</p>
<p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分 块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">TE:</span> trailers<br></code></pre></td></tr></table></figure>

<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">User</span>-Agent: Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; WOW<span class="hljs-number">64</span>; rv:<span class="hljs-number">13</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">2010010</span><br></code></pre></td></tr></table></figure>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传 达给服务器。</p>
<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件 地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服 务器的名称。 </p>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>
<h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p><img src="http://dengw.xyz/blog/180814/H1f57jFldI.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>图：当不能处理范围请求时，Accept-Ranges: none</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Accept</span>-Ranges: bytes<br></code></pre></td></tr></table></figure>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。</p>
<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为 none。 </p>
<h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p><img src="http://dengw.xyz/blog/180814/8C1Fb7gCGF.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。</p>
<p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次 发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。 </p>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p><img src="http://dengw.xyz/blog/180814/H5DGaBaIG7.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> <span class="hljs-string">&quot;82e22293907ce725faf67773957acd12&quot;</span><br></code></pre></td></tr></table></figure>

<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串 形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有 统一的算法规则，而仅仅是由服务器来分配</p>
<p><img src="http://dengw.xyz/blog/180814/bf6ClBl94A.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览 器访问 <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com/</a> 时，就会返回中文版对应的资源，而 使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下 载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<p>强 ETag 值和弱 Tag 值 : ETag 中有强 ETag 值和弱 ETag 值之分。 </p>
<ul>
<li><p>强 ETag 值<br>强 ETag 值，不论实体发生多么细微的变化都会改变其值。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> <span class="hljs-string">&quot;usagi-1234&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>弱 ETag 值<br>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">ETag:</span> W/<span class="hljs-string">&quot;usagi-1234&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p><img src="http://dengw.xyz/blog/180814/EgblJ49c5k.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">Location: http:<span class="hljs-regexp">//</span>www.usagidesign.jp/sample.html<br></code></pre></td></tr></table></figure>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置 不同的资源。</p>
<p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强 制性地尝试对已提示的重定向资源的访问。</p>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Proxy</span>-Authenticate: Basic realm=<span class="hljs-string">&quot;Usagidesign Auth&quot;</span><br></code></pre></td></tr></table></figure>

<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送 给客户端。</p>
<p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在 于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间 进行认证时，首部字段 WWW-Authorization 有着相同的作用。</p>
<h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><p><img src="http://dengw.xyz/blog/180814/9gDiD7A7ih.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Retry</span>-After: <span class="hljs-number">120</span><br></code></pre></td></tr></table></figure>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要 配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使 用。</p>
<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。 </p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><img src="http://dengw.xyz/blog/180814/8DgmmKBdla.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">17</span> (Unix)<br></code></pre></td></tr></table></figure>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版 本号和安装时启用的可选项。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Server</span>: Apache/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span> (Unix) PHP/<span class="hljs-number">5</span>.<span class="hljs-number">2</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p><img src="http://dengw.xyz/blog/180814/fFE3hbf2FE.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>图：当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓 存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Vary: <span class="hljs-keyword">Accept</span>-Language<br></code></pre></td></tr></table></figure>
<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关 于本地缓存使用方法的命令。</p>
<p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若 再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回 缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相 同，因此必须要从源服务器重新获取资源。</p>
<h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">WWW</span><span class="hljs-operator">-</span><span class="hljs-built_in">Authenticate</span><span class="hljs-operator">:</span> <span class="hljs-variable">Basic</span> <span class="hljs-variable">realm</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Usagidesign Auth&quot;</span><br></code></pre></td></tr></table></figure>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端 适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和 带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。 </p>
<p>上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。</p>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p><img src="http://dengw.xyz/blog/180814/cif77Ghaj5.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Allow:</span> <span class="hljs-keyword">GET</span>, HEAD<br></code></pre></td></tr></table></figure>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回。 </p>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><figure class="highlight csp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csp"><span class="hljs-attribute">Content-Encoding</span>: gzip`<br></code></pre></td></tr></table></figure>
<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>
<p>主要采用以下 4 种内容编码的方式。（各方式的说明请参考请求首部字段中 Accept-Encoding 字段）。</p>
<ul>
<li>gzip</li>
<li>compress</li>
<li> deflate</li>
<li> identity </li>
</ul>
<h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">Content</span>-Language: zh-<span class="hljs-meta">CN</span><br></code></pre></td></tr></table></figure>
<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言 （指中文或英文等语言）。</p>
<h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">15000</span><br></code></pre></td></tr></table></figure>
<p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字 节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。</p>
<h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">Content-Location</span>: <span class="hljs-attribute">http</span>:<span class="hljs-comment">//www.hackr.jp/index-ja.html</span><br></code></pre></td></tr></table></figure>
<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。 比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当 返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 <a target="_blank" rel="noopener" href="http://www.hackr.jp/">http://www.hackr.jp/</a> 返回的对象却是 <a target="_blank" rel="noopener" href="http://www.hackr.jp/index-ja.html">http://www.hackr.jp/index-ja.html</a> 等类似情况） </p>
<h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><p><img src="http://dengw.xyz/blog/180814/c70A6j3A9F.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"><br>图：客户端会对接收的报文主体执行相同的 MD5 算法，然后与首 部字段 Content-MD5 的字段值比较</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Content</span>-MD<span class="hljs-number">5</span>: OGFkZDUwNGVhNGY<span class="hljs-number">3</span>N<span class="hljs-number">2</span>MxMDIwZmQ<span class="hljs-number">4</span>NTBmY<span class="hljs-number">2</span>IyTY==<br></code></pre></td></tr></table></figure>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检 查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编 码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进 制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接 收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p>
<p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出 恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味 着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户 端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过 的。</p>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p><img src="http://dengw.xyz/blog/180814/6FhfB3241j.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Content</span>-Range: bytes <span class="hljs-number">5001</span>-<span class="hljs-number">10000</span>/<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。</p>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/html; charset=UTF<span class="hljs-number">-8</span><br></code></pre></td></tr></table></figure>
<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 type/subtype 形式赋值。 </p>
<p>参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。 </p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><img src="http://dengw.xyz/blog/180814/jHg7ekA857.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Expires</span>: Wed, <span class="hljs-number">04</span> Jul <span class="hljs-number">2012</span> <span class="hljs-number">08</span>:<span class="hljs-number">26</span>:<span class="hljs-number">05</span> GMT<br></code></pre></td></tr></table></figure>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过 指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求 资源。</p>
<p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。 </p>
<p>但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。 </p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p><img src="http://dengw.xyz/blog/180814/Ki1fECLmfD.png?imageslim" srcset="/img/loading.gif" lazyload alt="enter image description here"></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Last</span>-Modified: Wed, <span class="hljs-number">23</span> May <span class="hljs-number">2012</span> <span class="hljs-number">09</span>:<span class="hljs-number">59</span>:<span class="hljs-number">55</span> GMT<br></code></pre></td></tr></table></figure>
<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进 行动态数据处理时，该值有可能会变成数据最终修改时的时间。 </p>
<h3 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h3><p>上面列的这些首部字段都是被编入标准化 HTTP/1.1 的 RFC2616 中的字段，但是还有一些很重要的，经常使用的，却没有列入该标准的字段，管理服务器与客户端之间状态的 Cookie 就包括了这些字段。</p>
<p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的 状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。 </p>
<p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路 径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。<br>为 Cookie 服务的首部字段包括：</p>
<ul>
<li>Set-Cookie：开始状态管理所使用的Cookie信息，是一种响应首部字段 </li>
<li>Cookie：服务器接收到的Cookie信息，是一种请求首部字段</li>
</ul>
<h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Set</span>-Cookie: status=enable; expires=Tue, <span class="hljs-number">05</span> Jul <span class="hljs-number">2011</span> <span class="hljs-number">07</span>:<span class="hljs-number">26</span>:<span class="hljs-number">31</span> GMT; path<br></code></pre></td></tr></table></figure>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p>
<p>下面的表格列举了 Set-Cookie 的字段值。<br>| 属性 | 说明 |<br>| :——– | :——– |<br>| NAME=VALUE | 赋予 Cookie 的名称和其值（必需项）|<br>| expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|<br>| path=PATH | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录）|<br>| domain=域名 | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名）|<br>| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie |<br>| HttpOnly | 加以限制，使 Cookie 不能被 JavaScript 脚本访问 |</p>
<ul>
<li>expires 属性</li>
</ul>
<p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。 </p>
<p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session） 时间段内。这通常限于浏览器应用程序被关闭之前。</p>
<p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可 以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对 客户端 Cookie 的实质性删除操作。</p>
<ul>
<li>path 属性</li>
</ul>
<p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。 不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱 有期待。</p>
<ul>
<li>domain 属性 </li>
</ul>
<p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比 如，当指定 example.com 后，除 example.com 以外，<a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 或 www2.example.com 等都可以发送 Cookie。 </p>
<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</p>
<ul>
<li>secure 属性 </li>
</ul>
<p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才 可以发送 Cookie。</p>
<p>发送 Cookie 时，指定 secure 属性的方法如下所示。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Set</span>-Cookie: <span class="hljs-keyword">name</span>=value; secure<br></code></pre></td></tr></table></figure>
<p>以上例子仅当在 <a target="_blank" rel="noopener" href="https://www.example.com/%EF%BC%88HTTPS%EF%BC%89%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5">https://www.example.com/（HTTPS）安全连接的情况</a> 下才会进行 Cookie 的回收。也就是说，即使域名相同， <a target="_blank" rel="noopener" href="http://www.example.com/%EF%BC%88HTTP%EF%BC%89%E4%B9%9F%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F">http://www.example.com/（HTTP）也不会发生</a> Cookie 回收行为。 </p>
<p>当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行 回收。</p>
<ul>
<li>HttpOnly 属性 </li>
</ul>
<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本 无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。 </p>
<p>发送指定 HttpOnly 属性的 Cookie 的方法如下所示。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Set</span>-Cookie: <span class="hljs-keyword">name</span>=value; HttpOnly<br></code></pre></td></tr></table></figure>
<p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。 但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后 的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p>
<p> 虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的 主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了 防止 XSS 而开发的。 </p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Cookie: <span class="hljs-attribute">status</span>=enable<br></code></pre></td></tr></table></figure>
<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支 持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。 </p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/HTTP/">HTTP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">排序算法总结与java实现</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/">
                        <span class="hidden-mobile">二叉树三种遍历方式的Java实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
