<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-View的详细绘制流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/28/View%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-06-28T07:20:38.000Z" itemprop="datePublished">2018-06-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/28/View%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/">View的详细绘制流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>就不再增加阅读成本了，已经有一篇讲的非常详细的博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5a71014e7b1b">Android View的绘制流程</a>，然后可以再结合<code>Android 开发艺术探索</code>这本书，应该就可以很好地掌握这部分的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/28/View%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" data-id="ckqm6kpln0026xxr55ctugabn" data-title="View的详细绘制流程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-从XML布局文件到 VIew 绘制的全过程分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/25/%E4%BB%8EXML%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%20VIew%20%E7%BB%98%E5%88%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2018-06-25T09:28:57.000Z" itemprop="datePublished">2018-06-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/25/%E4%BB%8EXML%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%20VIew%20%E7%BB%98%E5%88%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/">从XML布局文件到 View 绘制的全过程分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇博客的篇幅可能有点长，最开始本来是想用几个部分分开讲解的，但是我觉得O老师说的很有道理，知识讲究一个体系，所以就想用一篇博客把 Android 中 View 相关的知识一起讲一下，对之前零碎的知识点能有一个整体的认识，从 Window 开始到 View 的绘制，希望通过这个流程，自己能够对这个在 Android 体系中重要性不亚于四大组件的 View 有一个更深刻的理解。</p>
<h2 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h2><h3 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h3><p>Surface 真的不是简单一两句话能够说清楚的，最开始本来是想把 Surface 一起学习了的，但是后来放弃了，它会涉及到 Android 中很底层的东西，比如 SurfaceFlinger的机制，真的挺复杂，也不是现在的我能够 get 得到的。但是为了能够更好地理解 Window 的概念，觉得还是要对 Surface 有一个基本的认识，下面这段话来自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7897d97d17cc">Android易混概念辨析之Surface,Window,View,SurfaceView,Bitmap</a>，可以帮助我们更好地理解 Window 的概念。</p>
<p>一个 Surface 就是一个对象，该对象持有一群像素（pixels），这些像素是要被组合到一起显示到屏幕上的。你在手机屏幕上看到的每一个 Window（如对话框、全屏的activity、状态栏）都有唯一一个自己的 surface，window 将自己的内容（content）绘制到该 surface 中。SurfaceFlinger 根据各个 surface 在Z轴上的顺序（Z-order）将它们渲染到最终的显示屏上。</p>
<h3 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h3><p>Window 即窗口，这个概念在 Android Framework 中的实现为 android.view.Window 这个抽象类，这个抽象类是对 Android 系统中的窗口的抽象。实际上，窗口是一个宏观的思想，它是屏幕上用于绘制各种 UI 元素及响应用户输入事件的一个矩形区域。结合上面介绍的 Surface 概念，窗口就是独占一个 Surface 实例的显示区域。见过一个很形象的比喻：我们可以把 Surface 看作是一块画布，应用可以通过 Canvas 或 OpenGL 在上面作画。画好之后，通过 SurfaceFlinger 将多块 Surface 按照特定的顺序（即Z-order）进行混合，而后输出到 FrameBuffer 中，这样用户界面就得以显示。</p>
<p>为了对 Window 能有一个更直观的概念，我们可以列举一些我们平时常见的 Window 实例，比如手机顶部的状态栏是一个Window, 全屏的<br>Activity, Toast 是一个窗口, Dialog 是一个窗口, 360卫士创建的悬浮球也是一个窗口。</p>
<p>下面给出创建一个 Window 的简单代码，这段代码参考了《Android 开发艺术探索》这本书，然后我们再从代码中来学习一些 Window 相关的知识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mWn = (WindowManager)getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">mFloatButton = <span class="keyword">new</span> Button(<span class="keyword">this</span>);</span><br><span class="line">mFloatButton.setText(<span class="string">&quot;Floating&quot;</span>);</span><br><span class="line">mFloatButton.setBackgroundColor(getResources().getColor(R.color.colorAccent));</span><br><span class="line">layoutParams = <span class="keyword">new</span> WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT,</span><br><span class="line">WindowManager.LayoutParams.WRAP_CONTENT, <span class="number">0</span>, <span class="number">0</span>, PixelFormat.TRANSPARENT);</span><br><span class="line">layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION;</span><br><span class="line">layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL</span><br><span class="line">		| WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">		| WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED;</span><br><span class="line">layoutParams.gravity = Gravity.LEFT | Gravity.TOP;</span><br><span class="line">layoutParams.x = <span class="number">200</span>;</span><br><span class="line">layoutParams.y = <span class="number">200</span>;</span><br><span class="line">mWn.addView(mFloatButton, layoutParams);</span><br></pre></td></tr></table></figure>
<p><strong>Flags</strong> 参数表示Window的属性，控制Window的显示特性。</p>
<p><strong>Type</strong>  参数表示Window的类型，Window 有三种类型，分别是应用 Window、子 Window 和系统 Window。应用类 Window 对应一个 Acitivity，子 Window 不能单独存在，需要依附在特定的父 Window 中，比如常见的一些 Dialog 就是一个子 Window。系统 Window是需要声明权限才能创建的 Window，比如 Toast 和系统状态栏都是系统 Window。</p>
<p>Window 是分层的，每个 Window 都有对应的 z-order 属性，层级大的会覆盖在层级小的 Window 上面，比如360悬浮球位于 Activity所在 Window 的上层、状态栏也位于 Activity所在 Window 的上层。这一点个人理解是借助 Surface 的 Z-order 属性实现的，不过有待验证。</p>
<p>在三种 Window 中，应用 Window 层级范围是 1<del>99，子 Window 层级范围是 1000</del>1999，系统 Window 层级范围是 2000~2999，我们可以用一个表格来直观的表示：</p>
<table>
<thead>
<tr>
<th>Window 类型</th>
<th>层级</th>
</tr>
</thead>
<tbody><tr>
<td>应用 Window</td>
<td>1~99</td>
</tr>
<tr>
<td>子 Window</td>
<td>1000~1999</td>
</tr>
<tr>
<td>系统 Window</td>
<td>2000~2999</td>
</tr>
</tbody></table>
<h3 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h3><p>Window 是一个抽象类，具体实现就是 PhoneWindow, 目前为止 PhoneWindow 是 Window 类的唯一实现类。</p>
<h3 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h3><p>DecorView是 FrameLayout 的子类，它可以被认为是 Android 视图树的根节点视图。DecorView 作为顶级 View，一般情况下它内部包含一个竖直方向的 LinearLayout，上面的标题栏(titleBar)，下面是内容栏(FrameLayout)，具体情况和 Android 版本和设置的主题有关。其中内容栏则是下文会提到的 mContentParent，有固定的id: android.R.id.content，通常我们在 Activity 中通过 setContentView 所设置的布局文件就是被加载到内容栏里，成为其唯一子View，在代码中可以通过如下方法来得到对应的布局。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup content = (ViewGroup) findViewById(android.R.id.content);  // 内容栏</span><br><span class="line">ViewGroup rootView = (ViewGroup) content.getChildAt(0);        // 布局文件对应的 View</span><br></pre></td></tr></table></figure>

<h3 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h3><p>是 ViewRoot 的实现类，它是连接 WindowManagerService 和 DecorView 的纽带，View 绘制的三大流程：测量(measure)、布局(layout)、绘制(draw) 均是通过 ViewRoot 来完成的。<br>ViewRoot 从名字上看很容易让人觉得是什么 View 的根节点，然而实际上它并不属于 View树 的一份子，它既非 View 的子类，也非 View 的父类。但是，它实现了 ViewParent 接口，这让它可以作为 View 的名义上的父视图。ViewRoot 继承了 Handler 类，可以接收事件并分发，Android 的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的。</p>
<h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="setContentView"><a href="#setContentView" class="headerlink" title="setContentView"></a>setContentView</h3><p>上面我们说了 Window 是用来装 View 的，那么一个 Window 是如何创建出来的呢？</p>
<p>带着这个问题我们继续探究，我们看到的手机屏幕上呈现出来的布局，是我们在一个 XML 文件中定义的，然后在 Activity 的 onCreate 函数中通过 setContentView 函数进行加载，我们的探究就是从这儿开始的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> @Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下 <strong>Activity#setContentView</strong> 的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">	//调用getWindow方法，返回mWindow</span><br><span class="line">    getWindow().setContentView(layoutResID);  </span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过追踪可以发现上面的 mWindow 是一个 Window 类型的对象，但是上面我们也提到了 Window 只是一个抽象类，因此它的 setContentView 也只是一个抽象方法，那么自然想到 Window 的子类了。查询资料发现， Window 有且仅有唯一一个实现类 — PhoneWindow.</p>
<p>这里需要我们先了解一下 Activity 的启动过程，由 ActivityThread 中的 performLaunchActivity() 来完成整个过程，这个过程会通过类加载器创建 Activity 的实例对象，并调用这个对象的 attach 方法为其关联运行过程中所依赖的一些列上下文环境变量，我们发现在 <strong>Activity#attach</strong> 方法中有如下实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">final void attach(Context context, ActivityThread aThread,</span><br><span class="line">Instrumentation instr, IBinder token, int ident,</span><br><span class="line">Application application, Intent intent, ActivityInfo info,</span><br><span class="line">CharSequence title, Activity parent, String id,</span><br><span class="line">NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	mWindow = new PhoneWindow(this);</span><br><span class="line">	mWindow.setCallback(this);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Activity 的 attach 方法中会创建一个 Activity 所属的 Window 的 PhoneWindow 对象并为其设置回调函数。额外提一下由于 Activity 对象实现了 Window 的 Callback 接口，因此当 Window 接收到外界的状态改变时就会回调 Activity 的方法。Window 的 Callback 接口中的方法有很多，列一些比较眼熟的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public interface Callback &#123;</span><br><span class="line">    public void onAttachedToWindow();</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event);</span><br><span class="line">    public View onCreatePanelView(int featureId);</span><br><span class="line">    public void onContentChanged();</span><br><span class="line">    public void onWindowFocusChanged(boolean hasFocus);</span><br><span class="line">    public void onDetachedFromWindow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看 Window 的创建，Activity 将具体实现交给了 Window，而 Window 的具体实现是 PhoneWindow，所以只需要看 PhoneWindow 的相关逻辑即可，下面给出 PhoneWindow#setContentView 的实现代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int layoutResID) &#123;</span><br><span class="line">    // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">    // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">    // before this happens.</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                getContext());</span><br><span class="line">        transitionTo(newScene);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">	    // 如果没有设置了FEATURE_CONTENT_TRANSITIONS，就会将布局文件填充至mContentParent</span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent); // ①</span><br><span class="line">    &#125;</span><br><span class="line">    // 通知Activity布局改变</span><br><span class="line">    final Callback cb = getCallback();</span><br><span class="line">    if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步是确定是否已经实例化 DecorView 和 mContentParent, 在具体的介绍之前，需要先清楚这里 mContentParent 成员是什么。</p>
<p>先看一下 <strong>mContentParent</strong> 的注解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// This is the view in which the window contents are placed. It is either</span><br><span class="line">// mDecor itself, or a child of mDecor where the contents go.</span><br><span class="line">private ViewGroup mContentParent;</span><br></pre></td></tr></table></figure>
<p>首先它的数据类型 ViewGroup，再结合<code>①</code>处代码可以得知，这个 mContentParent 是我们设置的布局(即main_activity.xml )的父布局。此外注释还提到了，这个 mContentParent 是 mDecor 本身或者是 mDecor 的一个子元素，mContentParent 是 mDecor 的子元素很好理解，但是为什么是 mDecor 本身呢？对于这一点，个人理解是当设置了 FEATURE_NO_ACTIONBAR，即设置了不显示标题栏的时候，此时 DecorView 内部的Linearlayout 就没有任何的意义，并且 DecorView 和 mContentParent 都采用的是 Framelayout 的布局类型，所以从布局的效果上来看可以认为 mContentParent 就是 mDecor 的本身。</p>
<p>到这里我们就把 Window 涉及到的所有 View 都介绍了一遍，下面给一张图形象地表示一下他们的关系：<br><img src="http://dengw.xyz/blog/180628/63FeffG9AL.png?imageslim)" alt="enter image description here"></p>
<p>对于这个图，还真是花了挺多功夫的，刚开始看了网上挺多的博客，但是发现都比较零散，没有一个比较系统的，完整介绍这个 View Tree 的，而且里面有一些概念很容易混淆，所以对各个 View 之间的关系不是十分的明确。后来通过对比各方面资料以及根据源码自己理解，也算是确定了他们的关系，绘制了上面的图。</p>
<p>概念清楚了我们接着看在 PhoneWindow 中的 installDecor() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">    if (mDecor == null) &#123;</span><br><span class="line">        //调用该方法创建new一个DecorView</span><br><span class="line">        mDecor = generateDecor();</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(true);</span><br><span class="line">        if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mContentParent == null) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line">        ...</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过 generateDecor 方法创建 DecorView实例.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected DecorView generateDecor() &#123;</span><br><span class="line">	return new DecorView(getContext(), -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候得到的 DecorView 还只是一个空白的 FrameLayout, 为了初始化 DecorView 的结构，PhoneWindow 还会通过 generateLayout 方法来加载布局到 DecorView 中，这个过程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> protected ViewGroup generateLayout(DecorView decor) &#123;</span><br><span class="line">	 </span><br><span class="line">	//将布局layout，添加至DecorView中</span><br><span class="line">	mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line"></span><br><span class="line">	//从布局中获取`ID_ANDROID_CONTENT`，并关联至contentParent</span><br><span class="line">	ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	//配置完成，DecorView根据已有属性调整布局状态</span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line"></span><br><span class="line">    return contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>展示的代码部分将布局添加到 DecorView 中，并且将 contentParent 布局中 id 为 ID_ANDROID_CONTENT 的 FrameLayout 绑定。所以我们可以通过 findViewById(ID_ANDROID_CONTENT) 获取到 contentParent. 其中 ID_ANDROID_CONTENT 的定义如下，这个 id 所对应的 ViewGroup 就是 mContentParent ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;</span><br></pre></td></tr></table></figure>
<p>上述整个步骤可以用下面的图表示：</p>
<p><img src="http://dengw.xyz/blog/180627/4Ag21f0ll3.png?imageslim"></p>
<h3 id="Window-的添加"><a href="#Window-的添加" class="headerlink" title="Window 的添加"></a>Window 的添加</h3><p>经过上面的步骤，DecorView 已经被创建并初始化完毕，Activity 的布局文件也已经成功添加到了 DecorView 的 mContentParent 中，但是这个时候 DecorView 还没有被 WindowManager 正式添加到 Window 中，我们的 View 还是不可见的，因为我们仅仅是加载了布局，并没有对View进行任何的测量、布局、绘制工作。在 View 进行测量流程之前，还要进行一个步骤，那就是把 DecorView 添加至 window中。</p>
<p>下面我们就来讨论这个过程，先上一个图来表示整个过程：<br><img src="http://dengw.xyz/blog/180627/i9ciHJkedj.png?imageslim"></p>
<p>我们继续看 Activity 启动的方法 handleLaunchActivity() 中调用的 handleResumeActivity() 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) &#123; </span><br><span class="line">    //...</span><br><span class="line">    ActivityClientRecord r = performResumeActivity(token, clearHide); // 这里会调用到onResume()方法</span><br><span class="line"></span><br><span class="line">    if (r != null) &#123;</span><br><span class="line">        final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">        //...</span><br><span class="line">        if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            r.window = r.activity.getWindow(); // 获得window对象</span><br><span class="line">            View decor = r.window.getDecorView(); // 获得DecorView对象</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);  // 不可见</span><br><span class="line">            ViewManager wm = a.getWindowManager(); // 获得windowManager对象</span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            if (a.mVisibleFromClient) &#123;</span><br><span class="line">                a.mWindowAdded = true;</span><br><span class="line">                wm.addView(decor, l); // 调用addView方法</span><br><span class="line">            &#125;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，首先配置 ActivityClientRecord，之后将 DecorView 设置为 INVISIBLE，因为此时 View 并未绘制完成，当前的 DecorView 只是一个有结构的空壳。 然后通过 WindowManager 将 DecorView 正式的添加到窗口上 wm.addView(decor, l)，这一步非常重要，它包括了2个很重要的过程：Window 的添加过程和 View 的绘制流程。</p>
<h4 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h4><p>从上面的代码可以看到我们是使用 WindowManager 来添加一个新的 Window的，我们可以通过WindowManager.LayoutParams 参数来设置 Window 的一些属性。WindowManager 是一个接口，它继承自 ViewManager 接口，ViewManager 有三个常用的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ViewManager&#123;</span><br><span class="line">    public void addView(View view, ViewGroup.LayoutParams params);</span><br><span class="line">    public void updateViewLayout(View view, ViewGroup.LayoutParams params);</span><br><span class="line">    public void removeView(View view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个方法其实就是 WindowManager 对外提供的主要功能，它可以创建一个 Window 并向其添加 View， 还可以更新 Window 中的 View, 另外如果想要删除一个 Window 就只要删除其中的 View 即可。</p>
<h4 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h4><p>上面我们已经知道添加一个 Window 是通过 WindowManager 的 addView 方法来实现的，WindowManager 也只是一个接口，它的实际实现类是 WindowManagerImpl 类。在 WindowManagerImpl 中 Window 的三大操作实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addView(View view, ViewGroup.LayoutParams params)</span><br><span class="line">&#123;</span><br><span class="line">	mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">@Override</span><br><span class="line">public void updateViewLayout(View view, ViewGroup.LayoutParams params)</span><br><span class="line">&#123;</span><br><span class="line">    mGlobal.updateViewLayout(view, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void removeView(View view)&#123;</span><br><span class="line">	mGlobal.removeView(view, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，WindowManagerImpl 并没有直接实现 Window 的三大操作，而是交给了 WindowManagerGlobal 类来处理。通过观察我们可以发现这实际上是使用桥接模式来实现的。WindowManagerImpl 内部含有一个WindowManagerGlobal 的实例，然后把所有操作就可以全部委托给 该实例来实现。</p>
<h4 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h4><p>我们看一下 WindowManagerGlobal 中的 addView 的部分代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123;</span><br><span class="line">	...</span><br><span class="line">	ViewRootImpl root;</span><br><span class="line">	View panelParentView = null;</span><br><span class="line">	</span><br><span class="line">	synchronized (mLock) &#123;</span><br><span class="line">		...</span><br><span class="line">		// 创建 ViewRootImpl 并将 View 添加到集合中</span><br><span class="line">		root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">		view.setLayoutParams(wparams);</span><br><span class="line">		mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // do this last because it fires off messages to start doing things</span><br><span class="line">    try &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">        // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            final int index = findViewLocked(view, false);</span><br><span class="line">            if (index &gt;= 0) &#123;</span><br><span class="line">                removeViewLocked(index, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中有2个比较重要的点</p>
<ol>
<li>在WindowManagerGlobal中有如下几个重要的集合</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//存储所有Window对应的View</span><br><span class="line">private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();</span><br><span class="line"></span><br><span class="line">//存储所有Window对应的ViewRootImpl</span><br><span class="line">private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();</span><br><span class="line"></span><br><span class="line">//存储所有Window对应的布局参数</span><br><span class="line">private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用 ViewRoot 的 setView 方法， 作用效果是 WindowManagerGlobal 将 View 的操作交给 ViewRootImpl来实现。</li>
</ol>
<p><strong>ViewRootImpl#setView</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">	...</span><br><span class="line">	requestLayout();</span><br><span class="line">	...</span><br><span class="line">	try &#123;</span><br><span class="line">		res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">		getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">		mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">		mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<ul>
<li>View绘制的入口</li>
</ul>
<p>ViewRootImpl 调用 requestLayout() 来完成 View 的绘制操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void requestLayout()&#123;</span><br><span class="line">   if(!mHandingLayoutInLayoutRequest)&#123;</span><br><span class="line">       checkThread();</span><br><span class="line">       mLayoutRequested = true;</span><br><span class="line">       scheduleTraversals();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>checkThread() 方法判断当前线程是否是主线程，如果是在子线程就会抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">    if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        throw new CalledFromWrongThreadException(</span><br><span class="line">            &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看，判断完线程后，接着调用 scheduleTraversals()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        ...</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">            Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduleTraversals中会通过 handler 去异步调用 mTraversalRunnable 接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">    ...</span><br><span class="line">    performTraversals();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而真正调用绘制的是 performTraversals() 方法，这个方法的核心如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;  </span><br><span class="line">    ......  </span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    ...</span><br><span class="line">    performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    ......  </span><br><span class="line">    performDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就很熟悉了，接着开始 View 的测量、布局、绘制这三大流程。这儿就不具体详细分析这三大流程了，后面会单独写一篇博客来介绍。</p>
<ul>
<li>通过 WindowSession 最终来完成 Window 的添加过程。</li>
</ul>
<p>在下面的代码中，mWindowSession 的类型是 IWindowSession，查阅资料得知它是一个 Binder 对象，真正的实现类是 Session。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(),mAttachInfo.mContentInsets, mInputChannel);</span><br></pre></td></tr></table></figure>
<p>在 Session 内部会通过 WindowManagerService 来实现 Window 的添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams, attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel)&#123;</span><br><span class="line">   return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道 WindowManagerService 运行在系统进程中。所以这里 IWindowSession 执行的 addtoDisplay 方法应该是 IPC 调用，接下来的Window 添加过程，具体 Window 在 WindowManagerService 内部是怎么添加的，就不对其进一步的分析，因为我们侧重的是整个添加 Window 的流程。</p>
<p>到现在我们就从 WindowManager 开始到具体 WindowManagerService 创建一个Window 的过程完成地过了一遍。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这是第一次写知识面这么广的博客，中间涉及到的过程非常的多，也暴露了自己存在的不足，首先是一个知识系完整的问题，写下来，感觉这些知识是一环扣一环的，是一个完整的链式调用，所以只要有哪一环没有理解透，那么对整个体系的理解就很困难，总之，收获满满。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/25/%E4%BB%8EXML%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E5%88%B0%20VIew%20%E7%BB%98%E5%88%B6%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/" data-id="ckqm6kpni0071xxr5a9mr05ie" data-title="从XML布局文件到 View 绘制的全过程分析" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Window/" rel="tag">Window</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-获取屏幕、状态栏、标题栏、内容栏方法总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/20/%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E6%A0%87%E9%A2%98%E6%A0%8F%E3%80%81%E5%86%85%E5%AE%B9%E6%A0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-06-20T06:29:51.000Z" itemprop="datePublished">2018-06-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/20/%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E6%A0%87%E9%A2%98%E6%A0%8F%E3%80%81%E5%86%85%E5%AE%B9%E6%A0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">获取屏幕、状态栏、标题栏、内容栏高度方法总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="屏幕区域划分"><a href="#屏幕区域划分" class="headerlink" title="屏幕区域划分"></a>屏幕区域划分</h3><p><img src="http://dengw.xyz/blog/180720/kF7Kef4Hm5.png?imageslim" alt="enter image description here"></p>
<p>在这张图中：</p>
<ul>
<li>紫色区域代表是整个屏幕</li>
<li>黄色区域是状态栏</li>
<li>红色区域是标题栏</li>
<li>绿色区域是内容栏，也是View绘制的区域</li>
<li>黑色区域是应用域</li>
</ul>
<p>从上面可以看出一些简单的数学关系，这些关系有时候可以根据我们的已知情况帮助我们求其他区域的高度。</p>
<blockquote>
<p>屏幕高度 = 应用域高度 + 状态栏高度<br>应用域高度 = 标题栏高度 + 内容栏高度</p>
</blockquote>
<h3 id="获取屏幕的宽度和高度"><a href="#获取屏幕的宽度和高度" class="headerlink" title="获取屏幕的宽度和高度"></a>获取屏幕的宽度和高度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WindowManager manager = <span class="keyword">this</span>.getWindowManager();</span><br><span class="line">DisplayMetrics outMetrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">manager.getDefaultDisplay().getMetrics(outMetrics);</span><br><span class="line"><span class="keyword">int</span> width = outMetrics.widthPixels;</span><br><span class="line"><span class="keyword">int</span> height = outMetrics.heightPixels;</span><br></pre></td></tr></table></figure>
<p>或者是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DisplayMetrics dm = <span class="keyword">this</span>.getResources().getDisplayMetrics();</span><br><span class="line"><span class="keyword">float</span> density = dm.density;</span><br><span class="line"><span class="keyword">int</span> width = dm.widthPixels;</span><br><span class="line"><span class="keyword">int</span> height = dm.heightPixels;</span><br></pre></td></tr></table></figure>

<p><strong>注：这两种方法都可以在Activity的任何生命周期函数中使用。</strong></p>
<h3 id="获取状态栏的高度"><a href="#获取状态栏的高度" class="headerlink" title="获取状态栏的高度"></a>获取状态栏的高度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getStatusBarHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> resourceId = getResources().getIdentifier(<span class="string">&quot;status_bar_height&quot;</span>, <span class="string">&quot;dimen&quot;</span>, <span class="string">&quot;android&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (resourceId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		height = getResources().getDimensionPixelSize(resourceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：这个方法可以在Activity的任何生命周期函数中使用。</strong></p>
<p>或者是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rect outRect = <span class="keyword">new</span> Rect();</span><br><span class="line">getWindow().getDecorView().getWindowVisibleDisplayFrame(outRect);</span><br><span class="line"><span class="keyword">int</span> height = outRect.top;</span><br></pre></td></tr></table></figure>

<p>这种方法的思想正式使用了<code>屏幕高度 = 应用域高度 + 状态栏高度</code>这种关系，状态栏的高度正好等于应用区域上边界的横坐标。</p>
<p><strong>注：这种方法只有确保View已经绘制完成后才能使用。</strong></p>
<h3 id="获取应用区域的高度"><a href="#获取应用区域的高度" class="headerlink" title="获取应用区域的高度"></a>获取应用区域的高度</h3><p>根据上面的数学关系，这个时候可以使用代数减法求的应用区域的高度，即使用屏幕的高度减去状态栏的高度。</p>
<p>另外一种方法值先获取到应用区域，然后上下边界纵坐标的差值就是整个应用区域的高度：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rect rect = <span class="keyword">new</span> Rect();</span><br><span class="line">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class="line"><span class="keyword">int</span> height = rect.bottom - rect.top;</span><br></pre></td></tr></table></figure>
<p><strong>注：这种方法只有确保 View 已经绘制完成后才能使用。</strong></p>
<h3 id="获取内容栏的高度"><a href="#获取内容栏的高度" class="headerlink" title="获取内容栏的高度"></a>获取内容栏的高度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup content = (ViewGroup) findViewById(android.R.id.content);  <span class="comment">// 内容栏</span></span><br><span class="line">ViewGroup rootView = (ViewGroup) content.getChildAt(<span class="number">0</span>);    <span class="comment">// 布局文件对应的 View</span></span><br><span class="line"><span class="keyword">int</span> height = content.getHeight();</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">int</span> height = rootView.getHeight();</span><br></pre></td></tr></table></figure>
<p><strong>注：这种方法只有确保 View 已经绘制完成后才能使用。</strong></p>
<h3 id="获取标题栏的高度"><a href="#获取标题栏的高度" class="headerlink" title="获取标题栏的高度"></a>获取标题栏的高度</h3><p>根据上面我们的数学关系可以的得到一些标题栏高度的求法，过程中需要用得到的值上面我们已经介绍了求的方法，直接套用就好了，知识需要注意一下使用的条件。</p>
<blockquote>
<p>height = 应用区域高度 - 内容栏高度<br>height = 内容栏上边界的纵坐标 - 状态栏的高度</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/20/%E8%8E%B7%E5%8F%96%E5%B1%8F%E5%B9%95%E3%80%81%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E6%A0%87%E9%A2%98%E6%A0%8F%E3%80%81%E5%86%85%E5%AE%B9%E6%A0%8F%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" data-id="ckqm6kpmj004oxxr58kvgbdni" data-title="获取屏幕、状态栏、标题栏、内容栏高度方法总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java中的23种设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/19/Java%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2018-06-19T08:09:25.000Z" itemprop="datePublished">2018-06-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/19/Java%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">Java中的23种设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这一次我选择站在巨人的肩膀上。</p>
<p>下面这些链接是我自己在学习设计模式中看到的一些非常好的文章，通俗易懂，同时结合代码理解，可以直接上手使用。</p>
<h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p>单例模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html">《JAVA与模式》之单例模式 — 博主：java_my_life</a></p>
<p>简单工厂模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html">《JAVA与模式》之简单工厂模式 — 博主：java_my_life</a></p>
<p>工厂方法模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html">《JAVA与模式》之工厂方法模式 — 博主：java_my_life</a></p>
<p>抽象工厂模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html">《JAVA与模式》之抽象工厂模式 — 博主：java_my_life</a></p>
<p>建造者模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html">《JAVA与模式》之建造者模式 — 博主：java_my_life</a></p>
<p>原型模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html">《JAVA与模式》之原型模式 — 博主：java_my_life</a></p>
<h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p>适配器模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html">《JAVA与模式》之适配器模式 — 博主：java_my_life</a></p>
<p>享元模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/26/2468499.html">《JAVA与模式》之享元模式 — 博主：java_my_life</a></p>
<p>代理模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/23/2466712.html">《JAVA与模式》之代理模式 — 博主：java_my_life</a></p>
<p>装饰模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html">《JAVA与模式》之装饰模式 — 博主：java_my_life</a></p>
<p>外观模式: <a target="_blank" rel="noopener" href="https://blog.csdn.net/jason0539/article/details/22775311">《JAVA与模式》之外观模式 — 博主：炸斯特</a></p>
<p>组合模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html">《JAVA与模式》之组合模式 — 博主：java_my_life</a></p>
<p>桥接模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html">《JAVA与模式》之桥接模式 — 博主：java_my_life</a></p>
<h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p>观察者模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/05/16/2502279.html">《JAVA与模式》之观察者模式 — 博主：java_my_life</a></p>
<p>策略模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html">《JAVA与模式》之策略模式 — 博主：java_my_life</a></p>
<p>命令模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html">《JAVA与模式》之命令模式 — 博主：java_my_life</a></p>
<p>模板方法模式: <a target="_blank" rel="noopener" href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html">《JAVA与模式》之模板方法模式 — 博主：java_my_life</a></p>
<p>中介者(调停者模式)模式: <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhengzhb/article/details/7430098">《JAVA与模式》之模板中介者模式 — 博主：愤怒的韭菜</a></p>
<p>责任链模式: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html">《JAVA与模式》之责任链模式 — 博主：java_my_life</a></p>
<p>解释器模式: </p>
<p>迭代模式: </p>
<p>备忘录模式: </p>
<p>状态模式: </p>
<p>访问者模式: </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/19/Java%E4%B8%AD%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckqm6kplb001bxxr5c1ixhojw" data-title="Java中的23种设计模式" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-关于Android坐标系的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/18/%E5%85%B3%E4%BA%8EAndroid%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2018-06-18T02:07:29.000Z" itemprop="datePublished">2018-06-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/18/%E5%85%B3%E4%BA%8EAndroid%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/">关于Android坐标系的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>对于坐标系，或者说Android的坐标系，平时在项目中或者说看源码的时候肯定都有接触到，特别是当你自定义控件的时候，发现在<code>onXXX()</code>函数里面很多都是关于坐标系的逻辑处理，因此感觉很有必要系统地学习总结一下Android坐标系相关的知识，这样才能更好更快脱离低级程序员的行列嘛haha</p>
<h3 id="三维坐标系"><a href="#三维坐标系" class="headerlink" title="三维坐标系"></a>三维坐标系</h3><p>首先要明确的一点是Android的坐标系是一个<strong>三维坐标系</strong>，包括X轴、Y轴、Z轴，其中X轴向右，Y轴向下、Z轴向上。Z轴到现在为止我都还没有接触过，这方面的总结以后再补上。</p>
<h3 id="Android屏幕区域划分"><a href="#Android屏幕区域划分" class="headerlink" title="Android屏幕区域划分"></a>Android屏幕区域划分</h3><p>这里参考了CSDN博主<strong>工匠若水</strong>的一篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/yanbober/article/details/50419117">Android屏幕区域划分</a><br>对于一个Android屏幕，我们可见的部分包括以下几个范围：<br><img src="http://dengw.xyz/blog/180720/aJh6GDiD2j.jpg?imageslim" alt="mark"></p>
<p>我觉得这个张图真的总结的非常好，可以解决很多开发中的问题，我们可以很直观的看到Android对于屏幕的划分定义。下面我们就给出这些区域里常用区域的一些坐标或者度量方式。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取整个屏幕区域宽度和高度，单位是px</span></span><br><span class="line">DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">getWindowManager().getDefaultDisplay().getMetrics(metrics);</span><br><span class="line"><span class="keyword">int</span> widthPixels = metrics.widthPixels;</span><br><span class="line"><span class="keyword">int</span> heightPixels = metrics.heightPixels;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获取应用程序App区域的宽度和高度，单位是px</span><br><span class="line">Rect rect = new Rect();</span><br><span class="line">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取状态栏的高度，单位是px</span></span><br><span class="line">Rect rect= <span class="keyword">new</span> Rect();</span><br><span class="line">getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class="line"><span class="keyword">int</span> statusBarHeight = rectangle.top;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取布局区域的宽度和高度，单位是px</span></span><br><span class="line">Rect rect = <span class="keyword">new</span> Rect();  </span><br><span class="line">getWindow().findViewById(Window.ID_ANDROID_CONTENT).getDrawingRect(rect);  </span><br></pre></td></tr></table></figure>

<h3 id="View区域的坐标系"><a href="#View区域的坐标系" class="headerlink" title="View区域的坐标系"></a>View区域的坐标系</h3><p>平时我们进行开发的时候主要就是集中在这个区域，这儿就再借鉴一下<strong>工匠若水</strong>的这篇博客，这篇博客真的是做到了授人以渔！<br><img src="http://dengw.xyz/blog/180720/fJGLjIcjI7.jpg?imageslim" alt="enter image description here"></p>
<p>通过上图我们可以很直观的给出View一些坐标相关的方法解释，不过必须要明确的是上面这些方法必须要在layout之后才有效，另外呢，我们经常可以看见很多getXXX()之类的函数来获取坐标，上面这张图片也给出解释。</p>
<blockquote>
<p>getLeft(): 返回View自身左边到父布局左边的距离</p>
<p>getTop(): 返回View自身顶边到父布局顶边的距离</p>
<p>getRight(): 返回View自身右边到父布局左边的距离</p>
<p>getBottom(): 返回View自身底边到父布局顶边的距离</p>
<p>getX(): 返回值为getLeft()+getTranslationX()，当setTranslationX()时getLeft()不变，getX()变</p>
<p>getY(): 返回值为getTop()+getTranslationY()，当setTranslationY()时getTop()不变，getY()变</p>
</blockquote>
<p>关于Translation相关的坐标理解在下面的移动对Android坐标系的影响部分会进一步的讲解。</p>
<p>同时也可以看见上图中给出了手指触摸屏幕时MotionEvent提供的一些方法解释，其中关于getX()需要特别注意一下，参考上面给的图片，如下：</p>
<p>MotionEvent坐标方法:</p>
<blockquote>
<p>getX(): 当前触摸事件距离当前View左边的距离 </p>
<p>getY(): 当前触摸事件距离当前View顶边的距离 </p>
<p>getRawX(): 当前触摸事件距离整个屏幕左边的距离 </p>
<p>getRawY():  当前触摸事件距离整个屏幕顶边的距离 </p>
</blockquote>
<p>上面解释了自定义View时各种获取宽高的一些含义，下面我们再来看看关于View获取屏幕中位置的一些方法，不过这些方法需要在Activity的 onWindowFocusChanged ()方法之后才能使用。如下图：<br><img src="http://dengw.xyz/blog/180720/76J3kf413J.jpg?imageslim" alt="enter image description here"></p>
<p>下面我们就给出上面这幅图涉及的View的一些坐标方法的结果（结果采用使用方法返回的实际坐标，不依赖上面实际绝对坐标转换，上面绝对坐标只是为了说明例子中的位置而已），如下：</p>
<table>
<thead>
<tr>
<th align="left">View的方法</th>
<th align="left">上图View1结果</th>
<th align="left">上图View2结果</th>
<th align="left">结论描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getLocalVisibleRect()</td>
<td align="left">(0, 0 - 410, 100)</td>
<td align="left">(0, 0 - 410, 470)</td>
<td align="left">获取View自身可见的坐标区域，坐标以自己的左上角为原点(0,0)，另一点为可见区域右下角相对自己(0,0)点的坐标，其实View2当前height为550，可见height为470</td>
</tr>
<tr>
<td align="left">getGlobalVisibleRect()</td>
<td align="left">(30, 100 - 440, 200)</td>
<td align="left">(30, 250 - 440, 720)</td>
<td align="left">获取View在屏幕绝对坐标系中的可视区域，坐标以屏幕左上角为原点(0,0)，另一个点为可见区域右下角相对屏幕原点(0,0)点的坐标</td>
</tr>
<tr>
<td align="left">getLocationOnScreen()</td>
<td align="left">(30, 100)</td>
<td align="left">(30, 250)</td>
<td align="left">坐标是相对整个屏幕而言，Y坐标为View左上角到屏幕顶部的距离</td>
</tr>
<tr>
<td align="left">getLocationInWindow()</td>
<td align="left">(30, 100)</td>
<td align="left">(30, 250)</td>
<td align="left">如果为普通Activity则Y坐标为View左上角到屏幕顶部（此时Window与屏幕一样大）；如果为对话框式的Activity则Y坐标为当前Dialog模式Activity的标题栏顶部到View左上角</td>
</tr>
</tbody></table>
<h3 id="移动对Android坐标系的影响"><a href="#移动对Android坐标系的影响" class="headerlink" title="移动对Android坐标系的影响"></a>移动对Android坐标系的影响</h3><p>其实这才是我真正想写的部分，进行控件的移动或者给空间添加的动画的时候肯定涉及到控件坐标的改变，并且使用不同的方法作用的结果还不一样，比如view动画和value动画。为了好好研究这个部分，自己尝试写了一个小demo来加深理解。使用了四个方法来改变view在整个视图中的位置，然后研究这些方法作用于view的哪一个参数。</p>
<p>整个app的布局如下：<br><img src="http://dengw.xyz/blog/180618/L6D5fjkdeG.png?imageslim" alt="enter image description here"></p>
<p>偏橘色的部分是一个TextView，里面的内容是一个字符串<code>我是内容</code>，它的父布局是一个<code>Linearlayout</code>。下面主要是我们的一些操作按钮，来作用与这个TextView修改它对应的参数，然后法僧位置改变。</p>
<p>在这个例子中主要是改变X轴方向的位置，Y轴的改变一个道理，使用的方法包括：</p>
<ul>
<li>使用View动画</li>
<li>使用ScollTo方法</li>
<li>使用属性动画</li>
<li>修改位置参数</li>
</ul>
<p>观察的变量有：</p>
<ul>
<li>getLeft() : 获取view左边界到夫层之间的距离</li>
<li>getX(): 获取view在父层这个相对坐标系里的X坐标</li>
<li>getTranslationX(): 获取view相对于父层的滑动距离</li>
<li>getScrollX(): 获取view里面的内容相对于view本身的滑动距离</li>
<li>getLocationOnScreenX：view相对于整个屏幕的X坐标</li>
</ul>
<p>好下面我们就开始，先输初始时的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Left: 150</span><br><span class="line">X:150.0</span><br><span class="line">TranslationX: 0.0</span><br><span class="line">LocationOnScreenX: 150</span><br><span class="line">LocationInWindowX: 150</span><br></pre></td></tr></table></figure>
<h4 id="使用view动画向右移动150px，过程如下，然后输出参数"><a href="#使用view动画向右移动150px，过程如下，然后输出参数" class="headerlink" title="使用view动画向右移动150px，过程如下，然后输出参数"></a>使用view动画向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/k1A1jcKj03.gif"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLeft: 150</span><br><span class="line">getX: 150.0</span><br><span class="line">getTranslationX: 0.0</span><br><span class="line">getscollX: 0</span><br><span class="line">getLocationOnScreenX: 150</span><br></pre></td></tr></table></figure>

<h4 id="使用ScollTo向右移动150px，过程如下，然后输出参数"><a href="#使用ScollTo向右移动150px，过程如下，然后输出参数" class="headerlink" title="使用ScollTo向右移动150px，过程如下，然后输出参数"></a>使用ScollTo向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/84K2A25EKl.gif"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLeft: 150</span><br><span class="line">getX: 150.0</span><br><span class="line">getTranslationX: 0.0</span><br><span class="line">getscollX: -150</span><br><span class="line">getLocationOnScreenX: 150</span><br></pre></td></tr></table></figure>

<h4 id="使用属性动画向右移动150px，过程如下，然后输出参数"><a href="#使用属性动画向右移动150px，过程如下，然后输出参数" class="headerlink" title="使用属性动画向右移动150px，过程如下，然后输出参数"></a>使用属性动画向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/26gKdbFfLl.gif"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLeft: 150</span><br><span class="line">getX: 300.0</span><br><span class="line">getTranslationX: 150.0</span><br><span class="line">getscollX: 0</span><br><span class="line">getLocationOnScreenX: 300</span><br></pre></td></tr></table></figure>

<h4 id="修改位置参数向右移动150px，过程如下，然后输出参数"><a href="#修改位置参数向右移动150px，过程如下，然后输出参数" class="headerlink" title="修改位置参数向右移动150px，过程如下，然后输出参数"></a>修改位置参数向右移动150px，过程如下，然后输出参数</h4><p><img src="http://dengw.xyz/blog/180618/L104ID2BC3.gif"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getLeft: 300</span><br><span class="line">getX: 300.0</span><br><span class="line">getTranslationX: 0.0</span><br><span class="line">sgetscollX: 0</span><br><span class="line">getLocationOnScreenX: 300</span><br></pre></td></tr></table></figure>
<p>总结一下：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">视觉效果</th>
<th align="left">分析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">view动画</td>
<td align="left">view整体向右移动</td>
<td align="left">参数没有任何改变，所以说只是视图的改变，当你的fillAfter属性设为false的时候，动画结束view还会自动回到之前的位置，这也是为什么在使用view动画后的位置上不能够响应点击事件的原因，可以理解为就是一个影子</td>
</tr>
<tr>
<td align="left">ScollTo</td>
<td align="left">view中的内容向右移动</td>
<td align="left">作用于ScollX，view本身的位置不会发生改变，改变的时view中内容为位置，ScollX参数表示view内容相对于view本身的偏移量，从名字看应该是只有scoll类的函数可以改变这个值</td>
</tr>
<tr>
<td align="left">属性动画</td>
<td align="left">view整体向右移动</td>
<td align="left">属性动画作用改变的是getTranslationX这个参数，view在父层的相对坐标以及在屏幕上的绝对坐标的改变，从而改变之后的view能够相应点击事件</td>
</tr>
<tr>
<td align="left">修改位置参数</td>
<td align="left">view整体向右移动</td>
<td align="left">这个就很好理解了，直接去修改位置参数，相当于把之前的view完全抹掉，然后在新的位置重新添加一个view</td>
</tr>
</tbody></table>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>我的理解就是这样了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/18/%E5%85%B3%E4%BA%8EAndroid%E5%9D%90%E6%A0%87%E7%B3%BB%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="ckqm6kplw002uxxr5gg7tc7wx" data-title="关于Android坐标系的理解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Android中dp与px之间的相互转化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/15/Android%E4%B8%ADdp%E4%B8%8Epx%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2018-06-15T01:49:04.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/15/Android%E4%B8%ADdp%E4%B8%8Epx%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/">Android中dp与px之间的相互转化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>写Android程序的时候在布局文件中控件的长度单位一般使用的<code>dp</code>，但是在Java类里面获取的或者处理的长度单位为<code>px</code>，所以经常需要两者之间的转化，下面就总结一下。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p><strong>屏幕大小</strong>：通常指的是屏幕对角线的长度，是一个物理尺寸，使用<code>英寸(in)</code>为单位来衡量，其中1in =2.54cm；</p>
</li>
<li><p><strong>分辨率</strong>：指手机屏幕的像素点个数，单位是<code>px</code>。比如说常见的<code>720*1280</code>，指的是宽有720个像素点，高有1280个像素点</p>
</li>
<li><p><strong>dpi</strong>：英文名：Dots Per Inch，即每英寸的像素点个数。例如：<code>320X480</code>分辨率的手机，宽2in，高3in，那么每英寸像素点个数(dpi)是:320/2=160. 使用正方形像素点横纵向计算结果一样，原因是大部分手机屏幕使用正方形的像素点，更严格上来说是计算对角线px / 对角线in</p>
</li>
<li><p><strong>屏幕密度(density)</strong>: 表示每英寸有多少个显示点，定义和dpi非常像，两者的关系是<code>density = dpi/160</code>, 这个是对dpi的一个规范，160dpi就是密度为1。也可以可以直接理解为dpi是屏幕密度的单位。</p>
</li>
<li><p>**dp(dip)**：每英寸像素，是一种基于屏幕密度的抽象单位，android特有的。规定在屏幕密度为1也就是 dpi=160 的屏幕上，1dp = 1px, dp与px的一般性关系是<code>px = dp (dpi / 160)</code>，在 Android 开发中使用 dp 作为控件爱的长度单位是为了使得开发者设置的长度能够根据不同屏幕(分辨率/尺寸也就是dpi)获得不同的像素(px)数量，也就是 dp 会随着不同屏幕而改变控件长度的像素数量。</p>
</li>
</ul>
<p>另外呢我们在<code>drawable</code>文件夹下面经常看见好几个dpi相关的文件夹，分别对应的是：</p>
<blockquote>
<p>ldpi 文件夹下对应的密度为120dpi, 对应的分辨率为240<em>320；<br>mdpi 文件夹下对应的密度为160dpi, 对应的分辨率为320</em>480；<br>hdpi 文件夹下对应的密度为240dpi, 对应的分辨率为480<em>800；<br>xhdpi 文件夹下对应的密度为320dpi, 对应的分辨率为720</em>1280；<br>xxhdpi 文件夹下对应的密度为480dpi, 对应的分辨率为1080*1920；</p>
</blockquote>
<h3 id="转化关系："><a href="#转化关系：" class="headerlink" title="转化关系："></a>转化关系：</h3><p>给出一个两者的转化函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据手机的分辨率从 dp 的单位 转成为 px(像素)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dp2px</span><span class="params">(Context context, <span class="keyword">float</span> dpValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (dpValue * scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据手机的分辨率从 px(像素) 的单位 转成为 dp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">px2dp</span><span class="params">(Context context, <span class="keyword">float</span> pxValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (pxValue / scale + <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于-sp"><a href="#关于-sp" class="headerlink" title="关于 sp"></a>关于 sp</h3><p>sp 与缩放无关的抽象像素（Scale-independent Pixel）。sp 和 dp 很类似但唯一的区别是，sp 还会根据用户的字体大小偏好来缩放。Android系统允许用户自定义文字尺寸大小（小、正常、大、超大等等），当文字尺寸是“正常”时 1sp=1dp=0.00625 英寸，而当文字尺寸是“大”或“超大”时，1sp&gt;1dp=0.00625英寸。类似我们在windows里调整字体尺寸以后的效果——窗口大小不变，只有文字大小改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/15/Android%E4%B8%ADdp%E4%B8%8Epx%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96/" data-id="ckqm6kpku0009xxr5cprl6wx9" data-title="Android中dp与px之间的相互转化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-美图实习周报-week1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/06/14/%E7%BE%8E%E5%9B%BE%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A5-week1/" class="article-date">
  <time class="dt-published" datetime="2018-06-14T05:53:33.000Z" itemprop="datePublished">2018-06-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/06/14/%E7%BE%8E%E5%9B%BE%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A5-week1/">美图实习周报-week1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还是一贯的习惯，人学会总结才能收获更多。来到美图实习也有一个星期了，这一个星期下来，收获很多，也认识到现在的自己有多么的弱。没办法，只有一步一步地来。</p>
<p>I want to be stronger！</p>
<h2 id="这一周都做了什么"><a href="#这一周都做了什么" class="headerlink" title="这一周都做了什么"></a>这一周都做了什么</h2><p>初来咋到，这一周师兄给了一个小项目先热热身，虽然只是一个小项目，但是时间花的真挺多的。<br>师兄给的项目是模仿<code>Camera 360 lite</code>版本滤镜打开动画，做出来的效果如下：<br><img src="http://dengw.xyz/blog/180614/kilIdD9kCm.gif" alt="mark"></p>
<p>大概的过程就是：实现一个支持drop down的菜单栏，并且是一个具有两级菜单的菜单栏，最开始，菜单都是隐藏的，当点击下方的按钮，出发条件，显示出一级菜单，并且这是一个滑动的过程，弹性的移动，一级菜单可以从左向右滑动，当点击点击一级菜单中的某个item，显示出对应的二级菜单，这个过程也是动态的，这也是这个项目中的一个难点所在，下面详细讲解，二级菜单也可以左右滑动，点击某个item，然后to do something. 每个二级菜单的最左边有一个fixed 返回按钮，它不会随着二级菜单的滑动而移动，当前及这个返回按钮，会返回之前进入二级菜单时的一级菜单，这个过程也是动态，同时也是本此项目的一个难点所在，也下面详细讲解。最下方的按钮控制真个菜单的隐藏与显示，当菜单是显示的时候，不管显示的一级菜单还是二级菜单，点击都要隐藏整个菜单，同理，当整个菜单隐藏的时候，点击后显示。</p>
<h2 id="怎么实现的"><a href="#怎么实现的" class="headerlink" title="怎么实现的"></a>怎么实现的</h2><h3 id="在布局上"><a href="#在布局上" class="headerlink" title="在布局上"></a>在布局上</h3><p>首先两个菜单，根据效果，选择使用<code>RecylerView</code>实现，这里为什么没有选择<code>ListView</code>呢？因为有很多动画，使用<code>RecylerView</code>更好实现，功能更多，并且能用<code>ListView</code>实现的肯定<code>RecylerView</code>也能实现。在控件的层次上，最下层需要是二级菜单，中间一层是一级菜单，最上面一层是蓝色的部分，i还有就是fixed按钮需要在二级菜单的上层。具体布局文件可以看博客最后面给的项目链接。<br>还有一个比较有记录价值的就是简单的实现一个圆形按钮，首先在drawable中添加<code>circle_background_for_image_button.xml</code>文件，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 填充色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;@color/white&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 圆角 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;90dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后把该文件赋值给控件的<code>background</code>属性就Ok了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageButton</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/fixedButton&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignBottom</span>=<span class="string">&quot;@id/menu2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;5dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginLeft</span>=<span class="string">&quot;10dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/circle_background_for_image_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_keyboard_return_grey_500_24dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="动画的实现"><a href="#动画的实现" class="headerlink" title="动画的实现"></a>动画的实现</h3><h4 id="一级菜单的弹性滑动"><a href="#一级菜单的弹性滑动" class="headerlink" title="一级菜单的弹性滑动"></a>一级菜单的弹性滑动</h4><p>对于一级菜单，首先是一个弹性滑动，这里需要一个动画效果，然后移动后还能够响应点击事件，所以这就需要使用是属性动画来实现，所以代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用动画平滑移动view指定的距离</span></span><br><span class="line"><span class="comment"> * @param1 要移动的view</span></span><br><span class="line"><span class="comment"> * @param2 标志位，值为true的时候下移，值为false的时候上移</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveViewSmooth</span><span class="params">(View view, <span class="keyword">boolean</span> sign)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> from = view.getTranslationY(), to;</span><br><span class="line">    <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">        to = from + fromDpToPx();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        to = from - fromDpToPx();</span><br><span class="line">    &#125;</span><br><span class="line">    ObjectAnimator.ofFloat(view, <span class="string">&quot;translationY&quot;</span>, from, to).setDuration(<span class="number">400</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NOTE: 这里面的<code>fromDpToPx()</code>函数是一个将固定Dp（控件的高度）值转化为px值的函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将dp = 60的值转化为对应px值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">fromDpToPx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> scale = getApplicationContext().getResources().getDisplayMetrics().density;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span> * scale + <span class="number">0.5f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="显示二级菜单"><a href="#显示二级菜单" class="headerlink" title="显示二级菜单"></a>显示二级菜单</h4><p>这个过程如效果图：点击屏幕上的某个一个菜单，从该位置处开始显示二级菜单，并且是从中间向两边逐个显示二级菜单的item，最后同时到达各自的边界。<br>对于这个动画，我们要明确一下几点，也是要解决的问题：</p>
<ol>
<li>动画的开始位置是你点击的一级菜单的横坐标</li>
<li>然后根据坐标确定二级菜单的哪些item是向左移动，哪些是向右移动的</li>
<li>动画分为左边和右边两部分，每个部分的动画不一样，所以不能给整个<code>RecylerView</code>添加动画，<code>LayoutAnimation</code>就不用考虑了.</li>
<li>每个item的动画是同时开始，同时结束的，动画的时间一样，但是每个item的移动距离不一样，所以需要为每个二级菜单的item设置一个动画，动画的属性都不完全一样</li>
</ol>
<p>下面就一个问题一个问题地解决。</p>
<ol>
<li>获取所点击item的横坐标。<br>对于这个问题，我们先要明白，在<code>Activity</code>或者<code>Fragment</code>中的是一个<code>RecylerView</code>的实例，是没有办法获取到其中一个Item的横坐标的，那有什么办法呢，方法就是在<code>Adapter</code>中获取，并且还只有在能获取<code>MotionEvent</code>的函数中才能获取坐标信息，因此在<code>Adapter</code>中的<code>onClick</code>函数中获取不到，因为该函数没有捕捉<code>MotionEvent</code>，那怎么办呢？我们发现<code>View</code>的<code>onTouch</code>函数会捕捉<code>MotionEvent</code>。因此一个可以解决问题的方案是：在<code>adapter</code>的<code>onBindViewHolder</code>函数中重写<code>holder.itemView</code>的<code>setOnTouchListener</code>函数，在该函数中记录最近一次点击的横坐标，然后在需要的时候通过<code>Adapter</code>返回给<code>Acticity</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">       holder.name.setText(itemList.get(position).getName());</span><br><span class="line">       holder.itemView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">               click.onItemClick(holder.getAdapterPosition());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">// 获取所点击Item相对于屏幕的横坐标</span></span><br><span class="line">       holder.itemView.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View view, MotionEvent motionEvent)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (motionEvent.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                   rawX = motionEvent.getRawX();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//这里要返回false,返回true会使点击事件无效</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getRawX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rawX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中需要注意的是<code>onTouch</code>函数这里需要返回false，不然会和<code>onClick</code>函数冲突是<code>onClick</code>函数失效。</p>
<ol start="2">
<li> 确定二级菜单item的移动方向<br>首先对于二级菜单的移动，因为每个item的动画都不一样，因此只有在二级菜单的<code>adapter</code>中的<code>onBindViewHolder</code>函数中给每个item添加动画，因此在new一个二级菜单的    <code>Adapter</code> 的时候需要把刚得到的坐标作为参数传递给二级菜单的    <code>Adapter</code>内部。这里我们把位置参数转化为<code>position</code>传递进去，转化的代码逻辑很简单,<code>fromDpToPx()</code>上面已经提过。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取二级菜单动画开始的下标</span></span><br><span class="line"><span class="comment"> * @param 所点击一级菜单item的横坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getStartPosition</span><span class="params">(<span class="keyword">float</span> rawX)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((rawX - fromDpToPx()) &gt;= <span class="number">0.0001</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        rawX -= fromDpToPx();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二级菜单的<code>adapter</code>中获取到这个<code>position</code>参数之后，<code>adapter</code>内部支持重写一个<code>getItemViewType</code>函数，这样就可以根据item的下标与动画开始下标的关系，决定item的移动方向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position &gt; startPosition) &#123;</span><br><span class="line">        <span class="keyword">return</span> RIGHT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(position &lt; startPosition)&#123;</span><br><span class="line">        <span class="keyword">return</span> LEFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MIDDLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>因为每个item移动的距离都有差别，所以不能使用<code>xml</code>文件定义定义动画的方式为item添加动画，需要根据位置的关系使用java代码动态添加。这里使用了以下几类：<code>TranslateAnimation</code>、<code>ScaleAnimation</code>、<code>AlphaAnimation</code>。<br>这里需要补充的一点就是当你使用java代码要为同一个View添加多个动画的时候，可以使用动画集合<code> AnimationSet</code>。</p>
</li>
<li><p>为每个item添加特定的动画属性，平移动画的距离由动画开始位置与item所在位置的关系决定，结合上面讲的这里就比较好实现了。</p>
</li>
</ol>
<h4 id="关闭二级菜单"><a href="#关闭二级菜单" class="headerlink" title="关闭二级菜单"></a>关闭二级菜单</h4><p>关闭二级菜单类似与一个关门的效果，但是有一点不同的是之前在屏幕上哪个位置打开的二级菜单，那么关闭的时候二级菜单的结束位置也要在这个位置。其实动画的设置和开始动画挺像的，肯定位置关系添加动画属性，所以这不是难点。首先我们也明确这个动画是作用于每个item的，不是作用于个<code>RecylerView</code>，这和开始动画有点一样，但也有不一样的地方。开始动画我们是在<code>adapter</code>的<code>onBinderView</code>函数中添加的，而<code>onBinderBinder</code>函数是<code>adapter</code>的生命周期函数，是可以自发执行的，但是当我们关闭二级菜单的时候，<code>adapter</code>的生命周期中并没有这样一个类似的函数供我们来调用，这样我们就不能获取到每个item，相应的也不能把动画添加给每个item，这么办呢？这个问题困扰了我很久，始终找不到什么好的解决方法，昨天下午突然灵光一闪，我在adapter中添加一个<code>ViewHolder</code>类型的属性，然后在<code>onCreateViewHolder</code>中把create出来的<code>ViewHolder</code>实例添加进容器里面，这样我们就能在非生命周期函数中操作这些item，达到想要的效果。<br>这个部分值得留意的获取一个RecylerView当前可见Item的下标范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取secondMenu可见item范围的下值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getFirstVisibleItemPosition</span><span class="params">(RecyclerView view)</span> </span>&#123;</span><br><span class="line">    LinearLayoutManager layoutManager = (LinearLayoutManager) view.getLayoutManager();</span><br><span class="line">    <span class="keyword">return</span> layoutManager.findFirstVisibleItemPosition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取secondMenu可见item范围的上值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLastVisibleItemPosition</span><span class="params">(RecyclerView view)</span> </span>&#123;</span><br><span class="line">    LinearLayoutManager layoutManager = (LinearLayoutManager) view.getLayoutManager();</span><br><span class="line">    <span class="keyword">return</span> layoutManager.findLastVisibleItemPosition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他一些实现"><a href="#其他一些实现" class="headerlink" title="其他一些实现"></a>其他一些实现</h4><blockquote>
<p>尝试了facebook开源框架<a target="_blank" rel="noopener" href="http://facebook.github.io/rebound/">rebound</a>的使用，可以添加一个弹簧效果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * item平移动画结束后的弹簧效果</span></span><br><span class="line"><span class="comment"> * @param 要作用的view</span></span><br><span class="line"><span class="comment"> * @param 标记位，用于判断左右方向（true: 向左， false: 向右）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSpringEffect</span><span class="params">(<span class="keyword">final</span> View viewToAnim, <span class="keyword">final</span> <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</span><br><span class="line">    Runnable startSpringAnimation = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SpringConfig config = <span class="keyword">new</span> SpringConfig(<span class="number">250</span>, <span class="number">25</span>);</span><br><span class="line">            Spring spring = SpringSystem.create().createSpring();</span><br><span class="line">            spring.setSpringConfig(config);</span><br><span class="line">            spring.addListener(<span class="keyword">new</span> SimpleSpringListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSpringUpdate</span><span class="params">(Spring spring)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">float</span> val;</span><br><span class="line">                    <span class="keyword">if</span>(isLeft) &#123;</span><br><span class="line">                        val = (<span class="keyword">float</span>) (-MAX_SPRING_LENGTH - spring.getCurrentValue());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        val = (<span class="keyword">float</span>) (MAX_SPRING_LENGTH - spring.getCurrentValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                    viewToAnim.setTranslationX(val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span>(isLeft) &#123;</span><br><span class="line">                spring.setEndValue(-MAX_SPRING_LENGTH);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                spring.setEndValue(MAX_SPRING_LENGTH);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    viewToAnim.postDelayed(startSpringAnimation, ANIMATATE_DURATION - <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外一个技巧就是实现延时动画</p>
</blockquote>
<p>这个项目中有这样一个需求，在平移动画结束的时候再添加一个弹性效果，可以使用<code>postDelayed()</code>+ <code>Runnable</code>的方法，代码看上面<code>rebound</code>的部分。</p>
<blockquote>
<p>还对之前自己对adapter的使用方法做了一个纠正</p>
</blockquote>
<p>之前传入<code>Adapter</code>中数据参数都是 <code>List&lt;Map&lt;String, Object&gt;&gt;</code>类型的，现在体会了这对面向对象特性的不友好，可以理解为 <code>List&lt;Map&lt;String, Object&gt;&gt;</code>是为view层的，而 <code>List&lt;Bean&gt;</code>model层的，维护view的代价肯定比维护model层的代价更大。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/duang0626/Camera">项目github地址</a></p>
<h2 id="最后再说点什么"><a href="#最后再说点什么" class="headerlink" title="最后再说点什么"></a>最后再说点什么</h2><p>上面说的这些方法都是自己慢慢尝试出来的，并没有一上来就想到，也让我体会到经验的重要性。所以说，继续加油吧少年！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/06/14/%E7%BE%8E%E5%9B%BE%E5%AE%9E%E4%B9%A0%E5%91%A8%E6%8A%A5-week1/" data-id="ckqm6kpmi004lxxr5a869gmu2" data-title="美图实习周报-week1" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Animation/" rel="tag">Animation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RecylerView/" rel="tag">RecylerView</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-关于Java内存机制的理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/05/04/%E5%85%B3%E4%BA%8EJava%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2018-05-04T06:41:43.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/05/04/%E5%85%B3%E4%BA%8EJava%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/">关于Java内存机制的理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在这次春招的过程中，很多次都会被问到与Java内存相关的问题，自己回答的不太好，现在春招结束了，就Java内存相关的知识好好总结一下。</p>
<h2 id="Java内存区域划分"><a href="#Java内存区域划分" class="headerlink" title="Java内存区域划分"></a>Java内存区域划分</h2><p>Java虚拟机在执行java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域，在看相关的知识之前。我一直以为Java内存就是由堆内存(Heap)以及栈内存(Stack)，其实这种说法不是很准确的，实际的Java的内存划分要更复杂一些，这种说法比较印象流，下面就分别从相对广义以及相对狭义的角度来介绍与。</p>
<h3 id="广义的Java内存划分"><a href="#广义的Java内存划分" class="headerlink" title="广义的Java内存划分"></a>广义的Java内存划分</h3><p>在JVM内部，Java内存模型把内存分成了两部分：栈区和堆区，下图展示了Java内存模型在JVM中的逻辑视图：</p>
<p><img src="http://dengw.xyz/hexo-blog/180504/jC1lCHEHFh.png"></p>
<p><strong>栈区，也被称为线程栈</strong>，为每个线程所私有的，其生命周期和线程相同，包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。<br>不同线程的线程栈之间相互独立，一个线程只能访问自己的线程栈，里面存储的数据对其他线程不可见。<br>在线程栈存放了编译阶段可知的所有基本数据类型（byte, char, boolean, short, int, long, float, double)，对象引用（注意并不是对象本身，只是一个指向对象起始地址的引用指针）。</p>
<p><strong>堆区</strong>包含了Java应用创建的所有对象实例，不管对象是哪个线程创建的。对上面说到的对象引用，就是这个对象存储到堆中，在栈中获得一个该对象在堆中的地址，所以栈中的只是一个引用指针。</p>
<p>下图具体的展示了在栈区以及堆区存储的数据类型：</p>
<p><img src="http://dengw.xyz/hexo-blog/180504/DKbLabC17d.png"></p>
<p>另外一点就是Static类型的变量存储在堆区，其实事实上这是存储在Java虚拟机的方法区中，虽然java虚拟机把方法区描述为堆的一个逻辑部分，但是方法区还有一个别名叫做Non-Heap(非堆)，说明实际上两个区域应该是分开的，后面比较详细的介绍。</p>
<p>堆中的对象可以被多线程共享。如果一个线程获得一个对象的应用，它便可访问这个对象的成员变量。如果两个线程同时调用了同一个对象的同一个方法，那么这两个线程便可同时访问这个对象的成员变量，但是对于本地变量，每个线程都会拷贝一份到自己的线程栈中。<br>下图展示了上面描述的过程: </p>
<p><img src="http://dengw.xyz/hexo-blog/180504/hiaBA10aL2.png"></p>
<h3 id="实际的Java内存划分"><a href="#实际的Java内存划分" class="headerlink" title="实际的Java内存划分"></a>实际的Java内存划分</h3><p>上面提到的堆—栈模型划分方式只是大多数程序员比较关注的、关系比较密切的一个方式，实际上的内存区域划分更为复杂。</p>
<p><img src="http://dengw.xyz/hexo-blog/180504/G1dKG5DJF6.jpg"></p>
<p><img src="http://dengw.xyz/hexo-blog/180504/kbakdmG2Gi.jpg"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，为当前线程所拥有， 可以看做是当前线程代码编译之后所产生的字节码的行号指示器，通过改变这个指示器的值来选取下一条需要执行的字节码的指令。程序计数器在计算机组成原理的课上有学，通过它来实现分支，跳转，循环，线程恢复等基础功能。<br>设想一下这个场景，在Java的多线程切换中由其他线程切换到当前线程中继续执行，程序计数器指示了恢复到正确继续执行的位置。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java虚拟机栈也是线程私有的，生命周期和线程相同。<br>Java虚拟机栈的栈元素是栈帧，当有一个方法被调用时，代表这个方法的栈帧入栈；当这个方法返回时，其栈帧出栈。</p>
<p><strong>栈帧(Stack Frame)</strong> 是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区的虚拟机栈(Virtual Machine Stack)的栈元素。</p>
<p>每一个栈帧代表了该线程的一个方法法，包括局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。栈帧的概念结构如下图所示：</p>
<p><img src="http://dengw.xyz/hexo-blog/180504/iDi64AJj85.png" alt="enter description here"></p>
<ul>
<li><p>局部变量表<br>局部变量表就和前面提到的堆—栈模型中的栈是同一个概念了，包括一些编译器可知的基本的数据类型和对一些对象的引用。</p>
</li>
<li><p>操作数栈<br>是一个后进先出栈，由若干个Entry组成，长度由编译期决定，单个Entry即可以存储一个Java虚拟机中定义的任意数据类型的值，包括long和double类型，但是存储long和double类型的Entry深度为2，其他类型的深度为1。在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。</p>
</li>
<li><p>动态连接<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接。</p>
</li>
<li><p>方法返回地址<br>当一个方法被执行后，有两种方式退出该方法：执行引擎遇到了任意一个方法返回的字节码指令或遇到了异常，并且该异常没有在方法体内得到处理。无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。<br>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。</p>
</li>
</ul>
<p>在这个区域中，Java虚拟机规范中规定了两种异常情况：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出<code>StackOverflowError</code>异常；如果虚拟机栈允许动态拓展（当前大部分的java虚拟机都可以动态扩展），如果扩展时无法申请到足够的内存，就会抛出<code>OutOfMemoryError</code>异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>在理解这个内容之前需要知道什么是本地(native)方法。</p>
<p>简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用<code>extern C</code>告知C++编译器去调用一个C的函数。</p>
<p>然后说回本地方法栈，其实和Java虚拟机栈是非常相似，之间的区别只不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native 方法服务。</p>
<p>与虚拟机栈一样，这个区域也会抛出<code>StackOverflowError</code>异常和<code>OutOfMemoryError</code>异常。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java堆可以说是java虚拟机所管理的内存中最大的一块了，也是我们经常接触到的Java区域。<strong>此区域的唯一目的就是存放对象的实例</strong>。在java程序中不管对象是在哪个线程创建的，产生的对象实例都是存放在Java堆中的。</p>
<p>此外呢，Java堆还是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。从内存回收的角度来看，由于现代收集器基本上都采用分代收集算法，所以Java堆中还可以细分为新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。具体各个区域分配的细节在垃圾回收的部分回收更详细的介绍。</p>
<p>在实现时，Java堆区域既可以是固定大小的，也可以是可扩展的。当前主流的Java虚拟机都是按照可扩展来实现的，如果在堆中没有内存完成实例分配，并且堆也无法再扩展的话就会抛出<code>OutOfMemoryError</code>异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区和Java堆一样，是各个线程共享的内存区域，该区域用于存储被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码等数据.</p>
<p>根据Java虚拟机规范的规定，在方法区无法满足内存分配需求时，会抛出<code>OutOfMemoryError</code>异常。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。在Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号的引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。不过相比class文件中的常量池，运行时常量池支持动态添加，在运行期间也可以将新的常量放入池中。</p>
<p>既然运行时常量池是方法区的一部分，自然也会受到方法去内存的限制，当常量池无法再申请到内存的时候会抛出<code>OutOfMemoryError</code>异常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/05/04/%E5%85%B3%E4%BA%8EJava%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/" data-id="ckqm6kplx002xxxr52p9g2w7r" data-title="关于Java内存机制的理解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">Java内存机制</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Android实习面试知识整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/26/Android%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2018-04-25T17:09:47.000Z" itemprop="datePublished">2018-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/26/Android%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">Android实习面试知识整理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今晚把准备面试的过程中遇到的一些问题总结了一下。</p>
<h2 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h2><h3 id="广播（BroadcastReceiver）"><a href="#广播（BroadcastReceiver）" class="headerlink" title="广播（BroadcastReceiver）"></a>广播（BroadcastReceiver）</h3><p>静态广播：程序未启动的情况下也能启动，在注册文件里面注册，广播有一个属性action，根据action的name进行匹配。<br>静态广播即使Activity销毁了，仍然可以收到广播。</p>
<p>动态广播：程序启动之后才能接收到广播，使用Java代码注册 。<br>注册广播的时候提供广播的名字以及启动广播的条件，即intentFilter，通过给intentfilter设置action实现。<br>动态广播必须手动关闭，不然会有内存泄漏的风险。</p>
<p>处理广播消息的时候需要写一个继承BroadcastReceiver的类，重写里面的接收函数onReceive()处理逻辑。</p>
<p>有序广播：广播接收器是有先后顺序的，可以设置接收器的权重，并且先接收到的接收器可以截断广播的传递。</p>
<h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>Android应用间的数据交互，本质上是进程进行数据交互&amp;共享，是一种跨进程通信的方式。</p>
<p><img src="http://dengw.xyz/hexo-blog/180426/AF40Lemhce.png"><br>ContentProvider的底层是采用 Android中的Binder机制。</p>
<p>借助ContentResolver实现，提供一系列进行数据CURD的操作，</p>
<p>通过URI参数访问特定的数据表，区分不同应用以及用一应用中的不同表。<br>获得表之后通过增删改查操作数据。</p>
<h3 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a>SharedPreferences</h3><p>使用键值对的方式存储数据。<br>数据存储过程：</p>
<blockquote>
<p>根据get方法获取一个SharedPreferences对象，这里需要文件名，路径是默认的<br>然后调用edit()获取一个editor对象<br>然后进行put操作，比如putString<br>调用apply（）提交数据</p>
</blockquote>
<p>数据读取：</p>
<blockquote>
<p>根据get方法获取一个SharedPreferences对象<br>然后通过getXXX的方法，比如：getInt(“key”, 默认值)的方式读取。</p>
</blockquote>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>首先自己使用String的方式定义表的格式，</p>
<p>继承SQLiteOpenHelper帮助类，重写里面的创建表和升级表的方法。<br>实例化一个自定义类的实例，使用getWritableDatabase()或者getReadableDatabase()方法获取一个SQLiteDatabase对象，然后就可以通过增删改查的函数进行操作了</p>
<p>NOTE：ContentValues的使用</p>
<h3 id="LitePal"><a href="#LitePal" class="headerlink" title="LitePal"></a>LitePal</h3><p>是一个开源库，需要添加依赖，配置litepal.xml文件（包括数据库名以及版本号），最后在AndroidMainfest.xml文件中注册一个name = “org.litepal.LitePalApplication”的application。</p>
<p>对象关系映射：面向对象的语言和面向关系的数据库建立映射关系<br>需要自定义一个Java Bean继承自DataSupport，然后就可以使用面向对象的语言进行操作了。</p>
<h3 id="Asset目录与res目录的区别"><a href="#Asset目录与res目录的区别" class="headerlink" title="Asset目录与res目录的区别"></a>Asset目录与res目录的区别</h3><p>assets: 需要自己手动创建的，用于存放需要打包到应用程序的静态文件，以便部署到设备中。与res/raw不同点在于，ASSETS支持任意深度的子目录。很重要的一点是这些文件不会生成资源ID，必须使用/assets开始（不包含它）的相对路径名。<br>res: 自动创建的， 能够被系统编译的，用于存放应用程序的资源，比如布局文件，图标等，支持以根据资源ID的形式访问。</p>
<h3 id="activity退出怎么保存数据"><a href="#activity退出怎么保存数据" class="headerlink" title="activity退出怎么保存数据"></a>activity退出怎么保存数据</h3><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/huaheshangxo/article/details/50829752">http://blog.csdn.net/huaheshangxo/article/details/50829752</a></p>
<h3 id="Android的数据存储形式"><a href="#Android的数据存储形式" class="headerlink" title="Android的数据存储形式"></a>Android的数据存储形式</h3><blockquote>
<p>使用SharedPreferences：存储数据: 轻量级的存储，保存一些常用的配置比如窗口状态，比如onSaveInstanceState保存一般使用SharedPreferences完成，主要存储一些基本数据类型以及String类型，数据保存在xml文件里。<br>文件存储数据：java提供的数据保存方法，文件可用来存放大量数据，如文本、图片、音频等。<br>SQLite数据库存储数据：使用sql语言的轻量级嵌入式数据库引擎，主要是对表格类型的数据进行操作，具体的包括增删改查。<br>使用ContentProvider存储数据 ：是应用程序之间共享数据的接口，以数据库形式存入手机内存，可以共享自己的数据给其他应用使用。<br>网络存储数据：比如什么云备份，就是把数据存储在云端，通过网络请求实现数据交互。</p>
</blockquote>
<h3 id="Activity正常和异常情况下的生命周期"><a href="#Activity正常和异常情况下的生命周期" class="headerlink" title="Activity正常和异常情况下的生命周期"></a>Activity正常和异常情况下的生命周期</h3><p>活动的几个状态，具体的边界</p>
<ul>
<li><p> Active (运行状态)：Activity 运行中的状态，可与用户之间进行交互，此时当前Activity位于栈顶。</p>
</li>
<li><p>Paused (暂停状态)：当Activity 暂时暗下来，退到背景画面的状态</p>
</li>
<li><p>Stopped (停止状态)：Activity完全被另一个Activity所覆盖，则其状态为Stopped。</p>
</li>
<li><p>Dead (销毁状态)：Activity 尚未被启动、已经被手动终止，或已经被系统回收的状态。</p>
</li>
<li><p>主要是异常情况，起作用的是onSaveInstanceState()函数，调用的实际，活动被非应用行为退出，如：</p>
</li>
<li><p>当用户按下HOME键时</p>
</li>
<li><p>长按HOME键，选择运行其他的程序时</p>
</li>
<li><p>按下电源按键（关闭屏幕显示）时</p>
</li>
<li><p>从activity A中启动一个新的activity时</p>
</li>
<li><p>屏幕方向切换时，例如从竖屏切换到横屏时，</p>
</li>
<li><p>资源内存不足杀死低优先级的活动<br>应用行为主要包括：主动调用finish()方法，或者主动按Back键，让Activity结束，这个时候就不会调用onSaveInstanceState()函数。</p>
</li>
</ul>
<p>数据恢复：</p>
<ul>
<li>onCreate：恢复了Paracelable对象下的Fragment</li>
<li>onRestoryInstanceState：恢复数据HierarchyState（View树的状态）</li>
</ul>
<p>注：要保存View的状态，View必须要有id，作为key<br>方法：针对某一个特定的View，进行保存，每个View都有onSaveInstanceState和onRestoreInstanceState方法<br>相关，Acticity的configChanges属性，View的保存，委托的思想，活动的三种优先级</p>
<h3 id="Acticity的优先级"><a href="#Acticity的优先级" class="headerlink" title="Acticity的优先级"></a>Acticity的优先级</h3><ul>
<li>前台活动</li>
<li>可见但非前台活动</li>
<li>后台活动</li>
</ul>
<h3 id="activity四种启动模式区别和应用场景。"><a href="#activity四种启动模式区别和应用场景。" class="headerlink" title="activity四种启动模式区别和应用场景。"></a>activity四种启动模式区别和应用场景。</h3><p>在特性的任务栈中启动一个Activity，通过设置TaskAffinity参数实现，主要是结合singleTask使用<br>应用场景： </p>
<blockquote>
<p>singleTop适合接收通知启动的内容显示页面。适用于接受到消息后显示的界面，例如QQ接受到消息后弹出Activity，如果一次来10条消息，总不能一次弹10个Activity。</p>
</blockquote>
<blockquote>
<p>singleTask适合作为程序入口点。在进入程序的第一个界面点击返回按钮，正常的逻辑是退出程序。满足这种情况。</p>
</blockquote>
<blockquote>
<p>singleInstance适合需要与程序分离开的页面。比如说，使用微信调起自己的客户端某个页面，不做任何处理的情况下，按下回退或者当前Activity.finish()，页面不会停留在自己的客户端而是返回到微信的客户端页面。但是如果这个页面的启动模式设置为singleTask，当按下返回键或者Activity。finish（）例如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</p>
</blockquote>
<p>相关：任务栈，onNewIntent方法的调用</p>
<h3 id="Android怎样退出终止App"><a href="#Android怎样退出终止App" class="headerlink" title="Android怎样退出终止App"></a>Android怎样退出终止App</h3><p>使用单例模式创建一个Activity管理对象ActivityManager，该对象中有一个Activity容器，可以使用LinkedList实现（一个容器代表一个app实例）专门负责存储新开启的每一个Activity。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ActivityManager instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例模式中获取唯一的app实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ActivityManager();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<blockquote>
<p>在每一个Activity中的onCreate方法里添加该Activity到AppUtils对象实例容器中<br>ActivityManager.getInstance().addActivity(this);</p>
</blockquote>
<blockquote>
<p>在需要结束所有Activity的时候调用exit方法<br>ActivityManager.getInstance().exit();</p>
</blockquote>
<h3 id="Fragement的生命周期"><a href="#Fragement的生命周期" class="headerlink" title="Fragement的生命周期"></a>Fragement的生命周期</h3><p>getFragementById()：在活动中获取碎片的方法<br>getActivity()：在碎片中获取活动的方法<br>几个重要的函数：</p>
<blockquote>
<p>onAttach()当碎片和活动建立关联的时候调用。</p>
</blockquote>
<blockquote>
<p>onCreateView()为碎片建立视图的时候调用, 加载布局和findViewById的操作通常在此函数内完成。</p>
</blockquote>
<blockquote>
<p>onActivityCreated() 确保碎片与碎片相关联的活动已经创建完时调用, 在该方法内可以进行与Activity交互的UI操作。</p>
</blockquote>
<blockquote>
<p>onDestroyView() 当与碎片关联的视图被移除的时候调用, 销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图</p>
</blockquote>
<blockquote>
<p>onDetach() 当碎片和活动解除关联的时候调用</p>
</blockquote>
<p>一旦activity进入running状态，你就可以自由地添加和删除fragment了，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。</p>
<p><img src="http://dengw.xyz/hexo-blog/180426/cA1kBDeEH1.png"></p>
<h3 id="service生命周期，两种启动方式的区别"><a href="#service生命周期，两种启动方式的区别" class="headerlink" title="service生命周期，两种启动方式的区别"></a>service生命周期，两种启动方式的区别</h3><blockquote>
<p>startService 方法启动，该Service在后台运行。如果一个Service被startService 方法多次启动，onCreate方法只会调用一次，onStartCommand将会被调用多次，并且系统只会创建Service的一个实例，因此只需要一次stopService。该Service将会一直在后台运行，而不管对应程序的Activity是否在运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务。</p>
</blockquote>
<blockquote>
<p>bindService 方法绑定启动，不管调用 bindService 调用几次，onCreate方法都只会调用一次，同时onStartCommand方法始终不会被调用。当连接建立之后，Service将会一直运行，除非调用Context.unbindService 断开连接或者之前调用bindService 的 Context 不存在了（如Activity被finish的时候），系统将会自动停止Service，对应onDestroy将被调用。一定要显示使用unbindService()解除引用。</p>
</blockquote>
<p><strong>NOTE</strong>: 如果一个Service又被启动又被绑定，则该Service将会一直在后台运行。并且不管如何调用，onCreate始终只会调用一次，对应startService调用多少次，Service的onStart便会调用多少次。调用unbindService将不会停止Service，而必须调用 stopService 或 Service的 stopSelf 来停止服务。<br><img src="http://dengw.xyz/hexo-blog/180426/e93db3aFH2.png"></p>
<h3 id="app如何保证后台服务不被杀死"><a href="#app如何保证后台服务不被杀死" class="headerlink" title="app如何保证后台服务不被杀死"></a>app如何保证后台服务不被杀死</h3><ul>
<li><p>建立两个service互相监听，当一个service被kill掉的时候马上启动另一个</p>
</li>
<li><p>在onDestory里自监听，service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service</p>
</li>
<li><p>提升进程优先级（有6个优先级）</p>
</li>
</ul>
<h3 id="HandlerThread的实现原理"><a href="#HandlerThread的实现原理" class="headerlink" title="HandlerThread的实现原理"></a>HandlerThread的实现原理</h3><p>HandlerThread继承自Thread，内部保存一个Looper对象。<br>这是一个系统帮我们包装好的Thread，这个线程的run方法已经调用了Looper.prepare和Looper.loop（即已经绑定了一个Looper对象，并且可以开始轮询消息），创建该对象之后可以通过获得对象获取到一个Looper对象，然后可以当前Looper的引用返回以方便调用，将Looper对象传递给Handler（通过Looper可以实例化一个Handler），完成Handler和Looper以及MessageQueue的绑定，最终handleMessage方法会在HandlerThread线程中被调用。最后再其他的线程中调用Handler的sendMessage或者post(Runable)方法发送消息，handler中的callback.handleMessage方法会在HandlerThread中运行。即，将消息发送到了特定的线程（此处是HandlerThread）处理。</p>
<p>继承自Thread，是一种可以使用handler的Thread，实现很简单，就是在run方法中通过Looper.prepare（）方法来创建一个消息队列。普通的Thread主要用来在run方法中执行一个耗时任务，handlerThread则是通过handler的消息方式来通知handlerThread执行一个具体的任务，主要的使用场景就是IntentService。</p>
<p>使用方法：一般是把HandlerThread线程的Looper，在需要的地方使用new Handler(Looper)创建一个WorkerHandler处理业务逻辑。</p>
<h3 id="IntentService比Service好在哪"><a href="#IntentService比Service好在哪" class="headerlink" title="IntentService比Service好在哪"></a>IntentService比Service好在哪</h3><p>IntentService继承自Service，运行时优先级更高，内部使用了HandlerThread作为处理消息的线程。内部有一个私有内部类ServiceHandler继承自Handler，并且会创建一个ServiceHandler对象。 </p>
<p>使用startService()方法启动IntentService时，不会重新创建一个服务，会调用ServiceHandler对象发送包含该Intent的Message对象，该对象通过HandlerThread处理后交给ServiceHandler重写的handleMessage方法进行处理，处理的方式是调用IntentService的onHandleIntent（Intent）方法，所以使用的方式就是创建一个继承自IntentService类的子类，并重写onHandleIntent方法，在该方法中处理startService时传递的Intent。Intent中包含有要交给Service处理的信息。</p>
<p>Service缺点：不是专门的一个新的线程，因此不能够在里面执行耗时操作。<br>IntentService： IntentService封装了HandlerThread和Handler，内部创建一个HandlerThread开辟新的线程。</p>
<p>重写继承的handler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        onHandleIntent((Intent)msg.obj);</span><br><span class="line">        stopSelf(msg.arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">    <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">    <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line"></span><br><span class="line">    mServiceLooper = thread.getLooper();</span><br><span class="line">    mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是通过Handler、looper、message的方式实现了一个多线程的操作，同时耗时操作也可以被这个线程管理和执行<br>（1）IntentService会创建单独的worker线程来处理所有的intent请求。<br>（2）IntentService会创建单独的worker线程来处理onHandleIntent（）方法实现的代码。<br>     继承类重写IntentService的onHandleIntent（）方法，处理具体的业务逻辑<br>（3）当所有的请求处理完之后，IntentService会自动停止。<br>（4）为Service的OnBind（）方法提供了默认的实现，返回null。<br>（5）为service的onStartCommand（）方法提供了默认的实现，该实现会将请求intent添加到队列中。<br>所以对IntentService的使用就是：继承IntentService，重写onHandleIntent()方法即可。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>设计的初衷：提供线程内部的局部变量，在本线程内随时随地可取，并且在多线程环境下每个线程里的变量独立于其他线程内的变量。</p>
<p>ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p>
<p>实现：<br>每个Thread维护一个ThreadLocalMap映射表，这个映射表的key是每个线程的ThreadLocal实例本身，value是真正需要存储的Object。</p>
<p>用法：<br>initialValue函数：用来设置ThreadLocal的初始值<br>get函数：用来获取与当前线程关联的ThreadLocal的值<br>set函数：用来设置当前线程的ThreadLocal的值<br>remove函数：用来将当前线程的ThreadLocal绑定的值删除</p>
<h3 id="handler的内在原理"><a href="#handler的内在原理" class="headerlink" title="handler的内在原理"></a>handler的内在原理</h3><p>消息队列为空会怎样？<br>消息队列为空时，消息队列的方法next就会一直阻塞，这样造成looper的loop方法也会被阻塞，直到Looper检测到消息队列中有新的消息时</p>
<h3 id="Looper原理"><a href="#Looper原理" class="headerlink" title="Looper原理"></a>Looper原理</h3><p>Looper主要是用来传递消息的，在消息机制里面扮演者一种消息循环的角色，会不停的从消息队列中查看是否有新消息，有消息的话就取出来才交给handler处理，没有的话就一直阻塞<br>Looper是存在于线程中的，一个线程中有Looper才能工作，<br>Prepare(): 创建Looper，在构造函数里面会声明一个消息队列，用于存放新收到的消息<br>Loop(): 启动消息循环<br>主要是loop函数起作用， 死循环，跳出循环的条件（消息队列的next方法）</p>
<h3 id="Android进程与线程的区别"><a href="#Android进程与线程的区别" class="headerlink" title="Android进程与线程的区别"></a>Android进程与线程的区别</h3><p>操作系统上来说：</p>
<blockquote>
<p>进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元.</p>
</blockquote>
<blockquote>
<p>同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。</p>
</blockquote>
<blockquote>
<p>进程有自己独立的地址空间，线程共享所属进程的地址空间。</p>
</blockquote>
<blockquote>
<p>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</p>
</blockquote>
<p>在安卓上体现：</p>
<blockquote>
<p>一个进程看成一个独立的程序，默认情况下一个app运行在一个进程内。</p>
</blockquote>
<blockquote>
<p>同样的，一个进程可以有多个线程，线程共享所属进程的地址空间，但是每个线程又有自己的栈空间。</p>
</blockquote>
<p>注：进程的资源包括各种表格、内存空间、磁盘空间、I／O设备等。</p>
<h3 id="IPC（进程间通信）的实现方法有哪些"><a href="#IPC（进程间通信）的实现方法有哪些" class="headerlink" title="IPC（进程间通信）的实现方法有哪些"></a>IPC（进程间通信）的实现方法有哪些</h3><p><img src="http://dengw.xyz/hexo-blog/180426/A81G5DlI2b.png"></p>
<h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>一般来说，内存泄漏都是因为泄漏对象的引用被传递到该对象的范围之外，或者说内存泄漏是因为持有对象的长期引用，导致对象无法被 GC 回收。<br>开发过程中有没有实际遇到内存泄露情况，怎么解决的。</p>
<blockquote>
<p>单例造成的内存泄漏，单例是静态的，生命周期和应用的生命周期一样长，如果说单例获取的context是一个activity的context，那么当前activity销毁的时候还被引用，资源不能及时被回收，解决方法，使传入的context参数为application的context, context.getApplicationContext();</p>
</blockquote>
<blockquote>
<p>匿名内部内部类或者非静态内部类创建了一个静态的实例，他们都会持有外部类的引用，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。</p>
</blockquote>
<blockquote>
<p>Handler造成的内存泄漏，非静态匿名内部类的实例，持有外部类Activity的引用，消息队列是在一个Looper线程中不断轮询处理消息，当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有handler实例的引用，handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，解决方法，将内部类声明为静态的，对Handler持有的对象使用弱引用，这样在回收时可以回收Handler持有的对象，避免了Activity，或者在onDestroy中中断子线程的运行。</p>
</blockquote>
<blockquote>
<p>资源未关闭注销造成的内存泄漏，EventBus、BroadcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
</blockquote>
<blockquote>
<p>线程导致内存泄漏。我们经常会执行一些长期运行的任务，避免在这些任务中持有 Activity 对象的引用，如果持有了引用的话，我们应该在对象生命周期结束的时候，释放引用。<br>解决方法：</p>
</blockquote>
<p><strong>一句话归纳：</strong>（生命周期比Activity长的类不要去强引用Activity）</p>
<h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><p>原理：系统会给每一个app的堆内存分配一个固定值heapSize，app运行一段时间后堆内存超过了系统规定的最大值heapSize。<br>主要是图片Bitmap的操作上，图片太大了，以及内存泄漏造成的</p>
<h3 id="什么是ANR，如何避免"><a href="#什么是ANR，如何避免" class="headerlink" title="什么是ANR，如何避免"></a>什么是ANR，如何避免</h3><p>Application Not Responding，在Android中，活动管理器和窗口管理器这两个系统服务负责监视应用程序的响应，当用户操作在5秒内应用程序未做出响应，或者BroadcastReceiver在10秒内没有执行完毕，就会出现应用程序无响应对话框，即是ANR</p>
<h3 id="什么情况会导致Force-Close-如何避免-能否捕获导致其的异常"><a href="#什么情况会导致Force-Close-如何避免-能否捕获导致其的异常" class="headerlink" title="什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?"></a>什么情况会导致Force Close ?如何避免?能否捕获导致其的异常?</h3><p>导致出现Force Close的原因有很多，常见的有比如空指针啦，类没有找到啦，资源没找到，就连Android API使用的顺序错误也可能导致（比如setContentView()之前进行了findViewById()操作）；<br>编写程序时逻辑连贯、思维缜密；<br>能捕获异常，在logcat中能看到异常信息。</p>
<h3 id="NDK是什么"><a href="#NDK是什么" class="headerlink" title="NDK是什么"></a>NDK是什么</h3><p>NDK是用来给安卓手机开发软件用的，但是和SDK不同的是它用的是C语言，而SDK用的是Java语言。<br>NDK开发的软件在安卓的环境里是直接运行的，一般只能在特定的CPU指令集的机器上运行，而且C语言可以直接和硬件对话，因此一般用它开给手机开发驱动或底层应用；而SDK开发出的软件在安卓上靠Dalvik虚拟机来运行，所以如果没有特殊的需要或署专门针对某个硬件去开发，那就一般用SDK。<br>NDK是一系列工具的集合，帮助开发者迅速地开发C/C++动态库，并能自动将so和java应用打成apk包；NDK集成了交叉编译器，并提供了相应的mk文件和隔离CPU、平台等差异，开发人员只需简单的修改mk文件就可以创建出so</p>
<h3 id="如何将SQLite数据库与apk文件一起发布"><a href="#如何将SQLite数据库与apk文件一起发布" class="headerlink" title="如何将SQLite数据库与apk文件一起发布"></a>如何将SQLite数据库与apk文件一起发布</h3><p>可以将XX.db文件复制到Eclipse Android工程中的res\raw目录中，如图1所示。所有在res\raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。<br>使用openDatabase方法来打开数据库文件，如果该文件不存在，系统会自动创建/sdcard/dictionary目录，并将res\raw目录中的 XX.db文件复制到/sdcard/dictionary目录中。</p>
<h3 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h3><h3 id="View的绘制机制"><a href="#View的绘制机制" class="headerlink" title="View的绘制机制"></a>View的绘制机制</h3><h3 id="ListView优化"><a href="#ListView优化" class="headerlink" title="ListView优化"></a>ListView优化</h3><blockquote>
<p>使用convertView保存加载好的布局，当使用getView()方法时，可以将缓存好的布局重用，避免从新加载。便于复用View</p>
</blockquote>
<blockquote>
<p>使用ViewHolder保存控件实例，当convertView为null的时候，就是用LayoutInflater加载布局，创建一个ViewHolder并将所有控件存放在里面，然后View.settag()将ViewHolder保存在View里面，当convertView不为null的时候，通过view.getTag（）把ViewHolder重新提取出来，这一样就避免多次加载控件的实例，便于复用控件实例</p>
</blockquote>
<blockquote>
<p>ListView加载图片时, 如果需要显示从网络上下载的图片的话，我们不要在ListView滑动的时候加载图片，那样会使ListView变得卡顿，所以我们需要再监听器里面监听ListView的状态，如果滑动的时候，停止加载图片，如果没有滑动，则开始加载图片。</p>
</blockquote>
<h3 id="RecyclerView和ListView"><a href="#RecyclerView和ListView" class="headerlink" title="RecyclerView和ListView"></a>RecyclerView和ListView</h3><p>ViewHolder: ListView种需要自己来定义，可以实现可以不实现，而在RecyclerView中必须要自己实现RecyclerView.ViewHolder<br>LayoutManager：在布局效果上，RecyclerView支持线性布局、网格布局、瀑布流布局三种效果，同时还能够控制横向还是纵向滚动，从效果上recyclerview的使用场景更多。而ListView在Android API中只支持<br>ItemAnimator： 提供在删除或添加item时产生动画效果，<br>各自缓存原理，ListView是两级缓存，recyclerview是四级缓存。</p>
<h3 id="如何优雅的展示Bitmap大图"><a href="#如何优雅的展示Bitmap大图" class="headerlink" title="如何优雅的展示Bitmap大图"></a>如何优雅的展示Bitmap大图</h3><p>主要目的：避免程序占用了过高的内存就容易出现OOM<br>压缩：使用BitmapFactory提供的解析方法，BitmapFactory.Options参数，计算压缩因子inSampleSize<br>使用图片缓存：LruCache和LruDiskCache</p>
<h3 id="Bitmap的四种属性"><a href="#Bitmap的四种属性" class="headerlink" title="Bitmap的四种属性"></a>Bitmap的四种属性</h3><p>每种属性队形的大小。</p>
<h3 id="多进程和多线程的实现，进程和线程区别"><a href="#多进程和多线程的实现，进程和线程区别" class="headerlink" title="多进程和多线程的实现，进程和线程区别"></a>多进程和多线程的实现，进程和线程区别</h3><p>1、子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文。<br>2、进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。<br>3、进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。<br>4、线程上下文切换比进程上下文切换要快得多。<br>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>（3）处理机分给线程，即真正在处理机上运行的是线程。<br>（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>Java8中的新功能<br>Interface函数接口的<br>使用Lambda表达式必须满足只有一个待实现方法</p>
<p><strong>和匿名内部类的不同</strong><br>lambda表达式是某些匿名表达式的简写<br>【相同点】</p>
<ol>
<li>都可以直接访问”effectively final”的局部变量，以及外部类的成员变量（包括实例变量和类变量）</li>
<li>都可以直接调用从接口中继承的默认方法。<br>【区别】</li>
<li>   匿名内部类可以为任意接口创建实例——不管有多少个抽象方法，只要匿名内部类实现了所有方法即可。<br>但是Lambda表达式只能为函数式接口创建实例，只有一个待实现方法。</li>
<li>   匿名内部类可以为抽象类甚至普通类创创建实例，<br>但lambda表达式只能为函数式接口创建实例。</li>
<li>   匿名内部类实现的抽象方法体允许调用接口中的默认方法，<br>但Lambda表达式的代码块不允许调用接口中的默认方法。</li>
</ol>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>单例、工厂、适配器、责任链、观察者<br>设计模式六大原则：</p>
<blockquote>
<p>开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
</blockquote>
<blockquote>
<p>里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。<br>里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。<br>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
</blockquote>
<blockquote>
<p>   依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
</blockquote>
<blockquote>
<p>   接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
</blockquote>
<blockquote>
<p>   迪米特法则（最少知道原则）（Demeter Principle）<br>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
</blockquote>
<blockquote>
<p>   合成复用原则（Composite Reuse Principle）<br>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
</blockquote>
<h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>发布/订阅事件总线，<br>基本使用：解耦性高，开销小，<br>三要素：<br>Event：任意类型的对象<br>Subscriber：在EventBus3.0之后，事件处理的方法可以随便取名，但是需要添加一个注解@Subscribe，并且要指定线程模型（默认为POSTING）<br>Publisher：能在任意线程任意位置发送事件，直接调用EventBus的post(Event)方法<br>线程模型ThreadMode：</p>
<ul>
<li>POSTING（默认）</li>
<li>MAIN</li>
<li>   BACKGROUND</li>
<li>   ASYNC</li>
</ul>
<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe(threadMode = ThreadMode.MAIN)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMoonEvent</span><span class="params">(MessageEvent messageEvent)</span></span>&#123;</span><br><span class="line">     tv_message.setText(messageEvent.getMessage());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用步骤：<br>（1）    添加依赖<br>（2）    在自定义一个类<br>（3）    要接收消息的页面注册<br>（4）    发送消息<br>（5）    接受消息的页面实现订阅函数（有四种类型的函数）<br>（6）    解除注册</p>
<p>支持粘性事件：发送事件之后才订阅该事件，依然能够接收该事件</p>
<p>EventBus2.0的版本中，</p>
<blockquote>
<p>onEvent：事件在哪个线程发布出来的，onEvent就会在这个线程中运行，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。</p>
</blockquote>
<blockquote>
<p>onEventMainThread：不论事件是在哪个线程中发布出来的，接收事件就会在UI线程中运行，所以可以在里面更新UI，不能执行耗时操作</p>
</blockquote>
<blockquote>
<p>onEventBackground: 如果事件是在UI线程中发布出来的，那么onEventBackground就会在子线程中运行，如果事件本来就是子线程中发布出来的，那么onEventBackground函数直接在该子线程中执行。</p>
</blockquote>
<blockquote>
<p>onEventAsync：无论事件在哪个线程发布，都会创建新的子线程在执行onEventAsync</p>
</blockquote>
<h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p>是一个abstract类，底层是对Handler与线程池的封装，使用线程池的主要原因是避免不必要的创建及销毁线程的开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Params：doInBackground方法的参数类型；</li>
<li><pre><code>Progress：AsyncTask所执行的后台任务的进度类型；
</code></pre>
</li>
<li>   Result：后台任务的返回结果类型。</li>
</ul>
<p>提供的方法：除了doInBackground方法由AsyncTask内部线程池执行外，其余方法均在主线程中执行。</p>
<blockquote>
<p>onPreExecute() //此方法会在后台任务执行前被调用，用于进行一些准备工作 </p>
</blockquote>
<blockquote>
<p>doInBackground(Params… params) //此方法中定义要执行的后台任务，在这个方法中可以调用publishProgress来更新任务进度（publishProgress内部会调用onProgressUpdate方法） </p>
</blockquote>
<blockquote>
<p>onProgressUpdate(Progress… values) //由publishProgress内部调用，表示任务进度更新 </p>
</blockquote>
<blockquote>
<p>onPostExecute(Result result) //后台任务执行完毕后，此方法会被调用，参数即为后台任务的返回结果</p>
</blockquote>
<blockquote>
<pre><code> onCancelled() //此方法会在后台任务被取消时被调用
</code></pre>
</blockquote>
<p><strong>存在的不足：</strong></p>
<ul>
<li>AsyncTask对象必须在主线程中创建 </li>
<li>AsyncTask对象的execute方法必须在主线程中调用 </li>
<li>一个AsyncTask对象只能调用一次execute方法</li>
</ul>
<p><strong>注意事项</strong>：</p>
<ul>
<li><p>AsyncTask实例必须在UI Thread中创建</p>
</li>
<li><p>execute方法必须在UI Thread中调</p>
</li>
<li><p>onPreExecute()、onPostExecute(),、doInBackground() 和 onProgressUpdate()这四个方法都是回调方法，Android会自动调用，我们不应自己调用。</p>
</li>
<li><p>对于一个AsyncTack的实例，只能执行一次execute方法，在该实例上第二次执行execute方法时就会抛出异常</p>
</li>
</ul>
<p><strong>OkHttp</strong><br>特点：</p>
<ul>
<li>支持http2，对一台机器的所有请求共享同一个socket </li>
<li>内置连接池，支持连接复用，减少延迟 </li>
<li>支持透明的gzip压缩响应体 </li>
<li>通过缓存避免重复的请求 </li>
<li>请求失败时自动重试主机的其他ip，自动重定向 </li>
<li>好用的API</li>
</ul>
<p>定义一个OkHttpClient， 定义一个Request,将url添加到Request,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mHttpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder().url(url).build();</span><br><span class="line">response = mHttpClient.newCall(request).execute();</span><br></pre></td></tr></table></figure>

<p>执行函数：同步请求execute或者异步请求enqueue（new Callback（））</p>
<h3 id="Retrofit原理："><a href="#Retrofit原理：" class="headerlink" title="Retrofit原理："></a>Retrofit原理：</h3><p>使用 Retrofit 的步骤共有7个：<br>步骤1：添加Retrofit库的依赖<br>步骤2：创建 接收服务器返回数据 的类<br>步骤3：创建 用于描述网络请求 的接口<br>步骤4：创建 Retrofit 实例<br>步骤5：创建 网络请求接口实例 并 配置网络请求参数<br>步骤6：发送网络请求（异步 / 同步）</p>
<h3 id="RxJava原理"><a href="#RxJava原理" class="headerlink" title="RxJava原理"></a>RxJava原理</h3><p>优缺点, map，flatmap的原理,可不可以多次subscribeOn，ObserveOn，会有什么后果。</p>
<p>基于观察者模式实现的异步调用，简洁，链式调用，处理复杂的逻辑的时候，消除或者减少嵌套使用的次数，代码更加容易理解</p>
<blockquote>
<p>flatMap() 和 map() 有一个相同点：它也是把传入的参数转化之后返回另一个对象，<br>flatMap()和map() 不同的是， flatMap()中返回的是个 Observable 对象，并且这个 Observable 对象并不是被直接发送到了 Subscriber 的回调方法中。</p>
</blockquote>
<p><strong>flatMap() 的原理：</strong></p>
<ol>
<li>使用传入的事件对象创建一个 Observable 对象；</li>
<li>并不发送这个 Observable, 而是将它激活，于是它开始发送事件；</li>
<li>每一个创建出来的 Observable 发送的事件，都被汇入同一个 Observable ，而这个 Observable 负责将这些事件统一交给 Subscriber 的回调方法。<br>这三个步骤，把事件拆成了两级，通过一组新创建的 Observable 将初始的对象『铺平』之后通过统一路径分发了下去。<br>ObserveOn（）可以使用多次，一个observeOn() 指定的是 一个特性Observable 所对应的 Subscriber所在的线程，即Observable的直接下级Subscriber， 但是当我们使用lift（）函数的时候，过程中会出现对个Observable，然后对应多个observer,因此这个使用就会使用到多个observeOn()，然后在代码上体现在observeOn() 指定的是紧跟着它之后的操作所在的线程：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// IO 线程，由 subscribeOn() 指定</span></span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) <span class="comment">// 新线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) <span class="comment">// IO 线程，由 observeOn() 指定</span></span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread) </span><br><span class="line">    .subscribe(subscriber);  <span class="comment">// Android 主线程，由 observeOn() 指定</span></span><br></pre></td></tr></table></figure>

<p>subscribeOn()是不可以使用多次的，因为起作用的只有一个原始被订阅源所在的那个subscribeOn()，所以使用多次也没什么意义。</p>
<p>Observable (可观察者，即被观察者)、 Observer (观察者)/subscriber (订阅者)、subscriber (订阅)事件。Observable 和 Observer 通过 subscribe() 方法实现订阅关系，从而 Observable 可以在需要的时候发出事件来通知 Observer。</p>
<p>Observer/ subscriber的创建方法，注意带上参数类型，解除订阅的方法</p>
<p>创建 Observable，三种方法，Observable 的OnSubscribe 对象：会被存储在返回的 Observable 对象中，它的作用相当于一个计划表，当 Observable 被订阅的时候，OnSubscribe 中定义好的 call() 方法会自动调用，执行一些具体的逻辑</p>
<p>重点是Create函数的写法：参数，参数类型等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Drawable&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>订阅函数：observable.subscribe(subscriber);</p>
<p>内部核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);    <span class="comment">//事件发送的逻辑开始运行</span></span><br><span class="line">    <span class="keyword">return</span> subscriber; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>subscribe() 还支持不完整定义的回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = <span class="keyword">new</span> Action1&lt;String&gt;() &#123;   <span class="comment">//注意Action1的含义</span></span><br><span class="line">    <span class="comment">// onNext()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</p>
</blockquote>
<blockquote>
<p>Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。</p>
</blockquote>
<blockquote>
<p>Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</p>
</blockquote>
<blockquote>
<p>Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。</p>
</blockquote>
<blockquote>
<p>另外， Android 还有一个专用的 AndroidSchedulers.mainThread()，它指定的操作将在 Android 主线程运行。</p>
</blockquote>
<p><strong>map()</strong> ：用于对象的转换，转换参数类型<br>注意Func1的含义与用法：一个参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">&quot;images/logo.png&quot;</span>) <span class="comment">// 输入类型 String</span></span><br><span class="line">    .map(<span class="keyword">new</span> Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Bitmap <span class="title">call</span><span class="params">(String filePath)</span> </span>&#123; <span class="comment">// 参数类型 String</span></span><br><span class="line">            <span class="keyword">return</span> getBitmapFromPath(filePath); <span class="comment">// 返回类型 Bitmap</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Bitmap bitmap)</span> </span>&#123; <span class="comment">// 参数类型 Bitmap</span></span><br><span class="line">            showBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>**flatMap()**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Course&gt; subscriber = <span class="keyword">new</span> Subscriber&lt;Course&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Course course)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;Course&gt; <span class="title">call</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure>

<h3 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h3><h3 id="解析xml文件的两种方法：Pull和SAX"><a href="#解析xml文件的两种方法：Pull和SAX" class="headerlink" title="解析xml文件的两种方法：Pull和SAX"></a>解析xml文件的两种方法：Pull和SAX</h3><p>Pull解析方式：<br>基于事件的模式，需要自己获取产生的事件然后做相应的操作。<br>特点：PULL解析器小巧轻便，解析速度快，简单易用，非常适合在Android移动设备中使用，Android系统内部在解析各种XML时也是用PULL解析器。<br>五种事件类型：</p>
<ul>
<li><p>START_DOCUMENT：文档开始，解析器还未读取到任何输入的时候</p>
</li>
<li><p>START_TAG：解析到开始标签</p>
</li>
<li><p>TEXT：解析到文本节点</p>
</li>
<li><p>END_TAG：解析到结束标签</p>
</li>
<li><p>END_DOCUMENT：文档结束</p>
</li>
</ul>
<p><strong>XmlPullParser常用方法</strong><br>// 获取指定索引属性的属性值，索引从0开始</p>
<blockquote>
<p>public abstract String getAttributeValue (int index);</p>
</blockquote>
<p>// 返回当前事件类型</p>
<blockquote>
<p>public abstract int getEventType ();</p>
</blockquote>
<p>// 返回当前事件类型的内容字符串形式</p>
<blockquote>
<p>public abstract String getText ();</p>
</blockquote>
<p>// 获取下一个解析事件类型</p>
<blockquote>
<p>public abstract int next ();</p>
</blockquote>
<p>// 当前是开始标签，如果下一个元素为文本，则返回该文本字符串，<br>// 如果下一个元素是结束标签，则返回空字符串，其它情况将抛出异常</p>
<blockquote>
<p>public abstract String nextText ();</p>
</blockquote>
<p>// 设置即将被解析的输入流</p>
<blockquote>
<p>public abstract void setInput (InputStream inputStream, String inputEncoding);</p>
</blockquote>
<p><strong>SAX解析方式</strong><br>也是事件驱动的模式<br>特点：边扫描边解析，自顶向下依次解析，由于边扫描边解析，所以它解析XML具有速度快，占用内存少的优点。<br>方法：<br>重写一个继承DefaultHandler的类,然后重写一下方法。</p>
<blockquote>
<p>startDocument()：文档解析开始时调用，该方法只会调用一次</p>
</blockquote>
<blockquote>
<p>startElement(String uri, String localName, String qName, Attributes attributes):标签（节点）解析开始时调用</p>
</blockquote>
<ul>
<li>uri：xml文档的命名空间</li>
<li>localName：标签的名字</li>
<li>qName：带命名空间的标签的名字</li>
<li>attributes：标签的属性集</li>
<li>characters(char[] ch, int start, int length)：解析标签的内容的时候调用</li>
<li>ch：当前读取到的TextNode(文本节点)的字节数组</li>
<li>start：字节开始的位置，为0则读取全部</li>
<li>length：当前TextNode的长度</li>
<li>endElement(String uri, String localName, String qName)：标签（节点）解析结束后调用</li>
<li>endDocument()：文档解析结束后调用，该方法只会调用一次</li>
</ul>
<p>最后在需要解析的地方调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String responseData = response.body().string();</span><br><span class="line">parseXMLWithSAX(responseData);</span><br></pre></td></tr></table></figure>
<p>解析Json数据的两种可行方式：JSONObject和GSON</p>
<p><strong>JSONObject的方式：</strong><br>结合JSONObject这个对象，结合JSONArray，可以将简单的Json字符串， 嵌套的json字符串，Bean对象，json数组转化为JSONObject<br>从JSONObject对象中获取值的方法：obj.get(属性名)；<br>Obj.put(“level”, “A”);</p>
<p><strong>GSON解析：</strong><br>通过Java Bean的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;App&gt; applist = gson.fromJson(jsonData. New TypeToken&lt;List&lt;App&gt;&gt;) ()&#123;&#125;.getType());</span><br></pre></td></tr></table></figure>
<p>其中，jsonData为reponse.Body();App为自定义的java Bean;</p>
<h3 id="Json有什么优劣势"><a href="#Json有什么优劣势" class="headerlink" title="Json有什么优劣势"></a>Json有什么优劣势</h3><p>优点：</p>
<ul>
<li>Json的分隔符简化了数据访问</li>
<li>数据格式简单，方便读写，传输效率高</li>
<li>支持语言很多</li>
</ul>
<p>缺点：</p>
<h3 id="自定义View过程"><a href="#自定义View过程" class="headerlink" title="自定义View过程"></a>自定义View过程</h3><p>onMeasure()、onLayout()、onDraw()</p>
<h2 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h2><h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3><p>1、Integer是int的包装类，int则是java的一种基本数据类型<br>2、Integer变量必须实例化后才能使用，而int变量不需要<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值<br>4、Integer的默认值是null，int的默认值是0</p>
<h3 id="Java面向对象的三个特征与含义"><a href="#Java面向对象的三个特征与含义" class="headerlink" title="Java面向对象的三个特征与含义"></a>Java面向对象的三个特征与含义</h3><p>封装：封装是指将某事物的属性和行为包装到对象中，这个对象只对外公布需要公开的属性和行为，而这个公布也是可以有选择性的公布给其它对象。<br>继承：继承是子对象可以继承父对象的属性和行为<br>多态：</p>
<h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><p>含义：我的理解是就像名字一样，表现出多个形态。父类的引用变量指向子类对象，当调用父类中存在的方法时，实际上会调用子类重写之后的方法几个相关概念：<br>重载（overload）<br>在子类中重写父类中的某个方法，这两个方法函数名相同，但是参数不同，可以是参数的类型或者参数的个数不同<br>覆盖（override）<br>在子类中重写父类中的某个函数，这两个函数函数名和参数都完全相同。<br>多态，三个条件</p>
<ol>
<li>要有继承关系</li>
<li>子类要重写父类的方法：这里的重写指的是覆盖（override），</li>
<li>父类数据的引用指向子类对象，例：Animal am = new Cat();</li>
</ol>
<h3 id="Interface与abstract类的区别"><a href="#Interface与abstract类的区别" class="headerlink" title="Interface与abstract类的区别"></a>Interface与abstract类的区别</h3><p>1). 抽象类可以有构造方法，接口中不能有构造方法。<br>2). 抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3). 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。<br>4). 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行）,但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>5). 抽象类中可以包含静态方法，接口中不能包含静态方法<br>6). 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。<br>7). 一个类可以实现多个接口，但只能继承一个抽象类。</p>
<h3 id="反射的作用与原理"><a href="#反射的作用与原理" class="headerlink" title="反射的作用与原理"></a>反射的作用与原理</h3><h3 id="泛型相关"><a href="#泛型相关" class="headerlink" title="泛型相关"></a>泛型相关</h3><h3 id="Collection包结构，与Collections的区别"><a href="#Collection包结构，与Collections的区别" class="headerlink" title="Collection包结构，与Collections的区别"></a>Collection包结构，与Collections的区别</h3><p>Collections是个java.util下的类，它包含有各种有关集合操作的静态方法。<br>Collection是个java.util下的接口，它是各种集合结构的父接口。</p>
<h3 id="equals方法是怎么来的"><a href="#equals方法是怎么来的" class="headerlink" title="equals方法是怎么来的"></a>equals方法是怎么来的</h3><p>equals 方法是子类从超类Object中继承的,所有继承Object类的方法都有，equals是用来进行比较的，可以在具体的类中自定义</p>
<h3 id="hashcode和equals有什么关系"><a href="#hashcode和equals有什么关系" class="headerlink" title="hashcode和equals有什么关系"></a>hashcode和equals有什么关系</h3><p>hashCode()方法和equal()方法的作用一样，都是用来对比两个对象是否相等一致<br>有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题，比如因为表示位数被截断了）</p>
<ol>
<li>equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。</li>
<li>hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。<br>每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</li>
</ol>
<h3 id="Object有公用方法："><a href="#Object有公用方法：" class="headerlink" title="Object有公用方法："></a>Object有公用方法：</h3><ul>
<li>clone方法:实现对象的浅赋值</li>
<li>getClass：返回运行时的类型</li>
<li>toString：转化为字符串</li>
<li>equals： 虽然很多说equals是比较值额，但是在Object中实际上还是比较地址的</li>
<li>hashCode：比较两个对象的哈希值，一般用于哈希查找</li>
<li>wait：使当前线程等待该对象的锁，当前线程具有该对象的锁</li>
<li>notify，唤醒在该对象上等待的某个线程</li>
<li>notifyAll：唤醒在该对象上等待的所有线程</li>
</ul>
<h3 id="Hashcode的作用"><a href="#Hashcode的作用" class="headerlink" title="Hashcode的作用"></a>Hashcode的作用</h3><p>hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</p>
<h3 id="Switch能否用string做参数"><a href="#Switch能否用string做参数" class="headerlink" title="Switch能否用string做参数"></a>Switch能否用string做参数</h3><p>这个和Java的版本有关，Java7之前无法使用字符串，在Java7以及以后的版本中可以使用字符串</p>
<h3 id="String、StringBuffer与StringBuilder的区别"><a href="#String、StringBuffer与StringBuilder的区别" class="headerlink" title="String、StringBuffer与StringBuilder的区别"></a>String、StringBuffer与StringBuilder的区别</h3><blockquote>
<p>String 是字符串常量，不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象。</p>
</blockquote>
<blockquote>
<p>StringBuffer是字符串变量，可变的对象，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象。并且StringBuffer是线程安全的，其很多方法可以带有synchronized关键字。</p>
</blockquote>
<blockquote>
<p>StringBuilder也是字符串变量，很多方面都和StringBuffer类似，但是最大的区别是StringBuilder是线程不安全的。</p>
</blockquote>
<ol>
<li>   三者在执行速度方面的比较：StringBuilder &gt;  StringBuffer  &gt;  String</li>
<li>   StringBuffer：线程安全的、StringBuilder：线程非安全的 </li>
</ol>
<p>适用情况：</p>
<ul>
<li><p>String：适用于少量的字符串操作的情况</p>
</li>
<li><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>
</li>
<li><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况</p>
</li>
</ul>
<h3 id="Comparator和Comparable"><a href="#Comparator和Comparable" class="headerlink" title="Comparator和Comparable"></a>Comparator和Comparable</h3><p>两种比较机制：Comparable 和 Comparator<br>Comparator，比较接口，涉及Collection的引入，具体的类本身不支持直接排序，重写Comparator内部的compareTo方法，可重用。<br>Comparable，排序的接口，具体的类内部实现compareTo方法，比如要比较两个Person，则需要在Person内部实现类方法compareTo，耦合性高</p>
<h3 id="java的浅拷贝和深拷贝"><a href="#java的浅拷贝和深拷贝" class="headerlink" title="java的浅拷贝和深拷贝"></a>java的浅拷贝和深拷贝</h3><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhangjg_blog/article/details/18369201">http://blog.csdn.net/zhangjg_blog/article/details/18369201</a></p>
<h3 id="Java静态内部类和内部类的区别"><a href="#Java静态内部类和内部类的区别" class="headerlink" title="Java静态内部类和内部类的区别"></a>Java静态内部类和内部类的区别</h3><p>内部类的作用：</p>
<blockquote>
<p>封装，隐藏不想让别人看的东西</p>
</blockquote>
<blockquote>
<p>完善多重继承，弥补Java只支持单继承的缺陷。当需要多重继承的时候，就可以实现多个内部类对应分别继承，实现外部类“多重继承”的效果。这也是内部类存在的最大意义。</p>
</blockquote>
<blockquote>
<p>闭包，内部类不仅包含创建内部类的作用域的信息，还自动拥有一个指向此外围类对象的引用</p>
</blockquote>
<blockquote>
<p>可以避免修改接口而实现同一个类中两种同名方法的调用，适用情况：当要继承的类和要实现的接口中有同名、同参数、同返回值的方法时。使用方法，让外部类去继承，内部类去实现接口</p>
</blockquote>
<p>（1） 被其他类访问：创建内部静态类实例的时候可以直接使用外部类名.内部类名访问内部类的静态成员或者需要新建一个内部类的实例来访问内部类的非静态成员。但非静态必须需要先新建一个外部类的实例，然后用外部类的实例创建内部类对象进行访问。<br>（2） 被外部类访问：对于非静态内部类外部类需要新建一个内部类的实例才能访问内部类，而对于静态内部类可以直接使用内部类类名访问内部类的静态成员或者新建一个内部类的实例访问内部类的非静态成员。<br>（3） 访问外部类：非静态内部类能够访问外部类的静态和非静态成员，所有访问权限。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员。<br>（4） 静态类和非静态类的共有区别：静态类，能够在这个类中定义静态的成员变量与成员方法，非静态内部类中不可以声明静态成员。</p>
<p><strong>局部内部类</strong>：类定义在外部类的方法中，并且有自己的类名。局部内部类相当于一个局部变量，所以不能有访问控制符以及static等修饰符。局部内部类的访问（包括对象的创建、方法的调用）局限在外部类的方法内部。</p>
<p><strong>匿名内部类</strong>：匿名内部类继承自一个类或者实现一个接口，使用方法是直接使用new 父类名称或者接口名称就可以创建自己匿名内部类的对象。</p>
<p>静态内部类的设计意图<br>主要的思想是，不需要保存引用，直接使用方法或者变量</p>
<h3 id="public等四个权限关键字的区别"><a href="#public等四个权限关键字的区别" class="headerlink" title="public等四个权限关键字的区别"></a>public等四个权限关键字的区别</h3><pre><code>访问权限   类   包  子类  其他包

public     ∨   ∨   ∨     ∨

protect    ∨   ∨   ∨     ×

default    ∨   ∨   ×     ×

private    ∨   ×   ×     ×
</code></pre>
<h3 id="final作用："><a href="#final作用：" class="headerlink" title="final作用："></a>final作用：</h3><p>当用final修饰一个类时，表明这个类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法<br>当用final修饰方法时，把方法锁定，以防任何继承类修改它的含义<br>当用final修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象（地址不可以改变，值可以改变）<br>当用final作用于类的成员变量时，成员变量必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。</p>
<h3 id="static的作用："><a href="#static的作用：" class="headerlink" title="static的作用："></a>static的作用：</h3><p>修饰类成员变量，来让此变量变成类的所属，而不是类的对象所属（多个实例具有相同的值）<br>修饰类成员方法，可以使用”类名.方法名”的方式操作方法，不需要先new一个对象<br>修饰对象类的对象时，static修饰的成员会首先被初始化<br>修饰静态导包用法，将类的方法直接导入到当前类中，从而直接使用“方法名”即可调用类方法，更加方便。</p>
<h3 id="try-里面return了finally还会执行吗"><a href="#try-里面return了finally还会执行吗" class="headerlink" title="try 里面return了finally还会执行吗"></a>try 里面return了finally还会执行吗</h3><p>1)、不管有木有出现异常，finally块中代码都会执行；<br>2)、当try和catch中有return时，finally仍然会执行；<br>3)、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4)、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p>
<h3 id="线程安全集合类与非线程安全集合类"><a href="#线程安全集合类与非线程安全集合类" class="headerlink" title="线程安全集合类与非线程安全集合类"></a>线程安全集合类与非线程安全集合类</h3><p>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;<br>HashMap是非线程安全的，HashTable是线程安全的;<br>StringBuilder是非线程安全的，StringBuffer是线程安全的。</p>
<h3 id="classloader"><a href="#classloader" class="headerlink" title="classloader"></a>classloader</h3><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/briblue/article/details/54973413">http://blog.csdn.net/briblue/article/details/54973413</a></p>
<h3 id="Java中强软弱虚四种引用"><a href="#Java中强软弱虚四种引用" class="headerlink" title="Java中强软弱虚四种引用"></a>Java中强软弱虚四种引用</h3><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhuojianhai88/article/details/13503007">http://blog.csdn.net/zhuojianhai88/article/details/13503007</a></p>
<h3 id="foreach与正常for循环效率对比"><a href="#foreach与正常for循环效率对比" class="headerlink" title="foreach与正常for循环效率对比"></a>foreach与正常for循环效率对比</h3><h3 id="java保证线程安全有哪些方法"><a href="#java保证线程安全有哪些方法" class="headerlink" title="java保证线程安全有哪些方法"></a>java保证线程安全有哪些方法</h3><ol>
<li>   Synchronized</li>
<li>   使用锁</li>
</ol>
<h3 id="线程安全的理解："><a href="#线程安全的理解：" class="headerlink" title="线程安全的理解："></a>线程安全的理解：</h3><p>一段代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，<br>就是线程安全的。</p>
<h3 id="Java有哪几种创建新线程的方法及区别"><a href="#Java有哪几种创建新线程的方法及区别" class="headerlink" title="Java有哪几种创建新线程的方法及区别"></a>Java有哪几种创建新线程的方法及区别</h3><p>继承Thread类创建线程类<br>通过Runnable接口创建线程类<br>通过Callable和Future创建线程</p>
<h3 id="Thread和Runnable比较："><a href="#Thread和Runnable比较：" class="headerlink" title="Thread和Runnable比较："></a>Thread和Runnable比较：</h3><p>Thread是一个可以继承的类，Runnable是一个接口，并且从Thread的源码可以发现， Thread类也是Runnable接口的子类；<br>Runnable接口相对于继承Thread类来说，有如下优点：</p>
<blockquote>
<p>首先Runnable作为接口，可以避免由于Java的单继承特性带来的局限。</p>
</blockquote>
<blockquote>
<p>适合多个相同程序代码的线程去处理同一资源的情况，支持线程间的资源共享。每个线程共享对象myRunnable的资源</p>
</blockquote>
<p>启动线程的方法：</p>
<blockquote>
<p>写一个类继承自Thread类,然后重写里面的run方法,用start方法启动线程</p>
</blockquote>
<blockquote>
<p>写一个类实现Runnable接口,实现里面的run方法,用new Thread(Runnable target).start()方法来启动.</p>
</blockquote>
<h3 id="synchronized的用法"><a href="#synchronized的用法" class="headerlink" title="synchronized的用法"></a>synchronized的用法</h3><p>可否嵌套，可以嵌套，但是容易造成死锁，互相等待。<br>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： </p>
<ol>
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象（此时这个对象不能执行其他的同步语句块）； </li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li>
<li>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li>
<li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li>
</ol>
<h3 id="Volatile的用法："><a href="#Volatile的用法：" class="headerlink" title="Volatile的用法："></a>Volatile的用法：</h3><h3 id="wait和sleep的区别，应用场景"><a href="#wait和sleep的区别，应用场景" class="headerlink" title="wait和sleep的区别，应用场景"></a>wait和sleep的区别，应用场景</h3><p>一般wait()和notify()方法使用于线程间的通信；sleep()方法用于暂停当前线程的执行。<br>sleep 是线程类（Thread）的静态方法，导致此线程暂停执行指定时间（阻塞当前线程），给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复，并且调用sleep不会释放对象锁。由于没有释放对象锁（锁还是存在），所以不能调用里面的同步方法。sleep必须捕获异常，可以自动唤醒<br>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；可以调用里面的同步方法，其他线程可以访问；必须要采用notify()和notifyAll()方法唤醒，<br>1，这两个方法来自不同的类分别是Thread和Object<br>2，最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(x) &#123;</span><br><span class="line">    x.notify()</span><br><span class="line">    <span class="comment">//或者wait()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4, sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</p>
<h3 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h3><p>死锁是指两个或两个以上的进程进在执行过程中，由于资源竞争或由于相互通信而造成的一种阻塞式现象，如果没有外力影响。那么它们将永远的持续下去， 此事称系统产生死锁现象，这种永远互相在等待的进程成为死锁。</p>
<p><strong>死锁的四个产生必要条件：</strong></p>
<p>1、（互斥）互斥条件：进程对所分配到的资源具有排他性使用，一段时间内某资源只由一个进程所占有。若此时还有其他请求资源，则请求者只能等待，知道占有资源的进程使用完毕释放。<br>2、（占有并等待）请求和保持条件：进程已经保持至少一个资源，但是又提出心得资源请求，而该资源已经被其他进程所占有，此时请求进程阻塞，但又对自己已经获得的其他资源保持不变。<br>3、（非抢占）不可剥夺条件：进程获得的资源，在未使用完之前，不能被剥夺，只能在使用完时有自己释放。<br>4、（循环等待）环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p>
<h2 id="算法与数据结构相关"><a href="#算法与数据结构相关" class="headerlink" title="算法与数据结构相关"></a>算法与数据结构相关</h2><h3 id="链表和数组比较"><a href="#链表和数组比较" class="headerlink" title="链表和数组比较"></a>链表和数组比较</h3><pre><code>    数组静态分配内存，链表动态分配内存；

    数组在内存中连续，链表不一定连续；

    数组元素在栈区，链表元素在堆区；

    数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；

    数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。
    
    
</code></pre>
<h3 id="Hashmap的原理（很重要）"><a href="#Hashmap的原理（很重要）" class="headerlink" title="Hashmap的原理（很重要）"></a>Hashmap的原理（很重要）</h3><p>在另外一篇介绍容器的博客</p>
<p><img src="http://dengw.xyz/hexo-blog/180426/ljG5K6bB9D.png"></p>
<h3 id="Hashmap和hashtable比较"><a href="#Hashmap和hashtable比较" class="headerlink" title="Hashmap和hashtable比较"></a>Hashmap和hashtable比较</h3><h3 id="TreeMap、HashMap、LindedHashMap的区别"><a href="#TreeMap、HashMap、LindedHashMap的区别" class="headerlink" title="TreeMap、HashMap、LindedHashMap的区别"></a>TreeMap、HashMap、LindedHashMap的区别</h3><h3 id="ArrayList和LinkedList的实现和区别"><a href="#ArrayList和LinkedList的实现和区别" class="headerlink" title="ArrayList和LinkedList的实现和区别"></a>ArrayList和LinkedList的实现和区别</h3><h3 id="List与Set、Map"><a href="#List与Set、Map" class="headerlink" title="List与Set、Map"></a>List与Set、Map</h3><h3 id="Map、Set、List、Queue、Stack的特点与用法。"><a href="#Map、Set、List、Queue、Stack的特点与用法。" class="headerlink" title="Map、Set、List、Queue、Stack的特点与用法。"></a>Map、Set、List、Queue、Stack的特点与用法。</h3><h3 id="HashSet和TreeSet"><a href="#HashSet和TreeSet" class="headerlink" title="HashSet和TreeSet"></a>HashSet和TreeSet</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">smap</span><span class="params">(<span class="keyword">int</span> []a, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tem = a[index1];</span><br><span class="line">    a[index1] = a[index2];</span><br><span class="line">    a[index2] = tem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="keyword">int</span> []a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = a[low];</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; num &lt; a[high]) &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        smap(a, low, high);</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; num &gt;= a[low]) &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        smap(a, low, high);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = partion(a, low, high);</span><br><span class="line">        quickSort(a, low, index - <span class="number">1</span>);</span><br><span class="line">        quickSort(a, index + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h3 id="AVL树-平衡二叉树"><a href="#AVL树-平衡二叉树" class="headerlink" title="AVL树(平衡二叉树)"></a>AVL树(平衡二叉树)</h3><ul>
<li>左子树和右子树的高度之差的绝对值不超过1</li>
<li>树中的每个左子树和右子树都是AVL树</li>
<li>每个节点都有一个平衡因子(balance factor–bf),任一节点的平衡因子是-1,0,1。(每个节点的平衡因子等于右子树的高度减去左子树的高度 )  </li>
</ul>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>只能有最下面两层的子节点度数不为2</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>除了最下面一层外每个节点都有两个子节点</p>
<p><img src="http://dengw.xyz/hexo-blog/180426/hh298Df396.png"></p>
<p>红黑树<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sun_tttt/article/details/65445754">https://blog.csdn.net/sun_tttt/article/details/65445754</a></p>
<p>Hash表<br>B+树</p>
<h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><p>进程冲突，生产者消费者问题，设逻辑分页和物理分页好处是什么，什么是脏内存</p>
<p>虚拟地址、逻辑地址、线性地址、物理地址的区别</p>
<p><strong>什么是虚拟内存</strong></p>
<p><strong>虚拟内存别称虚拟存储器（Virtual Memory）</strong></p>
<p><strong>进程的几种状态</strong><br>三态模型：</p>
<p>五态模型：</p>
<p><strong>线程的几种状态</strong><br>线程只有3个基本状态：就绪，执行，阻塞</p>
<p><strong>进程和线程的区别</strong><br>进程，是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竟争计算机系统资源的基本单位。每一个进程都有一个自己的地址空间，即进程空间或(虚空间)。进程空间的大小只与处理机的位数有关，一个16位长处理机的进程空间大小为216，而32位处理机的进程空间大小为232。进程至少有5种基本状态,它们是：初始态，执行态，等待状态，就绪状态，终止状态。</p>
<p>线程，在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中线程的概念便被引进了。线程，是进程的一部分，一个没有线程的进程可以被看作是单线程的。线程有时又被称为轻权进程或轻量级进程，也是 CPU 调度的一个基本单位。</p>
<p><strong>进程通信(IPC几种通信方式)</strong></p>
<h2 id="计算机网络相关"><a href="#计算机网络相关" class="headerlink" title="计算机网络相关"></a>计算机网络相关</h2><h3 id="http1-1相比以前版本（http1-0）有什么改变"><a href="#http1-1相比以前版本（http1-0）有什么改变" class="headerlink" title="http1.1相比以前版本（http1.0）有什么改变"></a>http1.1相比以前版本（http1.0）有什么改变</h3><p>HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象,；<br>HTTP/1.1默认使用持久连接，一个tcp连接可以传输多个web对象</p>
<h3 id="七层-五层模型"><a href="#七层-五层模型" class="headerlink" title="七层/五层模型"></a>七层/五层模型</h3><p>七层：物理层，链路层，网络层，传输层，会话层，表示层，应用层<br>五层：物理层，链路层，网络层，传输层，应用层<br>其中：</p>
<blockquote>
<p>表示层：信息语言语法语义以及它们的关联，如加密解密，转换翻译等<br>会话层：不同机器上的用户之间建立以及管理会话</p>
</blockquote>
<h3 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h3><p>GET主要是客户端的语义是请求获取指定的资源，主要用于客户端从服务端获取资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束）,GET方法的报文主体没有任何语义，适合传输少量数据</p>
<p>POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，主要用于客户端旺服务端提交信息，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存、对传送的数据大小没有限制</p>
<p><strong>get和post区别</strong></p>
<ol>
<li><p>GET提交:<br>请求的数据会附在URL之后（就是把数据放置在HTTP协议头＜request-line＞中），以?分割URL和传输数据，多个参数用&amp;连接;例如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0 %E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。</p>
</li>
<li><p>POST提交：<br>把提交的数据放置在是HTTP包的包体＜request-body＞中。上文示例中红色字体标明的就是实际的传输数据</p>
</li>
</ol>
<p>因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p>
<p><strong>传输数据的大小</strong>：<br>   首先声明,HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有：</p>
<p>   GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>
<p>   因此对于GET提交时，传输数据就会受到URL长度的限制。</p>
<p>   POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。</p>
<p><strong>安全性</strong>：<br>    POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了</p>
<h3 id="Http的报文结构"><a href="#Http的报文结构" class="headerlink" title="Http的报文结构"></a>Http的报文结构</h3><p><img src="http://dengw.xyz/hexo-blog/180426/HK0Le1E7cc.png" alt="请求报文"></p>
<p><img src="http://dengw.xyz/hexo-blog/180426/HImLIiD8hg.png" alt="返回报文"></p>
<h3 id="Http的状态码含义"><a href="#Http的状态码含义" class="headerlink" title="Http的状态码含义"></a>Http的状态码含义</h3><ul>
<li>200 ：OK：请求成功</li>
<li>204： 服务器成功处理了请求，但没有返回任何内容</li>
<li>301  Moved Permanently：请求的网页已永久移动到新位置。当URLs发生变化时，使用301代码。搜索引擎索引中保存新的URL。 </li>
<li>302： 请求的网页临时移动到新位置。搜索引擎索引中保存原来的URL。</li>
<li>304： 如果网页自请求者上次请求后没有更新，则用304代码告诉搜索引擎机器人，可节省带宽和开销。</li>
<li>400：Bad Request：一个通用差错代码，指示该请求不能被服务器理解</li>
<li>403：服务器拒绝请求。</li>
<li>404：Not Found：被请求的文档不在服务器上</li>
<li>500：服务器遇到错误，无法完成请求。 </li>
<li>503：服务器目前无法使用（由于超载或停机维护）</li>
<li>505：HTTP Version Not Support: 服务器不支持当前http协议的版本</li>
</ul>
<h3 id="Http-request的几种类型"><a href="#Http-request的几种类型" class="headerlink" title="Http request的几种类型"></a>Http request的几种类型</h3><ul>
<li>Get: 一般用来从客户端从服务器中读取内容，服务器将URL定位的资源放在响应报文的数据部分，回送给客户端</li>
<li>Post:</li>
<li>HEAD：HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</li>
<li>PUT</li>
<li>DELETE</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>CONNECT</li>
</ul>
<h3 id="HTTP和HTTPS协议的差别："><a href="#HTTP和HTTPS协议的差别：" class="headerlink" title="HTTP和HTTPS协议的差别："></a>HTTP和HTTPS协议的差别：</h3><p>超文本传输协议HTTP被用于在Web客户端程序和网站端程序之间传递信息，两个端系统之间通过HTTP报文进行会话，HTTP定义了这些报文的结构以及客户和服务器进行报文交换方式，它有两个很鲜明的特点：一是HTTP是一个无状态协议，二是它以明文方式发送内容，不提供任何方式的数据加密。<br>HTTPS就是为了解决HTTP协议的没办法加密的这一缺陷而产生的，毕竟不加密的话数据报文被窃取是很危险的，全称为安全套接字层超文本传输协议HTTPS，是在HTTP的基础上加入了SSL协议，使用SSL协议的加密算法来完成身份验证，并为浏览器和服务器之间的通信加密，它的安全基础是SSL协议。</p>
<p>用的端口也不一样，前者是80，后者是443</p>
<h3 id="SSL-TLS-握手"><a href="#SSL-TLS-握手" class="headerlink" title="SSL/TLS 握手"></a>SSL/TLS 握手</h3><p>SSL/TLS 协议是用来给HTTPS进行加密的，作用在 HTTP 协议之下，使用SSL的加密算法完成身份验证，防制报文信息被窃取（谈一谈HTTP的缺陷）</p>
<p>过程：就是https对称加密的原理，如下</p>
<p>https的非对称加密：非对称加密采用的是SSL协议完成的，过程如下：</p>
<ul>
<li>当你的浏览器使用htts的形式向服务器请求一个安全的网页</li>
<li>服务器就把它的证书和公匙发回来</li>
<li>浏览器检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的。</li>
<li>浏览器随机生成一对对称秘钥，并使用公钥（服务器端的）加密该对称秘钥，将它和对称加密后的URL一起发送到服务器</li>
<li>服务器用自己的私匙解密了你发送的钥匙。然后用这把对称加密的钥匙给你请求的URL链接解密。</li>
<li>服务器用你发的对称钥匙给你请求的网页加密。你也有相同的钥匙就可以解密发回来的网页</li>
</ul>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ul>
<li><p>TCP面向连接;UDP是无连接的，即发送数据之前不需要建立连接</p>
</li>
<li><p>TCP提供可靠的服务。背后有一套完整的机制确保通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保证可靠交付</p>
</li>
<li><p>UDP对应用层的控制更加精确，UDP会立即将应用层的报文发送给网络层。</p>
</li>
<li><p>每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信</p>
</li>
<li><p>TCP首部开销20字节;UDP的首部开销小，只有8个字节，TCP报文有20个字节的首部</p>
</li>
<li><p>一般实时类的应用选择UDP作为传输层协议。</p>
</li>
</ul>
<h3 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h3><p><img src="http://dengw.xyz/hexo-blog/180426/4fhfhjmjbE.png"></p>
<p>上图中有几个字段需要重点介绍下：</p>
<ol>
<li>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li>
<li>确认序号： Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</li>
<li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<blockquote>
<p>URG：紧急指针（urgent pointer）有效。<br>ACK：确认序号有效。<br>PSH：接收方应该尽快将这个报文交给应用层。<br>RST：重置连接。<br>SYN：发起一个新连接。<br>FIN：释放一个连接。</p>
</blockquote>
</li>
</ol>
<p>需要注意的是：<br>不要将确认序号Ack与标志位中的ACK搞混了。<br>确认方Ack=发起方Req+1，两端配对。</p>
<h3 id="TCP滑动窗口与回退N针协议"><a href="#TCP滑动窗口与回退N针协议" class="headerlink" title="TCP滑动窗口与回退N针协议"></a>TCP滑动窗口与回退N针协议</h3><p>发送方只是用一个定时器，超时重传多有已发但还未被确认过的分组<br>容错率低，单个分组可能造成GBN重传大量分组：<br>P147</p>
<h3 id="TCP选择重传"><a href="#TCP选择重传" class="headerlink" title="TCP选择重传"></a>TCP选择重传</h3><p>每个分组都有一个定时器，发送方超时只会重新发送一个分组<br>P151</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><h3 id="Tcp三次握手的过程"><a href="#Tcp三次握手的过程" class="headerlink" title="Tcp三次握手的过程"></a>Tcp三次握手的过程</h3><p><img src="http://dengw.xyz/hexo-blog/180426/dEiLHj5b1F.png"></p>
<p>如果确认信号没传到服务器会发生什么？为什么不是两次握手？</p>
<p>还要再发送一次确认是为了，防止已失效的连接请求报文段突然又传到了B，因而产生错误。<br>     某种情况下，A的第一个请求在某个节点滞留了，延误到达，本来这是一个早已失效的报文段，但是在A发送第二个，并且得到B的回应，建立了连接以后，这个报文段竟然到达了，于是B就认为，A又发送了一个新的请求，于是发送确认报文段，同意建立连接，假若没有三次的握手，那么这个连接就建立起来了（有一个请求和一个回应），此时，A收到B的确认，但A知道自己并没有发送建立连接的请求，因为不会理睬B的这个确认，于是呢，A也不会发送任何数据，而B呢却以为新的连接建立了起来，一直等待A发送数据给自己，此时B的资源就被白白浪费了。但是采用三次握手的话，A就不发送确认，那么B由于收不到确认，也就知道并没有要求建立连接。<br>     简而言之：第三次握手，主机A发送一次确认是为了防止：如果客户端迟迟没有收到服务器返回的确认报文，这时他会放弃连接，重新启动一条连接请求；但问题是：服务器不知客户端没收到，所以他会收到两个连接请求，白白浪费了一条连接开销。</p>
<h3 id="Tcp四次挥手的过程"><a href="#Tcp四次挥手的过程" class="headerlink" title="Tcp四次挥手的过程"></a>Tcp四次挥手的过程</h3><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><img src="http://dengw.xyz/hexo-blog/180426/cagcJbgJbE.png"></p>
<ol>
<li>A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。</li>
<li>B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。</li>
<li>A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li>
<li>B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。</li>
<li>A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</li>
</ol>
<h3 id="电脑上访问一个网页的过程"><a href="#电脑上访问一个网页的过程" class="headerlink" title="电脑上访问一个网页的过程"></a>电脑上访问一个网页的过程</h3><p>DNS、HTTP、TCP、OSPF、IP、ARP。</p>
<h3 id="Ping的整个过程"><a href="#Ping的整个过程" class="headerlink" title="Ping的整个过程"></a>Ping的整个过程</h3><p>ICMP报文是什么。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/26/Android%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" data-id="ckqm6kpns007oxxr58pecbsx0" data-title="Android实习面试知识整理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2018年实习春招总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/04/25/2018%E5%B9%B4%E5%AE%9E%E4%B9%A0%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-04-25T15:53:01.000Z" itemprop="datePublished">2018-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/04/25/2018%E5%B9%B4%E5%AE%9E%E4%B9%A0%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/">2018年实习春招面试总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>到今天为止，我的实习春招之路应该可以画上一个句号了，至于说这个句号完不完整，个人还是比较满意的。从量出比的角度来看，可以说自己的努力没有白费吧。从过完年之后决定找安卓方向的实习开始，到三月份从头再学习一遍安卓基础知识、系统性学习Java，然后在四月初开始出去面试，到现在收获第一个offer，现在回想起这个过程，心里面真的竟有感触的。整个三、四月份基本上都是凌晨两三点才睡，平均每天六个小时的睡眠，翘了无数的课，心情从每次面试前的满怀希望到面试后失望甚至到后期的绝望。晚上开始失眠，半个小时、一个小时、两个小时、三个小时，翻来覆去，第一次感受到这么大的压力。天晚上接完hr的录用电话后，那一刻真的想哭，真的很心酸…但是却什么也不想多说，只想静静地坐着，就那样坐着。</p>
<p>这次春招的收获，我觉得offer是一方面，另一方面深深刻刻地认识到自己的不足，真的是太弱了，要学习的东西太多了，太多了…这也为秋招敲响了警钟吧。知不足而奋进，我想，如果能够好好总结这次春招，根据面试过程中自己暴露出的薄弱项进行有针对的弥补与提高，也将会成为这次春招最大的收获吧。</p>
<p>面试过程中暴露出了如下一些问题：</p>
<h3 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h3><ul>
<li><p>Java泛型类</p>
</li>
<li><p>Java的内存管理</p>
</li>
<li><p>Java垃圾回收机制</p>
</li>
<li><p>Java虚拟机相关的知识</p>
</li>
<li><p>Java中线程相关，锁与同步的问题</p>
</li>
<li><p>Java并发编程相关的</p>
</li>
<li><p>一些比较底层的实现原理，比如：Java多态的实现原理</p>
</li>
<li><p>Java文件操作</p>
</li>
<li><p>Java网络访问</p>
</li>
</ul>
<p>总的来说，对于Java相关的知识，不管是广度还是深度都没有，有很多重要知识点是一点都没有了解，比如Java虚拟机相关的，另外一点就是对Java的底层原理了解的太少，面试官问的稍微深一点就不说不出来了。</p>
<h3 id="Android相关"><a href="#Android相关" class="headerlink" title="Android相关"></a>Android相关</h3><p>Android在面试中暴露出的问题主要有如下几个方面：</p>
<ul>
<li><p>底层实现原理不了解，现在掌握程度只停留在使用上，技术深度不够</p>
</li>
<li><p>纸上得来终觉浅，一些知识点没有亲自上手，很容易就遗忘或者理解有误</p>
</li>
<li><p>项目经验严重不足，对于技术难点以及一些问题的解决方法一点都不了解</p>
</li>
<li><p>设计模式太陌生了</p>
</li>
<li><p>常见的框架仅仅停留在使用的层面上，对实现方法不了解</p>
</li>
<li><p>没有了解的特别深入的知识点，与面试官的共同语言太少</p>
</li>
<li><p>知识广度不够，比如像性能优JNI和NDK相关的知识一点都不了解</p>
</li>
<li><p>对新技术了解地太少，比如插件化，热修复等</p>
</li>
</ul>
<p>上面罗列的知识只是一些大概的方向，没有涉及到具体的问题，还要总结一下具体的没有答上来或者没有答好的问题。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>卒</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><p>有待完善</p>
<h3 id="信息安全相关"><a href="#信息安全相关" class="headerlink" title="信息安全相关"></a>信息安全相关</h3><p>有待完善</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>有待完善</p>
<h3 id="面试问题整理"><a href="#面试问题整理" class="headerlink" title="面试问题整理"></a>面试问题整理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/code__man/article/details/79635714">BAT大厂Android面试题Java部分问题和答案整理(一)</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c70989bd5f29">最全的BAT大厂Android面试题整理</a><br><a target="_blank" rel="noopener" href="https://github.com/AweiLoveAndroid/CommonDevKnowledge">常用的Android开发的一些技能点以及史上最全的BAT大厂Android面试题汇集</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cf5092fa2694?utm_source=desktop&utm_medium=timeline">Android大厂面试题锦集(BAT TMD JD 小米)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xhmj12/article/details/54730883">Android面试题</a><br><a target="_blank" rel="noopener" href="https://github.com/Mr-YangCheng/ForAndroidInterview">Android 名企面试题及涉及知识点整理</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34111396">Android基础知识面试30题及答案</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/04/25/2018%E5%B9%B4%E5%AE%9E%E4%B9%A0%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/" data-id="ckqm6kpkl0001xxr523nn9v4u" data-title="2018年实习春招面试总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php%E5%AD%A6%E4%B9%A0/">php学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring%E5%AD%A6%E4%B9%A0/">spring学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">数据存储</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANR/" rel="tag">ANR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="tag">Android消息机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Animation/" rel="tag">Animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera%E5%BC%80%E5%8F%91/" rel="tag">Camera开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/" rel="tag">Intent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">Java内存机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%AE%B9%E5%99%A8/" rel="tag">Java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%91%BD%E4%BB%A4/" rel="tag">Linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP/" rel="tag">MVP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecylerView/" rel="tag">RecylerView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Window/" rel="tag">Window</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" rel="tag">apk反编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/" rel="tag">spring-boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag">剑指Offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0/" rel="tag">实习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">文件下载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/" rel="tag">网络框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/" rel="tag">自定义View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" rel="tag">项目总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANR/" style="font-size: 10px;">ANR</a> <a href="/tags/Activity/" style="font-size: 12.5px;">Activity</a> <a href="/tags/Android/" style="font-size: 12.5px;">Android</a> <a href="/tags/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Android消息机制</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/Camera%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Camera开发</a> <a href="/tags/Canvas/" style="font-size: 10px;">Canvas</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/HTTP/" style="font-size: 17.5px;">HTTP</a> <a href="/tags/Intent/" style="font-size: 10px;">Intent</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Java内存机制</a> <a href="/tags/Java%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">Java容器</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 17.5px;">Java虚拟机</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">Linux命令</a> <a href="/tags/MVP/" style="font-size: 10px;">MVP</a> <a href="/tags/RecylerView/" style="font-size: 10px;">RecylerView</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/View%E5%B8%83%E5%B1%80/" style="font-size: 20px;">View布局</a> <a href="/tags/Window/" style="font-size: 10px;">Window</a> <a href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" style="font-size: 10px;">apk反编译</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 10px;">spring-boot</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/vim/" style="font-size: 12.5px;">vim</a> <a href="/tags/%E5%89%91%E6%8C%87Offer/" style="font-size: 10px;">剑指Offer</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 12.5px;">反射</a> <a href="/tags/%E5%AE%9E%E4%B9%A0/" style="font-size: 12.5px;">实习</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" style="font-size: 10px;">文件下载</a> <a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 17.5px;">校招</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">泛型</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 15px;">类加载</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">网络框架</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/" style="font-size: 10px;">自定义View</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" style="font-size: 10px;">项目总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/06/Mac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/">Mac终端常用快捷键总结</a>
          </li>
        
          <li>
            <a href="/2019/06/23/%E5%85%B3%E4%BA%8Ephp%E7%9A%84empty%E5%87%BD%E6%95%B0/">关于php的empty函数</a>
          </li>
        
          <li>
            <a href="/2019/06/16/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">Spring常用注解</a>
          </li>
        
          <li>
            <a href="/2019/06/05/%E4%BD%BF%E7%94%A8-gitignore%E9%85%8D%E7%BD%AEgit%E5%BF%BD%E7%95%A5%E6%8F%90%E4%BA%A4%E8%A7%84%E5%88%99/">使用.gitignore配置git忽略提交规则</a>
          </li>
        
          <li>
            <a href="/2019/06/05/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">Mysql常用命令总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>