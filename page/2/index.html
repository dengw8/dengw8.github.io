<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Kotlins初学记录" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/11/19/Kotlins%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/" class="article-date">
  <time class="dt-published" datetime="2018-11-19T01:57:28.000Z" itemprop="datePublished">2018-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/11/19/Kotlins%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/">Kotlins初学记录</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="var和val的区别"><a href="#var和val的区别" class="headerlink" title="var和val的区别"></a>var和val的区别</h4><p>var是一个可变变量，可以通过重新分配来更改为另一个值的变量，这种声明变量的方式和java中声明变量的方式一样。</p>
<p>val是一个只读变量，这种声明变量的方式相当于java中的final变量。一个val创建的时候必须初始化，因为以后不能被改变。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><h4 id="区间范围"><a href="#区间范围" class="headerlink" title="区间范围"></a>区间范围</h4><ul>
<li><p>in a..b<br>表示[a, b]</p>
</li>
<li><p>in a until b<br>表示[a, b)</p>
</li>
</ul>
<h4 id="只读list"><a href="#只读list" class="headerlink" title="只读list"></a>只读list</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Long类型显示加L"><a href="#Long类型显示加L" class="headerlink" title="Long类型显示加L"></a>Long类型显示加L</h4><p>如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Long</span> a = <span class="number">123L</span></span><br></pre></td></tr></table></figure>

<h4 id="浮点数默认为Double类型"><a href="#浮点数默认为Double类型" class="headerlink" title="浮点数默认为Double类型"></a>浮点数默认为Double类型</h4><p>Float 必须要用 f 或者 F 标记，如 123.5f</p>
<h4 id="kotlin数据类型"><a href="#kotlin数据类型" class="headerlink" title="kotlin数据类型"></a>kotlin数据类型</h4><p>kotlin中不存在基本数据类型，所有的东西都是对象；</p>
<p>几种表示数字的内置类型：Double、Float、Long、Int、Short、Char、Byte</p>
<h4 id="相等性和同一性"><a href="#相等性和同一性" class="headerlink" title="相等性和同一性"></a>相等性和同一性</h4><ul>
<li><p>相等性<br>即数值相等，对应于函数equals 或者 “==”</p>
</li>
<li><p>同一性<br>是否是用一个对象，对应于“===”</p>
</li>
</ul>
<h4 id="较小的类型不能够隐式转化为较大的类型"><a href="#较小的类型不能够隐式转化为较大的类型" class="headerlink" title="较小的类型不能够隐式转化为较大的类型"></a>较小的类型不能够隐式转化为较大的类型</h4><p>⚠️注意这一点是和 java 的区别<br>例如下面的代码就会报错：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, 字面值是静态检测的</span></span><br><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>我们可以显式转换来拓宽数字</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b.toInt() <span class="comment">// OK：显式拓宽</span></span><br></pre></td></tr></table></figure>

<h4 id="Char类型不能直接当作数字"><a href="#Char类型不能直接当作数字" class="headerlink" title="Char类型不能直接当作数字"></a>Char类型不能直接当作数字</h4><h3 id="包与导入"><a href="#包与导入" class="headerlink" title="包与导入"></a>包与导入</h3><h4 id="可见性修饰符介绍"><a href="#可见性修饰符介绍" class="headerlink" title="可见性修饰符介绍"></a>可见性修饰符介绍</h4><p><a target="_blank" rel="noopener" href="https://www.kotlincn.net/docs/reference/visibility-modifiers.html#%E6%A8%A1%E5%9D%97">Kotlin文档介绍</a></p>
<p>注意⚠️：Kotlin 中外部类不能访问内部类的 private 成员，这一点在java中可以</p>
<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><h4 id="If表达式"><a href="#If表达式" class="headerlink" title="If表达式"></a>If表达式</h4><p>if是一个表达式，即它会返回一个值</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java用法</span></span><br><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    max = a</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max = b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// kotlin 中作为表达式</span></span><br><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure>
<p>当然也可以想java那样当作代码块中的语句使用</p>
<p>但是，如果你使用 if 作为表达式而不是语句，该表达式需要有 else 分支，例如下面是语句就会报错：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> max = <span class="keyword">if</span> (a &gt; b) a</span><br></pre></td></tr></table></figure>

<h4 id="when表达式取代switch"><a href="#when表达式取代switch" class="headerlink" title="when表达式取代switch"></a>when表达式取代switch</h4><p>when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。</p>
<p>常见形式</p>
<p>作为控制快：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">&quot;x == 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">&quot;x == 2&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; &#123; <span class="comment">// 注意这个块</span></span><br><span class="line">        print(<span class="string">&quot;x is neither 1 nor 2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为表达式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="keyword">when</span> (sign) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="number">1</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意⚠️： 如果 when 作为一个表达式使用，则必须有 else 分支；</p>
<h4 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h4><p>在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签</p>
<p>标签结合break和continue使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">loop@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (……) <span class="keyword">break</span><span class="symbol">@loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签在内联函数的使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span> <span class="comment">// 非局部直接返回到 foo() 的调用者</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;this point is unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了只退出lambda表达式，像下面：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach <span class="symbol">lit@</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@lit</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot; done with explicit label&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简介版：标签与接受该 lambda 的函数同名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).forEach &#123;</span><br><span class="line">        <span class="keyword">if</span> (it == <span class="number">3</span>) <span class="keyword">return</span><span class="symbol">@forEach</span> <span class="comment">// 局部返回到该 lambda 表达式的调用者，即 forEach 循环</span></span><br><span class="line">        print(it)</span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot; done with implicit label&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="主构造函数和次构造函数的区别"><a href="#主构造函数和次构造函数的区别" class="headerlink" title="主构造函数和次构造函数的区别"></a>主构造函数和次构造函数的区别</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xlh1191860939/article/details/79412319">Kotlin的构造函数介绍</a></p>
<h4 id="不需要使用new关键字"><a href="#不需要使用new关键字" class="headerlink" title="不需要使用new关键字"></a>不需要使用new关键字</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rectangle = Rectangle(<span class="number">5.0</span>, <span class="number">2.0</span>) <span class="comment">// 不需要“new”关键字</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展函数是静态解析的"><a href="#扩展函数是静态解析的" class="headerlink" title="扩展函数是静态解析的"></a>扩展函数是静态解析的</h4><p>扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。</p>
<p>我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">D</span>: <span class="type">C</span></span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> C.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">&quot;c&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> D.<span class="title">foo</span><span class="params">()</span></span> = <span class="string">&quot;d&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printFoo</span><span class="params">(c: <span class="type">C</span>)</span></span> &#123;</span><br><span class="line">        println(c.foo())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printFoo(D())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子会输出 “c”，因为调用的扩展函数只取决于参数 c 的声明类型，该类型是 C 类。</p>
<h4 id="幕后属性的理解"><a href="#幕后属性的理解" class="headerlink" title="幕后属性的理解"></a>幕后属性的理解</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27493630">幕后字段和 field</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/69f5b8a46eba">kotlin的幕后字段(backing field)的个人理解</a></p>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b4b9e3686171">Kotlin学习笔记（四十一）密封类</a></p>
<p> 密封类</p>
<ul>
<li>1.密封类用sealed关键词表示</li>
<li>2.密封类的子类只能定义在密封类的内部或同一个文件中，因为其构造方法为私有的</li>
<li>3.密封类相比于普通的open类，可以不被此文件外被继承，有效保护代码</li>
<li>4.与枚举的区别：密封类适用于子类可数的情况，枚举适用于实例可数的情况</li>
</ul>
<h4 id="嵌套类与内部类"><a href="#嵌套类与内部类" class="headerlink" title="嵌套类与内部类"></a>嵌套类与内部类</h4><p>嵌套类和内部类的一个区别是：嵌套类不能够访问外部类的成员以及方法，而内部类可以访问。</p>
<p>内部类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用方法：</span><br><span class="line">Outer().Nested().foo()</span><br></pre></td></tr></table></figure>

<p>嵌套类：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> bar: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Nested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> = bar   <span class="comment">//这样的话编译器会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Outer.Nested().foo()</span><br></pre></td></tr></table></figure>

<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><ul>
<li>声明处型变</li>
</ul>
<p>在 Kotlin 中，有一种方法向编译器解释这种情况。这称为声明处型变：我们可以标注 Source 的类型参数 T 来确保它仅从 Source<T> 成员中返回（生产），并从不被消费。 为此，我们提供 <code>out</code> 修饰符：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Source</span>&lt;<span class="type">out T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">nextT</span><span class="params">()</span></span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(strs: <span class="type">Source</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> objects: Source&lt;Any&gt; = strs <span class="comment">// 这个没问题，因为 T 是一个 out-参数</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般原则是：当一个类 C 的类型参数 T 被声明为 out 时，它就只能出现在 C 的成员的输出-位置，但回报是 C<Base> 可以安全地作为 C<Derived>的超类。(这一点在java不允许)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Source&lt;String&gt; strs)</span> </span>&#123;</span><br><span class="line">  Source&lt;Object&gt; objects = strs; <span class="comment">// ！！！在 Java 中不允许</span></span><br><span class="line">  <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，他们说类 C 是在参数 T 上是协变的，或者说 T 是一个协变的类型参数。 你可以认为 C 是 T 的生产者，而不是 T 的消费者。</p>
<p><strong>注</strong>：称那些你只能从中读取的对象为<code>生产者</code>，并称那些你只能写入的对象为<code>消费者</code>。</p>
<p>另外除了<code>out</code>，Kotlin 又补充了一个型变注释：<code>in</code>。它使得一个类型参数逆变：只可以被消费而不可以被生产。逆变类型的一个很好的例子是 Comparable：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">T</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">demo</span><span class="params">(x: <span class="type">Comparable</span>&lt;<span class="type">Number</span>&gt;)</span></span> &#123;</span><br><span class="line">    x.compareTo(<span class="number">1.0</span>) <span class="comment">// 1.0 拥有类型 Double，它是 Number 的子类型</span></span><br><span class="line">    <span class="comment">// 因此，我们可以将 x 赋给类型为 Comparable &lt;Double&gt; 的变量</span></span><br><span class="line">    <span class="keyword">val</span> y: Comparable&lt;<span class="built_in">Double</span>&gt; = x <span class="comment">// OK！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们相信 in 和 out 两词是自解释的（因为它们已经在 C# 中成功使用很长时间了）， 因此上面提到的助记符不是真正需要的，并且可以将其改写为更高的目标：</p>
<ul>
<li>类型投影</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">copy</span><span class="params">(from: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">Any</span>&gt;, to: <span class="type">Array</span>&lt;<span class="type">Any</span>&gt;)</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>这里发生的事情称为 <code>类型投影</code>：我们说from不仅仅是一个数组，而是一个受限制的（投影的）数组：我们只可以调用返回类型为类型参数 T 的方法，如上，这意味着我们只能调用 get()。这就是我们的使用处型变的用法，并且是对应于 Java 的 Array&lt;? extends Object&gt;、 但使用更简单些的方式。</p>
<p>你也可以使用 in 投影一个类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fill</span><span class="params">(dest: <span class="type">Array</span>&lt;<span class="type">in</span> <span class="type">String</span>&gt;, value: <span class="type">String</span>)</span></span> &#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>Array<in String> 对应于 Java 的 Array&lt;? super String&gt;，也就是说，你可以传递一个 CharSequence 数组或一个 Object 数组给 fill() 函数。</p>
<ul>
<li>泛型函数</li>
</ul>
<p>不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">singletonList</span><span class="params">(item: <span class="type">T</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">basicToString</span><span class="params">()</span></span> : String &#123;  <span class="comment">// 扩展函数</span></span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> 泛型约束</li>
</ul>
<p>能够替换给定类型参数的所有可能类型的集合可以由泛型约束限制。</p>
<p><strong>上界</strong></p>
<p>最常见的约束类型是与 Java 的 extends 关键字对应的 上界：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;  …… &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Comparable&lt;T&gt;</span>&gt; <span class="title">sort</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;  …… &#125;</span><br></pre></td></tr></table></figure>
<p>冒号之后指定的类型是上界：只有 Comparable<T> 的子类型可以替代 T。 例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// OK。Int 是 Comparable&lt;Int&gt; 的子类型</span></span><br><span class="line">sort(listOf(HashMap&lt;<span class="built_in">Int</span>, String&gt;())) <span class="comment">// 错误：HashMap&lt;Int, String&gt; 不是 Comparable&lt;HashMap&lt;Int, String&gt;&gt; 的子类型</span></span><br></pre></td></tr></table></figure>
<p>默认的上界（如果没有声明）是 Any?。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 where-子句：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">copyWhenGreater</span><span class="params">(list: <span class="type">List</span>&lt;<span class="type">T</span>&gt;, threshold: <span class="type">T</span>)</span></span>: List&lt;String&gt;</span><br><span class="line">    <span class="keyword">where</span> T : CharSequence,</span><br><span class="line">          T : Comparable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> list.filter &#123; it &gt; threshold &#125;.map &#123; it.toString() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类型擦除</li>
</ul>
<p>Kotlin 为泛型声明用法执行的类型安全检测仅在编译期进行。 运行时泛型类型的实例不保留关于其类型实参的任何信息。 其类型信息称为被擦除。例如，<code>Foo&lt;Bar&gt; </code>与 <code>Foo&lt;Bar?&gt;</code> 的实例都会被擦除为 <code>Foo&lt;*&gt;</code>，这点和java一样</p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><ul>
<li>对象声明</li>
</ul>
<p><code>对象声明</code>，总是在<code>object</code>关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="comment">// ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象声明的初始化过程是线程安全的。</p>
<p>如需引用该对象，我们直接使用其名称即可：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataProviderManager.registerDataProvider(……)</span><br><span class="line">DataProviderManager.registerDataProvider(……)</span><br></pre></td></tr></table></figure>

<p>注意：对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中。</p>
<ul>
<li>伴生对象</li>
</ul>
<p>类内部的对象声明可以用 companion 关键字标记：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Factory &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">()</span></span>: MyClass = MyClass()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该伴生对象的成员可通过只使用类名作为限定符来调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = MyClass.create()</span><br></pre></td></tr></table></figure>

<p>可以省略伴生对象的名称，在这种情况下将使用名称 Companion：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> x = MyClass.Companion</span><br></pre></td></tr></table></figure>

<p>其自身所用的类的名称（不是另一个名称的限定符）可用作对该类的伴生对象 （无论是否命名）的引用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Named &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">val</span> x = MyClass1</span><br><span class="line">​</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">val</span> y = MyClass2</span><br></pre></td></tr></table></figure>

<p>请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口：</p>
<pre><code class="kotlin">interface Factory&lt;T&gt; &#123;
    fun create(): T
&#125;
​
class MyClass &#123;
    companion object : Factory&lt;MyClass&gt; &#123;
        override fun create(): MyClass = MyClass()
    &#125;
&#125;

val f: Factory&lt;MyClass&gt; = MyClass

​```

当然，在 JVM 平台，如果使用 @JvmStatic 注解，你可以将伴生对象的成员生成为真正的静态方法和字段。更详细信息请参见Java 互操作性一节 。

* 对象表达式和对象声明之间的语义差异

对象表达式和对象声明之间有一个重要的语义差别：
- 对象表达式是在使用他们的地方立即执行（及初始化）的；
- 对象声明是在第一次被访问到时延迟初始化的；
— 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配。

</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/19/Kotlins%E5%88%9D%E5%AD%A6%E8%AE%B0%E5%BD%95/" data-id="ckqm6kpla0018xxr5a4be57jj" data-title="Kotlins初学记录" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-实习开发随记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/11/19/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2018-11-19T01:51:58.000Z" itemprop="datePublished">2018-11-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/11/19/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/">字节跳动实习开发随记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="2018-11-18"><a href="#2018-11-18" class="headerlink" title="2018/11/18"></a>2018/11/18</h3><h4 id="Android中visibility属性VISIBLE、INVISIBLE、GONE的区别"><a href="#Android中visibility属性VISIBLE、INVISIBLE、GONE的区别" class="headerlink" title="Android中visibility属性VISIBLE、INVISIBLE、GONE的区别"></a>Android中visibility属性VISIBLE、INVISIBLE、GONE的区别</h4><ul>
<li>可见（visible)</li>
</ul>
<p>XML文件：android:visibility=”visible”<br>Java代码：view.setVisibility(View.VISIBLE);</p>
<ul>
<li>不可见（invisible）</li>
</ul>
<p>XML文件：android:visibility=”invisible”<br>Java代码：view.setVisibility(View.INVISIBLE);</p>
<ul>
<li>隐藏（GONE）</li>
</ul>
<p>XML文件：android:visibility=”gone”<br>Java代码：view.setVisibility(View.GONE);</p>
<p>INVISIBLE 和 GONE 的主要区别是：<br>当控件 visibility 属性为 INVISIBLE 时，界面保留了 view 控件所占有的空间；<br>而控件属性为 GONE 时，界面则不保留 view 控件所占有的空间。</p>
<h4 id="Java基本数据类型的装箱与拆箱"><a href="#Java基本数据类型的装箱与拆箱" class="headerlink" title="Java基本数据类型的装箱与拆箱"></a>Java基本数据类型的装箱与拆箱</h4><p>这里拿int 和 Integer 作说明：<br>装箱过程是通过调用Integer的valueOf方法实现的，而拆箱过程是通过调用Integer的 intValue方法实现的；</p>
<p>Integer i = new Integer(xxx) 和 Integer i = xxx;这两种方式的区别：<br>最主要的区别是第一种方式不会处罚自动装箱的过程；</p>
<h3 id="2018-11-20"><a href="#2018-11-20" class="headerlink" title="2018/11/20"></a>2018/11/20</h3><p>Android SQlite 操作<br>sql命令</p>
<p>Kotlin还要继续学啊</p>
<h3 id="2018-11-24"><a href="#2018-11-24" class="headerlink" title="2018/11/24"></a>2018/11/24</h3><p>Android中广播的使用<br>使用广播检测网络变化</p>
<h3 id="2018-11-26"><a href="#2018-11-26" class="headerlink" title="2018/11/26"></a>2018/11/26</h3><p>git reset 三种用法总结</p>
<ul>
<li>git reset (–-mixed) HEAD~1<br>回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也不受影响) </li>
<li>git reset –-soft HEAD~1<br>回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响) </li>
<li>git reset –-hard HEAD~1<br>回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</li>
</ul>
<p><code>--mixed</code> 和 <code>--soft</code>的区别在于<code>--mixed</code>相当于做了一次<code>git add</code> + <code>git commit</code>的逆操作;而<code>--soft</code>相当于做了一次<code>git commit</code>的拟操作<br><code>–-hard</code>会替换掉本地的文件；</p>
<h3 id="2018-11-28"><a href="#2018-11-28" class="headerlink" title="2018/11/28"></a>2018/11/28</h3><p>Kotlin静态属性以及静态方法理解与使用</p>
<h3 id="2018-11-29"><a href="#2018-11-29" class="headerlink" title="2018/11/29"></a>2018/11/29</h3><p>Android Studio快捷键总结<br>Rxjava学习</p>
<h3 id="2018-11-30"><a href="#2018-11-30" class="headerlink" title="2018/11/30"></a>2018/11/30</h3><p>okhttp 给提交的任务添加优先级<br>okhttp不支持给任务添加优先级，当我们有这个需求的时候，除了改okhttp的源码之外，可以考虑下面的思路</p>
<p>首先我们知道提交的到okhttp中执行的任务是不具备优先级的，所以我们可以自己定义一个具备优先级的任务把本来的任务包装起来，就好像想让几岁大的小孩排队就非常困难，但是如果有大人把小孩抱着，大人知道排队吧，这样间接达到的效果就是小孩排队了。这样外面的壳就具备优先级了，就可以在优先级队里里面排队了。</p>
<p>然后定义一个线程池，并且这个线程池的等待队列使用具有优先级的队列，优先级的逻辑根据自己的需要写，然后用这个线程池来代替okhttp本来的线程池</p>
<h3 id="2018-12-1"><a href="#2018-12-1" class="headerlink" title="2018/12/1"></a>2018/12/1</h3><p>升级gradle版本的方法 </p>
<h4 id="mac下java多版本控制"><a href="#mac下java多版本控制" class="headerlink" title="mac下java多版本控制"></a>mac下java多版本控制</h4><ul>
<li>查看java安装路径：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br></pre></td></tr></table></figure>
注意：输入命令参数区分大小写(-v是不对的，必须是-V)</li>
</ul>
<p><img src="http://dengw.xyz/20181201153407.png"></p>
<p>如图：会显示已经安装的不同版本的JDK以及默认使用的JDK版本</p>
<ul>
<li>切换默认使用的JDK版本<br>通过修改环境变量文件中的设置可以达到切换JDk版本的效果，如果使用的是默认的终端的话，则在<code>~/.bash_profile</code> 文件中修改用户级环境变量，修改后执行<code>source ~/.bash_profile</code>使刚才的配置生效。</li>
</ul>
<p>这里需要注意的是，当mac上安装了zsh后，修改环境变量就需要在<code>~/.zshrc</code>文件中修改，修改后执行命令<code>source ~/.zshrc</code>使刚才的修改生效。</p>
<p>像上面这样打开对应的配置文件，添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设置 JDK 8  </span><br><span class="line">export JAVA_8_HOME=`/usr/libexec/java_home -v1.8`  </span><br><span class="line"># 设置 JDK 11  </span><br><span class="line">export JAVA_11_HOME=`/usr/libexec/java_home -v11`  </span><br><span class="line">  </span><br><span class="line">#默认JDK 8  </span><br><span class="line">export JAVA_HOME=$JAVA_8_HOME  </span><br><span class="line">  </span><br><span class="line">#alias命令动态切换JDK版本    </span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br><span class="line">alias jdk11=&quot;export JAVA_HOME=$JAVA_11_HOME&quot; </span><br></pre></td></tr></table></figure>
<p>我添加了jdk8和jdk11，按照需要添加对应的JDK版本。</p>
<p>生效之后，当你需要切换jdk版本，比如当我需要切换到 jdk8 的之后只需要在命令行里面输入 <code>jdk8</code> 就可以切换成功了,<code>jdk11</code>同理。</p>
<h3 id="2018-12-5"><a href="#2018-12-5" class="headerlink" title="2018/12/5"></a>2018/12/5</h3><h4 id="tinker"><a href="#tinker" class="headerlink" title="tinker"></a>tinker</h4><h3 id="2018-12-6"><a href="#2018-12-6" class="headerlink" title="2018/12/6"></a>2018/12/6</h3><h4 id="位运算总结"><a href="#位运算总结" class="headerlink" title="位运算总结"></a>位运算总结</h4><ul>
<li>&amp; </li>
</ul>
<p>按位与，如果两个相应的二进制位都为1，则该位的结果值为1，否则为0</p>
<ul>
<li>| </li>
</ul>
<p>按位或，两个相应的二进制位中只要有一个为1，该位的结果值为1</p>
<ul>
<li>^ </li>
</ul>
<p>按位异或，若参加运算的两个二进制位值相同则为0，否则为1</p>
<ul>
<li>~ </li>
</ul>
<p>取反，用来对一个二进制数按位取反，即将0变1，将1变0</p>
<ul>
<li>&lt;&lt; </li>
</ul>
<p>左移，用来将一个数的各二进制位全部左移N位，右补0</p>
<ul>
<li><blockquote>
<blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<p>右移，将一个数的各二进制位右移N位，移到右端的低位被舍弃，对于无符号数， 高位补0</p>
<h3 id="2018-12-9"><a href="#2018-12-9" class="headerlink" title="2018/12/9"></a>2018/12/9</h3><h4 id="Preference的使用"><a href="#Preference的使用" class="headerlink" title="Preference的使用"></a>Preference的使用</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/land_litao/article/details/23998579">隐藏PreferenceCategory和Preference的方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/valenhua/archive/2017/10/03/7624640.html">Android Preference 设置偏好全攻略</a></p>
<h3 id="2018-12-13"><a href="#2018-12-13" class="headerlink" title="2018/12/13"></a>2018/12/13</h3><h4 id="使用java代码获取apk的md5值"><a href="#使用java代码获取apk的md5值" class="headerlink" title="使用java代码获取apk的md5值"></a>使用java代码获取apk的md5值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取apk的md5值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path apk的路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMD5FromApk</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    BigInteger bi = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        MessageDigest md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        File f = <span class="keyword">new</span> File(path);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            md.update(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">byte</span>[] b = md.digest();</span><br><span class="line">        bi = <span class="keyword">new</span> BigInteger(<span class="number">1</span>, b);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bi.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用java代码获取apk的签名信息"><a href="#使用java代码获取apk的签名信息" class="headerlink" title="使用java代码获取apk的签名信息"></a>使用java代码获取apk的签名信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从APK中读取签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apkPath apk路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSignaturesFromApk</span><span class="params">(String apkPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = getSignatureBytes(apkPath);</span><br><span class="line">        <span class="keyword">return</span> hexDigest(bytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hexDigest</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    MessageDigest md5;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] md5Bytes = md5.digest(bytes);</span><br><span class="line">    StringBuffer hexValue = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; md5Bytes.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = ((<span class="keyword">int</span>) md5Bytes[i]) &amp; <span class="number">0xff</span>;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; <span class="number">16</span>)</span><br><span class="line">            hexValue.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        hexValue.append(Integer.toHexString(val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hexValue.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从APK中读取签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apkPath apk路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] getSignatureBytes(String apkPath) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    JarFile jarFile = <span class="keyword">new</span> JarFile(apkPath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JarEntry je = jarFile.getJarEntry(<span class="string">&quot;AndroidManifest.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] readBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">        Certificate[] certs = loadCertificates(jarFile, je, readBuffer);</span><br><span class="line">        <span class="keyword">if</span> (certs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Certificate c : certs) &#123;</span><br><span class="line">                <span class="keyword">return</span> c.getEncoded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> jarFile</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> je</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> readBuffer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Certificate[] loadCertificates(JarFile jarFile, JarEntry je, <span class="keyword">byte</span>[] readBuffer) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream is = jarFile.getInputStream(je);</span><br><span class="line">        <span class="keyword">while</span> (is.read(readBuffer, <span class="number">0</span>, readBuffer.length) != -<span class="number">1</span>) &#123;&#125;</span><br><span class="line">        is.close();</span><br><span class="line">        <span class="keyword">return</span> je != <span class="keyword">null</span> ? je.getCertificates() : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取当前应用的versionCode"><a href="#获取当前应用的versionCode" class="headerlink" title="获取当前应用的versionCode"></a>获取当前应用的versionCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前应用的versionCode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAppVersionCode</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageManager pm = context.getPackageManager();</span><br><span class="line">        PackageInfo pi = pm.getPackageInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pi == <span class="keyword">null</span> ? -<span class="number">1</span> : pi.versionCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">//e.printStackTrace();</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="获取apk的versionCode"><a href="#获取apk的versionCode" class="headerlink" title="获取apk的versionCode"></a>获取apk的versionCode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取apk的versionCode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context  context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filePath apk file path</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getApkVersionCode</span><span class="params">(Context context, <span class="keyword">final</span> String filePath)</span> </span>&#123;</span><br><span class="line">    PackageManager packageManager = context.getPackageManager();</span><br><span class="line">    PackageInfo packageInfo = packageManager.getPackageArchiveInfo(filePath, PackageManager.GET_ACTIVITIES);</span><br><span class="line">    <span class="keyword">return</span> packageInfo.versionCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="OKHttp的学习"><a href="#OKHttp的学习" class="headerlink" title="OKHttp的学习"></a>OKHttp的学习</h4><h3 id="2018-12-15"><a href="#2018-12-15" class="headerlink" title="2018/12/15"></a>2018/12/15</h3><h4 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h4><h3 id="2018-12-16"><a href="#2018-12-16" class="headerlink" title="2018/12/16"></a>2018/12/16</h3><h4 id="实现只有当主线程消息队列空闲时才处理耗时事件"><a href="#实现只有当主线程消息队列空闲时才处理耗时事件" class="headerlink" title="实现只有当主线程消息队列空闲时才处理耗时事件"></a>实现只有当主线程消息队列空闲时才处理耗时事件</h4><p>达到的效果：<strong>在UI显示完成后，再进行耗时操作</strong></p>
<p>官方源码解释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface for discovering when a thread is going to block</span></span><br><span class="line"><span class="comment"> * waiting for more messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when the message queue has run out of messages and will now</span></span><br><span class="line"><span class="comment">     * wait for more.  Return true to keep your idle handler active, false</span></span><br><span class="line"><span class="comment">     * to have it removed.  This may be called if there are still messages</span></span><br><span class="line"><span class="comment">     * pending in the queue, but they are all scheduled to be dispatched</span></span><br><span class="line"><span class="comment">     * after the current time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样假如我们想要定义一个只有当主线程消息队列为空的时候才处理的事件的话，就可以继承<code>IdleHandler</code>然后重写<code>queueIdle()</code>方法，用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.IdleHandler idleHandler = <span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 耗时操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Looper.myQueue().addIdleHandler(idleHandler);</span><br></pre></td></tr></table></figure>

<p>对<code>queueIdle()</code>方法返回值的一些补充：</p>
<ul>
<li>返回 true: 保持此 idleHandler 一直在消息队列中，这样就会一直被回调；</li>
<li>返回false: 代表在这个IdleHandler被回调一次后就会从消息队列中移除；</li>
</ul>
<h3 id="2018-12-17"><a href="#2018-12-17" class="headerlink" title="2018/12/17"></a>2018/12/17</h3><h4 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/19/%E5%AE%9E%E4%B9%A0%E5%BC%80%E5%8F%91%E9%9A%8F%E8%AE%B0/" data-id="ckqm6kpmc0040xxr5hufv7ge6" data-title="字节跳动实习开发随记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0/" rel="tag">实习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在Android中获取存储空间方法总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/11/07/%E5%9C%A8Android%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-11-07T11:46:25.000Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/11/07/%E5%9C%A8Android%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">在Android中获取存储空间方法总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在最近的项目中需要获取android设备的存储空间大小，完成了就好好总结一下，以及遇到的一些坑。</p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>首先需要弄懂几个很混淆的概念，内存、内部存储，外部存储。</p>
<ul>
<li>内存，英文中称作memory；</li>
<li>内部存储，英文中称作InternalStorage；</li>
<li>外部存储，英文中称作ExternalStorage；</li>
</ul>
<p>就贴一篇博客了，讲的非常清楚，还说明了在不同 android 版本中有什么差别;<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010937230/article/details/73303034/">彻底搞懂Android文件存储—内部存储，外部存储以及各种存储路径</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/07/%E5%9C%A8Android%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" data-id="ckqm6kpm9003sxxr5g3xtaucb" data-title="在Android中获取存储空间方法总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MAC环境下apk反编译方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/11/06/MAC%E7%8E%AF%E5%A2%83%E4%B8%8Bapk%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-11-06T12:19:02.000Z" itemprop="datePublished">2018-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/11/06/MAC%E7%8E%AF%E5%A2%83%E4%B8%8Bapk%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/">MAC环境下apk反编译方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="工具下载"><a href="#工具下载" class="headerlink" title="工具下载"></a>工具下载</h2><ul>
<li>apktool:  <a target="_blank" rel="noopener" href="https://bitbucket.org/iBotPeaches/apktool/downloads/">apktool下载链接</a><br>下载最新版本的jar包即可；</li>
<li>dex2jar: <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/dex2jar/files/">dex2jar下载链接</a><br>下载最新版本的zip包即可；</li>
<li>jd-gui: <a target="_blank" rel="noopener" href="http://jd.benow.ca/">JD-GUI下载链接</a><br>下载最新的Releases版本for OX;</li>
</ul>
<h2 id="反编译过程与排坑"><a href="#反编译过程与排坑" class="headerlink" title="反编译过程与排坑"></a>反编译过程与排坑</h2><p>首先可以将上面下载的三个包放到同一个文件夹里面（非必须，只是方便操作）；然后解压<code>dex2jar</code>以及<code>jd-gui</code>，然后便将你需要反编译的apk文件放入上面该文件夹中，这里我要反编译的apk名字为<code>BTcar.apk</code>，下面输入命令的时候对应输入你的apk文件名；</p>
<p><img src="http://dengw.xyz/20181107105318.png"></p>
<h3 id="apktool反编译apk得到图片、XML配置、语言资源等文件"><a href="#apktool反编译apk得到图片、XML配置、语言资源等文件" class="headerlink" title="apktool反编译apk得到图片、XML配置、语言资源等文件"></a>apktool反编译apk得到图片、XML配置、语言资源等文件</h3><p>打开命令行跳转到该目录下，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar apktool_2.3.4.jar d -f BTcar.apk -o BTCar</span><br></pre></td></tr></table></figure>
<p>其中， <code>apktool_2.3.4.jar</code>为我使用的<code>apktool</code>的apk包名，<code>BTCar</code>为生成的文件夹名，输入命令后的结果如图：<br><img src="http://dengw.xyz/20181107110350.png"></p>
<p>结果：<br><img src="http://dengw.xyz/20181107110549.png"></p>
<p>这个BTCar文件夹为反编译生成的各种资源文件；</p>
<h3 id="dex2jar反编译apk得到Java源代码"><a href="#dex2jar反编译apk得到Java源代码" class="headerlink" title="dex2jar反编译apk得到Java源代码"></a>dex2jar反编译apk得到Java源代码</h3><p>将要反编译的APK后缀名改为.zip，并解压，得到classes.dex文件；这里有一个坑就是使用系统自带的解压工具解压不能够成功，会生成如下的文件；</p>
<p><img src="http://dengw.xyz/20181107110731.png"><br><img src="http://dengw.xyz/20181107110811.png"></p>
<p>一种解决方法就是在 appStore 上下载一个叫做<code>The Archiver</code>的解压工具，然后就可以成功解压，生成<code>BTCar-1</code>文件夹：<br><img src="http://dengw.xyz/20181107110825.png"></p>
<p>打开该文件夹就可以看到需要的<code>class.dex</code>文件：<br><img src="http://dengw.xyz/20181107110854.png"></p>
<p>将获取到的<code>classes.dex</code>放到之前解压出来的工具<code>dex2jar</code>文件夹内，然后在<code>dex2jar</code>文件夹内打开终端输入命令<code>./d2j-dex2jar.sh classes.dex</code>，这个地方的一个坑就是可能会出现<code>Permission Denied</code>异常：<br><img src="http://dengw.xyz/20181107110912.png"></p>
<p>关于如何在mac中修改文件权限可以参考这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/x1876631/article/details/70162009/">mac 查看、修改文件权限的命令</a>，也可以直接使用下面的方法修改文件权限，一般报的哪个文件就修改对应文件权限即可，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zsh: permission denied: ./d2j-dex2jar.sh</span><br></pre></td></tr></table></figure>
<p>然后就在终端输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 d2j-dex2jar.sh</span><br></pre></td></tr></table></figure>
<p>所有文件的权限修改成功过后再执行<code>./d2j-dex2jar.sh classes.dex</code>，生成<code>classes-dex2jar.jar</code>:<br><img src="http://dengw.xyz/20181107110936.png"></p>
<h3 id="使用jd-gui工具查看java代码"><a href="#使用jd-gui工具查看java代码" class="headerlink" title="使用jd-gui工具查看java代码"></a>使用jd-gui工具查看java代码</h3><p>在得到classes-dex2jar.jar文件之后，就可以使用jd-gui工具查看源码了。这里另外一个坑就是如果你的Java版本大于Java 8的话是运行不了jd-gui，解决方法可以参考这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/YoungStunner/article/details/78699864">Mac上的jd-gui不能使用（打开）</a>，上面有很详细的解决方法。解决后就可以使用jd-gui工具查看java源代码了。<br><img src="http://dengw.xyz/20181107110955.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/11/06/MAC%E7%8E%AF%E5%A2%83%E4%B8%8Bapk%E5%8F%8D%E7%BC%96%E8%AF%91%E6%96%B9%E6%B3%95/" data-id="ckqm6kple001ixxr5aydkgw2e" data-title="MAC环境下apk反编译方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" rel="tag">apk反编译</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Android开发2018年互联网秋招总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/30/Android%E5%BC%80%E5%8F%912018%E5%B9%B4%E4%BA%92%E8%81%94%E7%BD%91%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-09-30T03:01:06.000Z" itemprop="datePublished">2018-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/30/Android%E5%BC%80%E5%8F%912018%E5%B9%B4%E4%BA%92%E8%81%94%E7%BD%91%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/">Android开发2018年互联网秋招总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>8月20号左右从美图离职参加秋招到今天9月30号，从8月20号参加阿里的一面到9月26号头条的三面，一个多月的互联网秋招对我来说差不多就结束了，现在来看，感受很深，失落过，焦虑过，挫败过，不过好在最后的结局让人满意，超过了秋招开始时候的预期目标，所以本文的基调还是轻松的，主要讲讲自己对秋招的总结。</p>
<h3 id="面试情况"><a href="#面试情况" class="headerlink" title="面试情况"></a>面试情况</h3><p>公司我投的倒是挺多的，除了阿里和金山wps都是正式批，有十多二十个吧，都通过了简历筛选，这儿要感谢我鸭大，以及高中的时候努力的自己，下面列一下详细的进度情况：</p>
<ul>
<li><strong>阿里</strong>：二面挂，阿里真的挺可惜的，实习离职第二天就收到面试电话了，奈何时间紧准备不充分；</li>
<li><strong>金山wps</strong>：hr面后无消息，当时说是一周内给消息的，然后到现在快一个月了也还没消息，可能是要价太高，排名又低，被淘汰了；</li>
<li><strong>虎牙</strong>：二面挂；虎牙其实是我最开始秋招的时候给自己定的目标之一，在广州，技术氛围和待遇上也挺满意的，可惜二面没过，当时也非常失落。不过虎牙面试过程中也让自己明白当时还存在的一些不足，数据结构和计算机网络的部分，这对后来头条的面试帮助非常大。这儿我的一点感触就是对于大多数人来说秋招是一个持久战，一次失败对整个秋招的影响不会很大，但是如果你能够从这次失败中发现自己的问题，那对整个秋招的帮助就非常大了，所以对于失败要善于总结，发现了问题一定要及时解决和补救，眼光要长远一点，不要太纠结一次的得失。</li>
<li><strong>爱奇艺</strong>：笔试后无消息，好像同批次笔试的都没有收到消息；</li>
<li><strong>bigo</strong>：一面挂；</li>
<li><strong>超有爱</strong>：笔试挂，因为最开始很想回成都去，百词斩真的挺想去的，但是要求也真的很高，1一个小时3道笔试题我通过了2.5道都没有面试机会，挺遗憾的。</li>
<li><strong>京东</strong>：笔试挂；</li>
<li><strong>欢聚时代</strong>：一面挂，这个我真的很想多说几句，一面面试完面试官亲口给我说：我这儿你过了，今天没有复试安排，复试会有邮件通知的，然而等了一周收到不适合的邮件2333，到这儿投的yy系的三个公司全部扑街；</li>
<li><strong>CVTE</strong>：hr面后无消息；</li>
<li><strong>触宝</strong>：拿到offer，到手的第一个offer，虽然说现在来看应该不会去了，不过当时拿到offer的时候真的非常开心，后面面试心态也更轻松，没有那么焦虑，真的非常感谢触宝对我的认可；</li>
<li><strong>网易</strong>：一面挂；网易感觉很奇怪，笔试的时候只做了半个小时就放弃直接交卷了然而都还给了我面试机会，面试的时候感觉表现很好却没有过2333；</li>
<li><strong>招银网络</strong>：时间冲突放弃了笔试；</li>
<li><strong>微众</strong>：一面挂；聊的挺好的，不过我感觉自己挺傻的，前面面试官先问我最近在面哪些公司啊，然后我说百度三面了（我这样原本是打算拔高自己的形象的，毕竟百度能够面到三面还是挺不容易的，哪知道给自己挖了一个坑），最后面试官就问了我一个问题：如果我现在直接给你发offer你会来微众吗？然后我诚实地说了如果百度三面过了应该会去百度，毕竟bat嘛，接着就和面试官讨论起平台，愉快地结束面试。然后回来就没收到任何消息了，事后想想真的觉得自己傻，欠缺面试经验吧；</li>
<li><strong>百度</strong>：拿到offer；完完全全的三轮技术面，前两轮表现得挺好，第三轮答得不好以为过不了，感谢百度给了我一个学习的机会；</li>
<li><strong>vivo</strong>：拿到offer，感觉vivo的流程是最快的，下午六点面试，一轮技术一轮hr面，晚上就收到offer了，</li>
<li><strong>头条</strong>：已确定拿到实习offer，正式offer已经在流程中，说到头条觉得自己真的挺幸运，最开始走的校招流程，做了一次笔试，5道题应该ac了3.5道左右，奈何其他人太强了，笔试没过，然后觉得自己太菜打算放弃秋招了（投简历的时候手里还一个offer都没有），先找个实习的offer然后准备明年春招，然后就投了头条的实习岗位。可能是因为现在投实习岗的不多所以就没有笔试，直接进入面试，3论技术面，运气又比较好，每一轮只有一道手撕算法题，一道是双栈实现队列，一道是二叉树的层次遍历，最后一道挺难的，求一个矩阵中最大子矩阵的和（一道动态规划的题，和求一个数组的最大子数组的最大和挺像的，不过要求了时间复杂度为O(n^3)，所以要考虑降维），都做出来了。第三面的时候有一个场景题，让设计一个登陆模块，其中一个要求是实现第二次登陆免登陆。我最开始给出的方案是使用 SharedPerfences 将第一次登陆输入的账号和密码保存到本地，下次登陆的时候直接去读取然后自动登陆，面试官说把安全性怎么办，然后我说使用一些加密算法将密码进行加密？面试还是不满意，问我还有没有其他的方法。然后仔细想了一下，突然想到上次虎牙面试的时候面试官问到的 cookie 的作用原理，当时没有回答上，下来很仔细地学习了一下，然后发现 cookie 可以适用于这个场景，说完面试官还算满意。另外一点是面试官还问了我关于B+树的一些问题，给了我一个场景让我画出分裂图，这儿又要感谢虎牙的面试了，因为一直觉得 B+ 树在数据库的索引部分中用的比较多，而移动开发一般不会问数据库的问题，但是之前虎牙的面试官把B+树当作数据结构的题来问了，虎牙面试完又很仔细地学习了一下B+树，所以准备真的很重要。三面后半个小时就接到hr的电话了，更让我惊喜的是说觉得我面试过程中表现得还行，能够帮我申请正式offer，现在已经在流程中了；</li>
<li><strong>腾讯</strong>：一面挂；</li>
<li><strong>酷狗</strong>：现在还没开始应该会直接放弃了；</li>
<li><strong>小米</strong>：通知去武汉面试太远直接放弃了；</li>
<li><strong>新浪</strong>：通知去成都面试，国庆正好要回老家有时间的话就去一下吧；</li>
<li><strong>华为</strong>：通知去面试了，到时候人在广州就去一下吧；</li>
<li><strong>oppo</strong>；广州场还没开始，到时候去试一下吧，因为有成都的岗位，观望一下；</li>
</ul>
<h3 id="秋招心得"><a href="#秋招心得" class="headerlink" title="秋招心得"></a>秋招心得</h3><p>从上面可以看到，我投了很多公司，也挂了非常多，前半段时间基本上面一个挂一个，很菜，信心也被打击过。不过后来能收获一个比较完美的结局，除开运气之外我觉得还是有一些个人原因吧，希望对大家有所帮助：</p>
<ul>
<li>个人心态</li>
</ul>
<p>心态真的很重要，心态不好的话整天忧心忡忡的，晚上睡不好觉，白天复习效果不好。我整个秋招基本上很少或者基本上没有失眠过，前半段时间面一个挂一个也没有失眠，我现在记得的一次失眠是收到百度录用短信通知第二天去面试那晚，激动地睡不着。也不要抱怨，不要太在意得失，笔试面试没过自身肯定是有原因的，你要做的就是好好弥补，发现问题就能进步了嘛，何必忧心忡忡呢是吧。</p>
<ul>
<li>基础扎实，技术要有深度：</li>
</ul>
<p>我学习android的时间不长，到现在也就8、9个月，还是本科生，所以相比那些学了两、三年的人来说肯定是有劣势的，像什么插件化、热修复、RN、Flutter这些根本就没有碰过。在我离职前我半开玩笑地问我的leader，我说我这些东西都不会是不是找不到工作了啊，他说，其实你不用太纠结，这些东西最多是一些加分项，而不是必须项，很多大厂更看重的还是基础。这些话对我很受益，如果当时没问他的话我肯定会把花时间去学习这些东西，而不是把重心放在基础知识的复习上，这样又学不深，基础有没有得到巩固，反而得不偿失。<br>对于基础知识，像操作系统，计算机网络，数据结构与算法、java相关的，android相关的，一定要做到非常熟悉，一些加分项不会只是不会加分，但是一些必须项不会的话肯定是会减分的，举个例子，Android 中 Activity的生命周期问题，你问每个学习 Android 的肯定都知道一些，我面试的时候也被问过很多次，变着花样来问你，可以像下面这样问：</p>
<blockquote>
<p>按下 home 键 activity的生命周期变化；<br>按下 back 键 activity的生命周期变化；<br>息屏时 activity的生命周期变化；<br>启动一个透明 Activity 时当前活动的生命周期变化；<br>旋转屏幕时未设置 configureChanges 参数时 activity 的生命周期变化；<br>旋转屏幕时设置了 configureChanges 参数时 activity 的生命周期变化；</p>
</blockquote>
<p>上面列的一些问题有一些共性，情景很多但是本质差别不大，面试的时候如果你之前都遇到过那还好说，没遇到过那就只有靠自己分析了。</p>
<p>说完基础，另外一点就是技术深度了，个人感觉对于应届生来说主要体现在源码的掌握程度上，虽然我现在学习的Android的时间不是很长，但是对于一些接触频率很高源码还是有掌握的，比如常见容器的源码我有一次面试就是叫我写一下 HashMap 添加元素源码，感觉如果平时没看过的话即使知道添加元素的过程也很难下笔。再者就是 Android 中 Activity 的启动过程的源码、View绘制与添加的源码以及一些经常使用第三方框架，Butterknife、EventBus、Rxjava、okHttp、Retrofit也要看一看，如果直接看源代码感觉很困难可以结合一些博客看一下关键性代码。</p>
<p>最后就是你写在简历上的东西自己一定要非常清楚，不要为了简历好看而给自己挖坑，到时候就得不偿失了。项目细节面试官一般都会深挖的，不过可能是面试官看我的项目太菜了，只是很简单地问了一下。</p>
<ul>
<li>学会总结：</li>
</ul>
<p>是要在一次面试完之后根据这次的面试情况及时总结，一次面试可以暴露出很多问题的，一次面试也是很好的反馈，这个在上面具体的面试情况里也说了这一点，我个人觉得这一点真的挺重要的，面试也是学习的过程，如果能够把一个个问题都解决了，那最后就是学到了嘛。发现问题，解决问题。</p>
<ul>
<li>表达清晰，逻辑清楚：</li>
</ul>
<p>这一点可以看作是个人软实力的一种体现吧，其实我在平时生活中的表达能力真算不上好，普通话也不算特别标准，但是一到面试的时候，对于接下来自己要说总能够很好的组织，然后表达，最开始我都没注意到这点的，在百度二面的时候二十分钟就问完了，当面试官说我问的差不多了的时候，我都有点蒙，说这么快？因为感觉百度二面二十多分钟就结束了感觉是要凉了啊，然后面试官说我一共问了你十五个问题，你回答的时候逻辑很清晰，说的很完整，表达的也很清楚，回答的挺好的，我这儿会把面试结果反馈上去，如果通过的话会给你发通知的，晚上就收到二面通过准备三面的通知。从这儿我觉得能够好好地表达确实会为面试加分不少。这一点其实平时也是可以准备的，对于一些很常规的问题，比如让你抽象类和接口的区别，这个问题应该面试java或者Android的都会遇到吧，我都是会像下面这样回答的，说的很全面，不容易遗漏，不过你回答得时候不要表现得有很明显背的痕迹，这个需要注意一下；</p>
<blockquote>
<p>首先从个体层面来说：<br>抽象类不能被实例化，而接口可以；<br>抽象类可以继承类或者实现接口，而接口只能够实现接口</p>
</blockquote>
<blockquote>
<p>从成员变量的角度来说：<br>接口只能够具有静态常量，而抽象类则没有限制，可以具有和普通类一样的成员变量；</p>
</blockquote>
<blockquote>
<p>从类函数来说：<br>抽象类可以有类构造器，接口没有；<br>抽象类可以有main方法，接口没有；<br>抽象类中可以具有抽象方法和非抽象方法，接口中只有抽象方法；<br>抽象类中的抽象方法可以除private之外的任意方法修饰符，接口中只可以为public和默认（和public一致）的</p>
</blockquote>
<blockquote>
<p>从子类的角度来说来说：<br>子类只能继承一个抽象类，但可以实现多个接口；</p>
</blockquote>
<blockquote>
<p>从访问速度上来说（寻找成员方法）：<br>抽象类更快，接口更慢；（主要是从方法表的角度进行考虑的）</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/30/Android%E5%BC%80%E5%8F%912018%E5%B9%B4%E4%BA%92%E8%81%94%E7%BD%91%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" data-id="ckqm6kpky000gxxr58spycodd" data-title="Android开发2018年互联网秋招总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-常用的git命令清单" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/24/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/" class="article-date">
  <time class="dt-published" datetime="2018-09-24T09:27:12.000Z" itemprop="datePublished">2018-09-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/24/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/">常用的git命令清单</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h3><p>在当前目录新建一个Git代码库</p>
<ul>
<li>git init</li>
</ul>
<p>新建一个目录，将其初始化为Git代码库</p>
<ul>
<li>git init [project-name]</li>
</ul>
<p>下载一个项目和它的整个代码历史</p>
<ul>
<li>git clone [url]</li>
</ul>
<h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<p>显示当前的Git配置</p>
<ul>
<li>git config –list</li>
</ul>
<p>编辑Git配置文件</p>
<ul>
<li>git config -e [–global]</li>
</ul>
<p>设置提交代码时的用户信息</p>
<ul>
<li>git config [–global] user.name “[name]”</li>
<li>git config [–global] user.email “[email address]”</li>
</ul>
<h3 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h3><p>添加指定文件到暂存区</p>
<ul>
<li>git add [file1] [file2] …</li>
</ul>
<p>添加指定目录到暂存区，包括子目录</p>
<ul>
<li>git add [dir]</li>
</ul>
<p>添加当前目录的所有文件到暂存区</p>
<ul>
<li>git add .</li>
</ul>
<p>删除工作区文件，并且将这次删除放入暂存区</p>
<ul>
<li>git rm [file1] [file2] …</li>
</ul>
<p>停止追踪指定文件，但该文件会保留在工作区</p>
<ul>
<li>git rm –cached [file]</li>
</ul>
<p>改名文件，并且将这个改名放入暂存区</p>
<ul>
<li>git mv [file-original] [file-renamed]</li>
</ul>
<h3 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h3><p>提交暂存区到仓库区</p>
<ul>
<li>git commit -m [message]</li>
</ul>
<p>提交暂存区的指定文件到仓库区</p>
<ul>
<li>git commit [file1] [file2] … -m [message]</li>
</ul>
<p>提交工作区自上次commit之后的变化，直接到仓库区</p>
<ul>
<li>git commit -a</li>
</ul>
<p>提交时显示所有diff信息</p>
<ul>
<li>git commit -v</li>
</ul>
<p>使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息</p>
<ul>
<li>git commit –amend -m [message]</li>
</ul>
<p>重做上一次commit，并包括指定文件的新变化</p>
<ul>
<li>git commit –amend …</li>
</ul>
<h3 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h3><p>列出所有本地分支</p>
<ul>
<li>git branch</li>
</ul>
<p>列出所有远程分支</p>
<ul>
<li>git branch -r</li>
</ul>
<p>列出所有本地分支和远程分支</p>
<ul>
<li>git branch -a</li>
</ul>
<p>新建一个分支，但依然停留在当前分支</p>
<ul>
<li>git branch [branch-name]</li>
</ul>
<p>新建一个分支，并切换到该分支</p>
<ul>
<li>git checkout -b [branch]</li>
</ul>
<p>新建一个分支，指向指定commit</p>
<ul>
<li>git branch [branch] [commit]</li>
</ul>
<p>新建一个分支，与指定的远程分支建立追踪关系</p>
<ul>
<li> git branch –track [branch] [remote-branch]</li>
</ul>
<p>切换到指定分支，并更新工作区</p>
<ul>
<li>git checkout [branch-name]</li>
</ul>
<p>建立追踪关系，在现有分支与指定的远程分支之间</p>
<ul>
<li>git branch –set-upstream [branch] [remote-branch]</li>
</ul>
<p>合并指定分支到当前分支</p>
<ul>
<li>git merge [branch]</li>
</ul>
<p>选择一个commit，合并进当前分支</p>
<ul>
<li>git cherry-pick [commit]</li>
</ul>
<p>删除分支</p>
<ul>
<li>git branch -d [branch-name]</li>
</ul>
<p>删除远程分支</p>
<ul>
<li><p>git push origin –delete</p>
</li>
<li><ul>
<li>git branch -dr</li>
</ul>
</li>
</ul>
<p>###六、标签</p>
<p>列出所有tag</p>
<ul>
<li> git tag</li>
</ul>
<p>新建一个tag在当前commit</p>
<ul>
<li>git tag [tag]</li>
</ul>
<p>新建一个tag在指定commit</p>
<ul>
<li>git tag [tag] [commit]</li>
</ul>
<p>查看tag信息</p>
<ul>
<li>git show [tag]</li>
</ul>
<p>提交指定tag</p>
<ul>
<li>git push [remote] [tag]</li>
</ul>
<p>提交所有tag</p>
<ul>
<li>git push [remote] –tags</li>
</ul>
<p>新建一个分支，指向某个tag</p>
<ul>
<li>git checkout -b [branch] [tag]</li>
</ul>
<h3 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h3><p>显示有变更的文件</p>
<ul>
<li>git status</li>
</ul>
<p>显示当前分支的版本历史</p>
<ul>
<li>git log</li>
</ul>
<p>显示commit历史，以及每次commit发生变更的文件</p>
<ul>
<li>git log –stat</li>
</ul>
<p>显示某个文件的版本历史，包括文件改名</p>
<ul>
<li><p>git log –follow [file]</p>
</li>
<li><p>git whatchanged [file]</p>
</li>
</ul>
<p>显示指定文件相关的每一次diff</p>
<ul>
<li>git log -p [file]</li>
</ul>
<p>显示指定文件是什么人在什么时间修改过</p>
<ul>
<li>git blame [file]</li>
</ul>
<p>显示暂存区和工作区的差异</p>
<ul>
<li>git diff</li>
</ul>
<p>显示暂存区和上一个commit的差异</p>
<ul>
<li>git diff –cached []</li>
</ul>
<p>显示工作区与当前分支最新commit之间的差异</p>
<ul>
<li>git diff HEAD</li>
</ul>
<p>显示两次提交之间的差异</p>
<ul>
<li>git diff [first-branch]…[second-branch]</li>
</ul>
<p>显示某次提交的元数据和内容变化</p>
<ul>
<li>git show [commit]</li>
</ul>
<p>显示某次提交发生变化的文件</p>
<ul>
<li>git show –name-only [commit]</li>
</ul>
<p>显示某次提交时，某个文件的内容</p>
<ul>
<li>git show [commit]:[filename]</li>
</ul>
<p>显示当前分支的最近几次提交</p>
<ul>
<li>git reflog</li>
</ul>
<h3 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h3><p>下载远程仓库的所有变动</p>
<ul>
<li>git fetch [remote]</li>
</ul>
<p>显示所有远程仓库</p>
<ul>
<li>git remote -v</li>
</ul>
<p>显示某个远程仓库的信息</p>
<ul>
<li>git remote show [remote]</li>
</ul>
<p>增加一个新的远程仓库，并命名</p>
<ul>
<li>git remote add [shortname] [url]</li>
</ul>
<p>取回远程仓库的变化，并与本地分支合并</p>
<ul>
<li>git pull [remote] [branch]</li>
</ul>
<p>上传本地指定分支到远程仓库</p>
<ul>
<li>git push [remote] [branch]</li>
</ul>
<p>强行推送当前分支到远程仓库，即使有冲突</p>
<ul>
<li>git push [remote] –force</li>
</ul>
<p>推送所有分支到远程仓库</p>
<ul>
<li>git push [remote] –all</li>
</ul>
<h3 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h3><p>恢复暂存区的指定文件到工作区</p>
<ul>
<li>git checkout [file]</li>
</ul>
<p>恢复某个commit的指定文件到工作区</p>
<ul>
<li>git checkout [commit] [file]</li>
</ul>
<p>恢复上一个commit的所有文件到工作区</p>
<ul>
<li>git checkout .</li>
</ul>
<p>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</p>
<ul>
<li>git reset [file]</li>
</ul>
<p>重置暂存区与工作区，与上一次commit保持一致</p>
<ul>
<li>git reset –hard</li>
</ul>
<p>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</p>
<ul>
<li>git reset [commit]</li>
</ul>
<p>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</p>
<ul>
<li>git reset –hard [commit]</li>
</ul>
<p>重置当前HEAD为指定commit，但保持暂存区和工作区不变</p>
<ul>
<li>git reset –keep [commit]</li>
</ul>
<p>新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支</p>
<ul>
<li>git revert [commit]</li>
</ul>
<h3 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h3><p>生成一个可供发布的压缩包</p>
<ul>
<li>git archive</li>
</ul>
<p>备份当前工作区的内容</p>
<ul>
<li>git stash</li>
</ul>
<p>从Git栈中读取最近一次保存的内容，恢复工作区的相关内容</p>
<ul>
<li>git stash pop</li>
</ul>
<p>显示Git栈内的所有备份</p>
<ul>
<li>git stash list</li>
</ul>
<p>清空Git栈</p>
<ul>
<li>git stash clear</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/24/%E5%B8%B8%E7%94%A8%E7%9A%84git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/" data-id="ckqm6kpmf0048xxr52t8lchjn" data-title="常用的git命令清单" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/" rel="tag">Github</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Android绘图之Paint和Canvas的使用方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/22/Android%E7%BB%98%E5%9B%BE%E4%B9%8BPaint%E5%92%8CCanvas%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-08-22T10:17:05.000Z" itemprop="datePublished">2018-08-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/22/Android%E7%BB%98%E5%9B%BE%E4%B9%8BPaint%E5%92%8CCanvas%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/">Android绘图之Paint和Canvas的使用方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在自定义 View 的时候经常会使用到 Paint 和 Canvas 进行绘图，这些类比较像一些工具类，主要集中在方法的理解与使用。下面是给出的一些常用方法，当然还有很多还有方法没有列出来，使用的时候可以直接查看源码查找相应的方法。</p>
<h3 id="Paint类"><a href="#Paint类" class="headerlink" title="Paint类"></a>Paint类</h3><h4 id="setStyle"><a href="#setStyle" class="headerlink" title="setStyle"></a>setStyle</h4><p>用于设置画笔的风格，可以指定是圆心还是实心，该方法在矩形，圆形有明显的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数style为画笔的风格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStyle</span><span class="params">(Paint.Style style)</span></span></span><br></pre></td></tr></table></figure>
<p>可选参数包括：</p>
<ul>
<li>Style.FILL: 实心</li>
<li>Style.FILL_AND_STROKE: 同时显示实心和空心</li>
<li>Style.STROKE: 空心</li>
</ul>
<h4 id="setStrokeCap"><a href="#setStrokeCap" class="headerlink" title="setStrokeCap"></a>setStrokeCap</h4><p> 用来控制我们的画笔在离开画板时候留下的最后一点图形，或者说叫做笔触风格 ，笔触就像我们现实世界中的笔，如果你用圆珠笔在纸上戳一点，那么这个点是个圆，它代表了笔的笔触形状，如果我们把一支铅笔笔尖削成方形的，那么画出来的线条会是一条弯曲的“矩形”，这就是笔触的意思。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrokeCap</span><span class="params">(Cap cap)</span></span></span><br></pre></td></tr></table></figure>
<p>参数可选列表：</p>
<ul>
<li>Cap.BUTT : 无笔触风格</li>
<li>Cap.ROUND ：圆形</li>
<li>Cap.SQUARE ： 方形</li>
</ul>
<h4 id="setStrokeJoin"><a href="#setStrokeJoin" class="headerlink" title="setStrokeJoin"></a>setStrokeJoin</h4><p>设置线段连接处样式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrokeJoin</span><span class="params">(Join join)</span></span></span><br></pre></td></tr></table></figure>
<p>可选值包括：</p>
<ul>
<li>Join.MITER（结合处为锐角）</li>
<li>Join.Round(结合处为圆弧)</li>
<li>Join.BEVEL(结合处为直线) </li>
</ul>
<h4 id="setTypeface"><a href="#setTypeface" class="headerlink" title="setTypeface"></a>setTypeface</h4><p>用于设置画笔的字体样式，可以使用系统自带的字段，也可以使用自定义的字体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typeface为字体样式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Typeface</span><span class="params">(Typeface typeface)</span></span></span><br></pre></td></tr></table></figure>

<p>一些可选值包括：</p>
<ul>
<li>Typeface.DEFAULT: 默认字体</li>
<li>Typeface.DEFAULT_BOLD: 加粗字体</li>
<li>Typeface.MONOSPACE: monospace字体</li>
<li>Typeface.SANS_SERIF: sans字体</li>
<li>Typeface.SERIF: serif字体</li>
</ul>
<h4 id="setColor"><a href="#setColor" class="headerlink" title="setColor"></a>setColor</h4><p>用于设置画笔的颜色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数color为颜色值，也可以使用Color类定义的颜色</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(<span class="keyword">int</span> color)</span></span></span><br></pre></td></tr></table></figure>

<p>下面是一些Color类定义的颜色：</p>
<ul>
<li>Color.BLACK:黑色</li>
<li>Color.BLUE:蓝色</li>
<li>Color.CYAN:青绿色</li>
<li>Color.DKGRAY:灰黑色</li>
<li>Color.YELLOW:黄色</li>
<li>Color.GRAY:灰色</li>
<li>Color.GREEN:绿色</li>
<li>Color.LTGRAY:浅绿色</li>
<li>Color.MAGENTA:红紫色</li>
<li>Color.TRANSPARENT:透明色</li>
</ul>
<h4 id="setAlpha"><a href="#setAlpha" class="headerlink" title="setAlpha"></a>setAlpha</h4><p>用于设置画笔的透明度，为透明度，其取值范围为0~255，数值越小越透明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="setPathEffect"><a href="#setPathEffect" class="headerlink" title="setPathEffect"></a>setPathEffect</h4><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/tianzhijiexian/p/4297783.html">详解Paint的setPathEffect(PathEffect effect)</a></p>
<h4 id="setStrokeWidth"><a href="#setStrokeWidth" class="headerlink" title="setStrokeWidth"></a>setStrokeWidth</h4><p>用于设置画笔的空心线宽，该方法在矩形，圆形，等图形上有明显的效果；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数width为线宽，浮点型数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrokeWidth</span><span class="params">(<span class="keyword">float</span> width)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="setARGB"><a href="#setARGB" class="headerlink" title="setARGB"></a>setARGB</h4><p>用于设置画笔的颜色和透明度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setARGB</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> r,<span class="keyword">int</span> g,<span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数a为透明度，范围0~255</li>
<li>参数r为红色的颜色值，范围0~255</li>
<li>参数g为绿色的颜色值，范围0~255</li>
<li>参数b为蓝色的颜色值，范围0~255</li>
</ul>
<h4 id="setTextSize"><a href="#setTextSize" class="headerlink" title="setTextSize"></a>setTextSize</h4><p> 用于设置画笔的字体大小，主要用于绘制字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为字体大小</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextSize</span><span class="params">(<span class="keyword">float</span> textSize)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="setShadowLayer"><a href="#setShadowLayer" class="headerlink" title="setShadowLayer"></a>setShadowLayer</h4><p>用于设置添加阴影</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShadowLayer</span><span class="params">(<span class="keyword">float</span> radius, <span class="keyword">float</span> dx, <span class="keyword">float</span> dy, <span class="keyword">int</span> shadowColor)</span> </span></span><br></pre></td></tr></table></figure>
<ul>
<li>adius 表示阴影的倾斜度</li>
<li>dx:水平方向位移的像素</li>
<li>dy:垂直方向位移的像素</li>
<li>shadowColor:设置阴影的颜色</li>
</ul>
<h4 id="setTextScaleX"><a href="#setTextScaleX" class="headerlink" title="setTextScaleX"></a>setTextScaleX</h4><p>设置字体水平方向的拉伸，默认为1，当大于1时表示向两边拉伸，小于1时表示向中间压缩</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextScaleX</span><span class="params">(<span class="keyword">float</span> scaleX)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="setFakeBoldText"><a href="#setFakeBoldText" class="headerlink" title="setFakeBoldText"></a>setFakeBoldText</h4><p>用于设置文字是否为粗体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFakeBoldText</span><span class="params">(<span class="keyword">boolean</span> fakeBoldText)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="setStrikeThruText"><a href="#setStrikeThruText" class="headerlink" title="setStrikeThruText"></a>setStrikeThruText</h4><p>设置是否带有删除线效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrikeThruText</span><span class="params">(<span class="keyword">boolean</span> strikeThruText)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="setUnderlineText"><a href="#setUnderlineText" class="headerlink" title="setUnderlineText"></a>setUnderlineText</h4><p>用于设置画笔的下划线，当取值为true时，表示显示下划线</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUnderlineText</span><span class="params">(Boolean underlintext)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="setTextAlign"><a href="#setTextAlign" class="headerlink" title="setTextAlign"></a>setTextAlign</h4><p>设置文字对齐方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为文字对齐方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextAlign</span><span class="params">(Align align)</span></span></span><br></pre></td></tr></table></figure>

<p>可选参数包括：</p>
<ul>
<li>Align.LEFT</li>
<li>Align.RIGHT</li>
<li>Align.CENTER</li>
</ul>
<h4 id="setTextSkewX"><a href="#setTextSkewX" class="headerlink" title="setTextSkewX"></a>setTextSkewX</h4><p>用于设置画笔的倾斜因子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数 skewX 为倾斜因子，正数表示向左倾斜，负数表示向右倾斜</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTextSkewX</span><span class="params">(<span class="keyword">float</span> skewX)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Canvas类"><a href="#Canvas类" class="headerlink" title="Canvas类"></a>Canvas类</h3><h4 id="绘制背景"><a href="#绘制背景" class="headerlink" title="绘制背景"></a>绘制背景</h4><h5 id="drawColor"><a href="#drawColor" class="headerlink" title="drawColor"></a>drawColor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(<span class="keyword">int</span> color)</span> </span></span><br></pre></td></tr></table></figure>
<h5 id="drawRGB"><a href="#drawRGB" class="headerlink" title="drawRGB"></a>drawRGB</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRGB</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b)</span> </span></span><br></pre></td></tr></table></figure>

<h4 id="绘制弧形"><a href="#绘制弧形" class="headerlink" title="绘制弧形"></a>绘制弧形</h4><h5 id="drawArc"><a href="#drawArc" class="headerlink" title="drawArc"></a>drawArc</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawArc</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> useCenter, <span class="meta">@NonNull</span> Paint paint)</span></span></span><br></pre></td></tr></table></figure>

<p>参数信息：</p>
<ul>
<li>前面四个参数围成的矩形，在矩形内绘制内切弧形；</li>
<li>startAngle ： 起始角度</li>
<li>sweepAngle ： 结束角度（按顺时针）</li>
<li>useCenter ：若为true表示此弧会和 RectF 中心相连形成扇形，否则，弧的两头直接相连形成图形</li>
<li>paint</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawArc</span><span class="params">(<span class="meta">@NonNull</span> RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> useCenter, <span class="meta">@NonNull</span> Paint paint)</span></span></span><br></pre></td></tr></table></figure>
<p>直接用 RectF 来表示矩形区域</p>
<h4 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h4><h5 id="drawCircle"><a href="#drawCircle" class="headerlink" title="drawCircle"></a>drawCircle</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">float</span> cx, <span class="keyword">float</span> cy, <span class="keyword">float</span> radius, <span class="meta">@NonNull</span> Paint paint)</span></span></span><br></pre></td></tr></table></figure>

<p>参数信息：</p>
<ul>
<li>cx: 圆心横坐标</li>
<li>cy: 圆心纵坐标</li>
<li>radius: 半径</li>
<li>paint</li>
</ul>
<h4 id="绘制点"><a href="#绘制点" class="headerlink" title="绘制点"></a>绘制点</h4><h5 id="drawPoint"><a href="#drawPoint" class="headerlink" title="drawPoint"></a>drawPoint</h5><p>绘制一个点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="meta">@NonNull</span> Paint paint)</span></span></span><br></pre></td></tr></table></figure>

<p>参数信息：</p>
<ul>
<li>x: 横坐标</li>
<li>y: 纵坐标</li>
<li>paint</li>
</ul>
<h4 id="绘制线段"><a href="#绘制线段" class="headerlink" title="绘制线段"></a>绘制线段</h4><h5 id="drawLine"><a href="#drawLine" class="headerlink" title="drawLine"></a>drawLine</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(<span class="keyword">float</span> startX, <span class="keyword">float</span> startY, <span class="keyword">float</span> stopX, <span class="keyword">float</span> stopY, <span class="meta">@NonNull</span> Paint paint)</span></span></span><br></pre></td></tr></table></figure>

<p>参数信息：</p>
<ul>
<li>startX: 第一个点的横坐标</li>
<li>startY: 第一个点的纵坐标</li>
<li>stopX: 第二个点的横坐标</li>
<li>stopY: 第一个点的纵坐标</li>
<li>paint</li>
</ul>
<h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><h5 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, Paint paint)</span>  </span></span><br></pre></td></tr></table></figure>
<p>因为默认矩形是水平的，所以只需要给出四条边的左边</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(Rect r, Paint paint)</span> </span></span><br></pre></td></tr></table></figure>

<h4 id="绘制圆角矩形"><a href="#绘制圆角矩形" class="headerlink" title="绘制圆角矩形"></a>绘制圆角矩形</h4><h5 id="drawRoundRect"><a href="#drawRoundRect" class="headerlink" title="drawRoundRect"></a>drawRoundRect</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRoundRect</span> <span class="params">(RectF rect,<span class="keyword">float</span> rx,<span class="keyword">float</span> ry,Paint paint)</span></span></span><br></pre></td></tr></table></figure>
<p>参数信息：</p>
<ul>
<li>rx为X方向上的圆角半径</li>
<li>ry为Y方向上的圆角半径</li>
</ul>
<h4 id="绘制椭圆"><a href="#绘制椭圆" class="headerlink" title="绘制椭圆"></a>绘制椭圆</h4><h5 id="drawOval"><a href="#drawOval" class="headerlink" title="drawOval"></a>drawOval</h5><p>通过指定椭圆的外切矩形实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawOval</span><span class="params">(RectF rect.Paint paint)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="根据定义的路径画出图"><a href="#根据定义的路径画出图" class="headerlink" title="根据定义的路径画出图"></a>根据定义的路径画出图</h4><p>主要用于绘制复杂的图形轮廓</p>
<h5 id="drawPath"><a href="#drawPath" class="headerlink" title="drawPath"></a>drawPath</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawPath</span><span class="params">(Path path, Paint paint)</span></span></span><br></pre></td></tr></table></figure>

<p>比如我想要绘制一个三角形，可以定义一个path对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path path = <span class="keyword">new</span> Path(); <span class="comment">//定义一条路径</span></span><br><span class="line">path.moveTo(<span class="number">60</span>, <span class="number">60</span>); <span class="comment">//起始点 坐标60,60</span></span><br><span class="line">path.lineTo(<span class="number">100</span>, <span class="number">100</span>);<span class="comment">//连接直线</span></span><br><span class="line">path.lineTo(<span class="number">200</span>,<span class="number">80</span>);</span><br><span class="line">path.lineTo(<span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制定义的 path</span></span><br><span class="line">canvas.drawPath(path,paint);</span><br></pre></td></tr></table></figure>

<h4 id="绘制字体"><a href="#绘制字体" class="headerlink" title="绘制字体"></a>绘制字体</h4><h5 id="drawText"><a href="#drawText" class="headerlink" title="drawText"></a>drawText</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(String text, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(<span class="keyword">char</span>[] text,<span class="keyword">int</span> index,<span class="keyword">int</span> count,<span class="keyword">float</span> x,<span class="keyword">float</span> y,Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(CharSequence text,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">float</span> x,<span class="keyword">float</span> y,Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span><span class="params">(String text,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">float</span> x,<span class="keyword">float</span> y,Paint paint)</span></span></span><br></pre></td></tr></table></figure>
<p>参数信息：</p>
<ul>
<li>text为字符串的内容</li>
<li>x为X坐标</li>
<li>y为Y坐标</li>
<li>index为显示的起始字符位置</li>
<li>count为显示的字符个数</li>
<li>start为显示的起始字符的位置</li>
<li>end为显示的终止的字符的位置</li>
</ul>
<h4 id="绘制Bitmap"><a href="#绘制Bitmap" class="headerlink" title="绘制Bitmap"></a>绘制Bitmap</h4><h5 id="drawBitmap"><a href="#drawBitmap" class="headerlink" title="drawBitmap"></a>drawBitmap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">float</span> left, <span class="keyword">float</span> top, Paint paint)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数bitmap为Bitmap对象，代表图像资源，</li>
<li>left为图像显示的左边的位置</li>
<li>right为图像的显示的右边的位置</li>
</ul>
<h4 id="Canvas平移"><a href="#Canvas平移" class="headerlink" title="Canvas平移"></a>Canvas平移</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 画布向（100，50）方向平移 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 参数1: 向X轴方向移动100距离</span></span><br><span class="line"><span class="comment"> * 参数2: 向Y轴方向移动50距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> canvas.translate(<span class="number">100</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Canvas缩放"><a href="#Canvas缩放" class="headerlink" title="Canvas缩放"></a>Canvas缩放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在X轴方向放大为原来2倍，Y轴方向方大为原来的4倍 </span></span><br><span class="line"><span class="comment"> * 参数1: X轴的放大倍数 </span></span><br><span class="line"><span class="comment"> * 参数2: Y轴的放大倍数 </span></span><br><span class="line"><span class="comment"> * 默认原点为左上角</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">canvas.scale(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在X轴方向放大为原来2倍，Y轴方向方大为原来的4倍 </span></span><br><span class="line"><span class="comment"> * 参数1: X轴的放大倍数 </span></span><br><span class="line"><span class="comment"> * 参数2: Y轴的放大倍数 </span></span><br><span class="line"><span class="comment"> * 参数3: 原点X坐标</span></span><br><span class="line"><span class="comment"> * 参数4: 原点Y坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">canvas.scale(<span class="number">2</span>, <span class="number">4</span>，<span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>作用效果：<br><img src="http://dengw.xyz/hexo-blog/180822/B1dge7fakI.png" alt="enter image description here"></p>
<h4 id="Canvas旋转"><a href="#Canvas旋转" class="headerlink" title="Canvas旋转"></a>Canvas旋转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 原点为中心，旋转30度（顺时针方向为正方向 ）</span></span><br><span class="line"><span class="comment"> * 参数: 旋转角度 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">canvas.rotate(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以（100,100）为中心，旋转30度，顺时针方向为正方向 </span></span><br><span class="line"><span class="comment"> * 参数: 旋转角度 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">canvas.rotate(<span class="number">30</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>作用效果：<br><img src="http://dengw.xyz/hexo-blog/180822/Jb3DiKd5jm.png" alt="enter image description here"></p>
<h4 id="Canvas保存和还原"><a href="#Canvas保存和还原" class="headerlink" title="Canvas保存和还原"></a>Canvas保存和还原</h4><p>Canvas提供了几个方法，让我们可以方便的对Canvas的状态进行更改和还原。这些方法是：</p>
<ul>
<li>save()</li>
<li>restore()</li>
<li>restoreToCount(int saveCount)。</li>
</ul>
<p>我们在对 Canvas 进行平移、旋转、放大等操作时候，可以调用save()方法，将当前修改过的Canvas状态进行保存，调用restore() 方法后，会将 Canvas 还原成最近的一个save() 的状态。</p>
<p>save()方法还会有一个返回值，我们也可以调用 restoreToCount(int saveCount) 方法，将这个返回值作为参数传递进去，就可以将Canvas还原成某一个特定的save()状态。</p>
<p>一个可参考操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">canvas.translate(<span class="number">100</span>,<span class="number">100</span>); <span class="comment">// 平移（100,100）</span></span><br><span class="line"><span class="keyword">int</span> save1 = canvas.save(); <span class="comment">// 保存Canvas状态（状态1）</span></span><br><span class="line">canvas.scale(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 放大2倍</span></span><br><span class="line"><span class="keyword">int</span> save2 = canvas.save(); <span class="comment">// 保存Canvas状态（状态2）</span></span><br><span class="line">canvas.restore(); <span class="comment">// 返回最新的save状态，即状态2</span></span><br><span class="line">canvas.restoreToCount(save1);<span class="comment">// 手动指定的返回到 状态1</span></span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f69873371763">Android Canvas 方法总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/22/Android%E7%BB%98%E5%9B%BE%E4%B9%8BPaint%E5%92%8CCanvas%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" data-id="ckqm6kpl0000hxxr5hkyje6xc" data-title="Android绘图之Paint和Canvas的使用方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-IdCardCamera—从一个Demo学习Android平台Camera开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/21/IdCardCamera%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AADemo%E5%AD%A6%E4%B9%A0Android%E5%B9%B3%E5%8F%B0Camera%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2018-08-21T06:46:55.000Z" itemprop="datePublished">2018-08-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/21/IdCardCamera%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AADemo%E5%AD%A6%E4%B9%A0Android%E5%B9%B3%E5%8F%B0Camera%E5%BC%80%E5%8F%91/">IdCardCamera — 从一个Demo学习Android平台Camera开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前在 meitu 实习的时候就接触过 Android Camera，现在 Android 已经有两套相机 API：Camera 和Camera2，虽然现在官方推崇的是 Camera2 而且部分 Camera1 的很多API现在已经不再推荐使用了，但是现在市场上的手机厂商对 Camera2 的支持程度也各不相同，所以现在开发使用的还是主要是  Camera1  的API，给出的 Demo 也是在 Camera1 的基础上实现的。</p>
<h2 id="Camera-实践"><a href="#Camera-实践" class="headerlink" title="Camera 实践"></a>Camera 实践</h2><p>Demo实现的功能是一个拍摄身份证正反面的相机应用，首先肯定支持拍摄功能，这个过程就可以完整地体验一下相机应用的开发流程以及相关API的使用，比如：</p>
<ul>
<li>预览</li>
<li>闪光灯</li>
<li>对焦</li>
<li>拍摄</li>
</ul>
<p>其次呢，我们是为了拍摄身份证正反两面的照片，还需要支持对图片的截取功能，这部分我们通过自定义一个控件实现图片四个角的截取。</p>
<h3 id="相机开发的一般流程"><a href="#相机开发的一般流程" class="headerlink" title="相机开发的一般流程"></a>相机开发的一般流程</h3><ol>
<li>检测并访问相机资源，检查手机是否存在相机资源，如果存在则请求访问相机资源。</li>
<li>创建预览界面，创建继承自SurfaceView并实现SurfaceHolder接口的拍摄预览类。有了拍摄预览类，即可创建一个布局文件，将预览画面与设计好的用户界面控件融合在一起，实时显示相机的预览图像。</li>
<li>设置拍照监听器，给用户界面控件绑定监听器，使其能响应用户操作, 开始拍照过程。</li>
<li>拍照并保存文件，将拍摄获得的图像转换成位图文件，最终输出保存成各种常用格式的图片。</li>
<li>释放相机资源，相机是一个共享资源，当相机使用完毕后，必须正确地将其释放，以免其它程序访问使用时发生冲突。</li>
</ol>
<h4 id="资源权限和权限申请"><a href="#资源权限和权限申请" class="headerlink" title="资源权限和权限申请"></a>资源权限和权限申请</h4><p>首先要检查相机资源，获取系统相机的相关信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否有相机</span></span><br><span class="line">context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否有前置相机</span></span><br><span class="line">context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_FRONT);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有多少个摄像头</span></span><br><span class="line">numberOfCameras = Camera.getNumberOfCameras();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfCameras; ++i) &#123;</span><br><span class="line">    <span class="keyword">final</span> Camera.CameraInfo cameraInfo = <span class="keyword">new</span> Camera.CameraInfo();</span><br><span class="line"></span><br><span class="line">    Camera.getCameraInfo(i, cameraInfo);</span><br><span class="line">    <span class="comment">//后置摄像头</span></span><br><span class="line">    <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK)</span><br><span class="line">    &#123;</span><br><span class="line">        faceBackCameraId = i;</span><br><span class="line">        faceBackCameraOrientation = cameraInfo.orientation;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//前置摄像头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) </span><br><span class="line">    &#123;</span><br><span class="line">        faceFrontCameraId = i;</span><br><span class="line">        faceFrontCameraOrientation = cameraInfo.orientation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>另外，相机开发还会设计及到一些权限操作，比如，调用相机拍摄图片的权限，读、写文件的权限等，在demo中需要申请3个权限：</p>
<ul>
<li>Manifest.permission.WRITE_EXTERNAL_STORAGE</li>
<li>Manifest.permission.READ_EXTERNAL_STORAGE</li>
<li>Manifest.permission.CAMERA</li>
</ul>
<p>这里学习到了一种同时申请多个权限的方法</p>
<ul>
<li><p>首先用一个字符串数组保存要申请的权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要申请的权限数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] permissions = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">        Manifest.permission.WRITE_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.READ_EXTERNAL_STORAGE,</span><br><span class="line">        Manifest.permission.CAMERA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>检查应用是否已经具有某个权限，如果没有的话就申请这个权限；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查权限，检查应用所需要的某个权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestCode  请求码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permission  权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkSinglePermission</span><span class="params">(Context context,<span class="keyword">int</span> requestCode, String permission)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> permissionCode = ActivityCompat.checkSelfPermission(context, permission);</span><br><span class="line">	<span class="comment">// PackageManager.PERMISSION_GRANTED 表示应用已经具有的权限</span></span><br><span class="line">	<span class="keyword">if</span>(permissionCode != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">		ActivityCompat.requestPermissions((Activity) context, <span class="keyword">new</span> String[]&#123;permission&#125;, requestCode);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>或者说同时检查应用是否已经具有多个权限，如果没有的话就申请其中应用还不具备权限；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查权限，检查应用所需要的所有权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestCode  请求码</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permissions  权限数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkMultiPermissions</span><span class="params">(Context context, <span class="keyword">int</span> requestCode, String []permissions)</span> </span>&#123;</span><br><span class="line">	rejectedPermissions.clear();</span><br><span class="line">	<span class="keyword">for</span>(String per : permissions) &#123;</span><br><span class="line">		<span class="keyword">int</span> permissionCode = ActivityCompat.checkSelfPermission(context, per);</span><br><span class="line">		<span class="keyword">if</span>(permissionCode != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">	        rejectedPermissions.add(per);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rejectedPermissions.isEmpty()) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    String[] permissionList = rejectedPermissions.toArray(<span class="keyword">new</span> String[rejectedPermissions.size()]);</span><br><span class="line">        ActivityCompat.requestPermissions((Activity)context, permissionList, requestCode);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路就是用一个数组保存还不具备的权限，如果数组不为空的话说明就需要申请这些权限。</p>
<ul>
<li>申请需要的权限</li>
</ul>
<p>申请一个权限的时候使用的是 <code>ActivityCompat</code> 的 <code>requestPermissions</code> 方法，该方法的声明为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void requestPermissions(final @NonNull Activity activity,</span><br><span class="line">            final @NonNull String[] permissions, final @IntRange(from = 0) int requestCode)</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>activity：上下文，</li>
<li>permissions：权限数组</li>
<li>requestCode：请求码</li>
</ul>
<p>并且该方法请求完之后会有一个回调接口，需要在上面传入的上下文中重写该方法，该回调接口的作用就是权限请求的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="meta">@NonNull</span> String[] permissions, <span class="meta">@NonNull</span> <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line"><span class="comment">/* callback - no nothing */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，比如当我们  requestPermissions 方法传入的 context 是 CameraActivity ，那么我们就需要在 CameraActivity 中重写 onRequestPermissionsResult 方法，详细见下面链接中给出的项目代码。</p>
<h4 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 默认开启后置相机</span><br><span class="line">camera = Camera.open();</span><br><span class="line"></span><br><span class="line">// 当知道某个相机具体的id，参考上面检查是否有相机资源的第二种方法</span><br><span class="line">camera = Camera.open(cameraId);</span><br></pre></td></tr></table></figure>

<h4 id="获取相机参数"><a href="#获取相机参数" class="headerlink" title="获取相机参数"></a>获取相机参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取相机参数</span><br><span class="line">Camera.Parameters parameters = camera.getParameters();</span><br></pre></td></tr></table></figure>

<p>常见的参数有以下几种:</p>
<p>闪光灯配置参数，可以通过Parameters.getFlashMode()接口获取:</p>
<ul>
<li>Camera.Parameters.FLASH_MODE_AUTO 自动模式，当光线较暗时自动打开闪光灯；</li>
<li>Camera.Parameters.FLASH_MODE_OFF 关闭闪光灯；</li>
<li>Camera.Parameters.FLASH_MODE_ON 拍照时闪光灯；</li>
<li>Camera.Parameters.FLASH_MODE_RED_EYE 闪光灯参数，防红眼模式。</li>
</ul>
<p>对焦模式配置参数，可以通过Parameters.getFocusMode()接口获取。</p>
<ul>
<li>Camera.Parameters.FOCUS_MODE_AUTO 自动对焦模式，摄影小白专用模式；</li>
<li>Camera.Parameters.FOCUS_MODE_FIXED 固定焦距模式，拍摄老司机模式；</li>
<li>Camera.Parameters.FOCUS_MODE_EDOF 景深模式，文艺女青年最喜欢的模式；</li>
<li>Camera.Parameters.FOCUS_MODE_INFINITY 远景模式，拍风景大场面的模式；</li>
<li>Camera.Parameters.FOCUS_MODE_MACRO 微焦模式，拍摄小花小草小蚂蚁专用模式；</li>
</ul>
<p>场景模式配置参数，可以通过Parameters.getSceneMode()接口获取。</p>
<ul>
<li>Camera.Parameters.SCENE_MODE_BARCODE 扫描条码场景，NextQRCode项目会判断并设置为这个场景；</li>
<li>Camera.Parameters.SCENE_MODE_ACTION 动作场景，就是抓拍跑得飞快的运动员、汽车等场景用的；</li>
<li>Camera.Parameters.SCENE_MODE_AUTO 自动选择场景；</li>
<li>Camera.Parameters.SCENE_MODE_HDR 高动态对比度场景，通常用于拍摄晚霞等明暗分明的照片；</li>
<li>Camera.Parameters.SCENE_MODE_NIGHT 夜间场景；</li>
</ul>
<h4 id="开启预览"><a href="#开启预览" class="headerlink" title="开启预览"></a>开启预览</h4><p>Camera的预览时通过 SurfaceView 的 SurfaceHolder 进行的，这里需要了解几个很关键的类：</p>
<ul>
<li>SurfaceView：用于绘制相机预览图像，提供实时预览的图像。</li>
<li>SurfaceHolder：用于控制Surface的一个抽象接口，它可以控制Surface的尺寸、格式与像素等，并可以监视Surface的变化。</li>
<li>SurfaceHolder.Callback：用于监听Surface状态变化的接口。</li>
</ul>
<h5 id="SurfaceView和普通的View区别"><a href="#SurfaceView和普通的View区别" class="headerlink" title="SurfaceView和普通的View区别"></a>SurfaceView和普通的View区别</h5><p>Surfaceview是视图（view）的一个继承类，这个视图里内嵌了一个专门用于绘制的Surface。</p>
<p>SurfaceView 是在一个新起的单独线程中可以重新绘制画面，而 View 必须在 UI 线程中更新画面。这样，如果绘图任务繁重，使用普通 View 的 onDraw 方法里面的代码要执行好长一段时间，就可能会造成UI主线程阻塞。而 SurfaceView 的机制是在后台线程执行繁重的绘图任务，把所有绘制的东西缓存起来；绘制完毕后，再回到 UI 线程，一次性把所绘制的东西渲染到屏幕上，实质上就是后台线程绘制，UI主线程渲染。</p>
<p>关于 SurfaceView 后面会专门写一篇博客来介绍。</p>
<p>在SurfaceHolder.Callback接口里定义了三个函数：</p>
<ul>
<li>surfaceCreated(SurfaceHolder holder); 当Surface第一次创建的时候调用</li>
<li>surfaceChanged(SurfaceHolder holder, int format, int width, int height); 当Surface的size、format等发生变化的时候调用</li>
<li>surfaceDestroyed(SurfaceHolder holder); 当Surface被销毁的时候调用</li>
</ul>
<p>介绍完上面这些可以写我们用于预览的控件了，下面是我们demo中的预览控件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">// 继承自 SurfaceView 并实现 SurfaceHolder.Callback 接口</span><br><span class="line">public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback&#123;</span><br><span class="line">	// camera实例</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">	</span><br><span class="line">	// 自定义View的三个构造函数</span><br><span class="line">    public CameraPreview(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line">    public CameraPreview(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line">    public CameraPreview(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 依次为重写的 SurfaceHolder.Callback 的三个函数</span><br><span class="line">	 */ </span><br><span class="line"></span><br><span class="line">	// 在这个函数中一般设置预览界面的一些参数，然后开启预览</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceCreated(SurfaceHolder holder) &#123;</span><br><span class="line">        if(mCamera != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Camera.Parameters parameters = mCamera.getParameters();</span><br><span class="line">                if(getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">                    //竖屏拍照时，需要设置旋转90度，否者看到的相机预览方向和界面方向不相同</span><br><span class="line">                    mCamera.setDisplayOrientation(90);</span><br><span class="line">                    parameters.setRotation(90);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mCamera.setDisplayOrientation(0);</span><br><span class="line">                    parameters.setRotation(0);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 设置预览的尺寸</span><br><span class="line">                Camera.Size size = getBestSize(parameters.getSupportedPreviewSizes());</span><br><span class="line">                if(size != null) &#123;</span><br><span class="line">                    parameters.setPreviewSize(size.width, size.height);</span><br><span class="line">                    parameters.setPictureSize(size.width, size.height);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    parameters.setPreviewSize(1920, 1080);</span><br><span class="line">                    parameters.setPictureSize(1920, 1080);</span><br><span class="line">                &#125;</span><br><span class="line">                //设置surfaceHolder</span><br><span class="line">                mCamera.setPreviewDisplay(holder);</span><br><span class="line">                //设置相机参数</span><br><span class="line">                mCamera.setParameters(parameters);</span><br><span class="line">                // 开启预览</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">                //首次对焦</span><br><span class="line">                CameraUtil.focus();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceChanged(SurfaceHolder holder, int format, int width,</span><br><span class="line">                               int height) &#123;</span><br><span class="line">        //因为设置了固定屏幕方向，所以在实际使用中不会触发这个方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 这个函数中一般用来回收资源</span><br><span class="line">    @Override</span><br><span class="line">    public void surfaceDestroyed(SurfaceHolder holder) &#123;</span><br><span class="line">        //回收释放资源</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void init(Context context) &#123;</span><br><span class="line">        SurfaceHolder surfaceHolder = getHolder();</span><br><span class="line">        surfaceHolder.addCallback(this);</span><br><span class="line">        surfaceHolder.setKeepScreenOn(true);</span><br><span class="line">        surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);</span><br><span class="line">        mCamera = CameraUtil.getCameraInstance(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Android相机的预览尺寸都是4:3或者16:9，这里遍历所有支持的预览尺寸，得到16:9的最大尺寸，保证成像清晰度</span><br><span class="line">     *</span><br><span class="line">     * @param sizes</span><br><span class="line">     * @return 最佳尺寸</span><br><span class="line">     */</span><br><span class="line">    private Camera.Size getBestSize(List&lt;Camera.Size&gt; sizes) &#123;</span><br><span class="line">        Camera.Size bestSize = null;</span><br><span class="line">        for (Camera.Size size : sizes) &#123;</span><br><span class="line">            if ((float) size.width / (float) size.height == 16.0f / 9.0f) &#123;</span><br><span class="line">                if (bestSize == null) &#123;</span><br><span class="line">                    bestSize = size;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (size.width &gt; bestSize.width) &#123;</span><br><span class="line">                        bestSize = size;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bestSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放资源</span><br><span class="line">     */</span><br><span class="line">    private void release() &#123;</span><br><span class="line">        if (mCamera != null) &#123;</span><br><span class="line">            mCamera.stopPreview();</span><br><span class="line">            CameraUtil.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 开启预览</span><br><span class="line">     */</span><br><span class="line">    public void startPreview() &#123;</span><br><span class="line">        if (mCamera != null) &#123;</span><br><span class="line">            mCamera.startPreview();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关闭预览"><a href="#关闭预览" class="headerlink" title="关闭预览"></a>关闭预览</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.stopPreview();</span><br></pre></td></tr></table></figure>
<h4 id="开启闪关灯"><a href="#开启闪关灯" class="headerlink" title="开启闪关灯"></a>开启闪关灯</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 开关闪光灯</span><br><span class="line"> *</span><br><span class="line"> * @return 闪光灯是否开启</span><br><span class="line"> */</span><br><span class="line">public static boolean switchFlashLight() &#123;</span><br><span class="line">	if (camera != null) &#123;</span><br><span class="line">		Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">		if (parameters.getFlashMode().equals(Camera.Parameters.FLASH_MODE_OFF))</span><br><span class="line">		&#123;</span><br><span class="line">	        parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);</span><br><span class="line">            camera.setParameters(parameters);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是严谨的话开启闪光灯之前还需要判断是否具有闪光灯，虽然现在没有手机闪光灯的手机基本上没有了。</p>
<h4 id="开启对焦"><a href="#开启对焦" class="headerlink" title="开启对焦"></a>开启对焦</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.autoFocus(null);</span><br></pre></td></tr></table></figure>

<h4 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h4><p>拍照时通过调用Camera的takePicture()方法来完成的，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">takePicture(ShutterCallback shutter, PictureCallback raw,</span><br><span class="line">            PictureCallback jpeg)</span><br></pre></td></tr></table></figure>
<p>该方法有三个参数：</p>
<ul>
<li>ShutterCallback shutter：在拍照的瞬间被回调，这里通常可以播放”咔嚓”这样的拍照音效。</li>
<li>PictureCallback raw：返回未经压缩的图像数据。<br>PictureCallback jpeg：返回经过JPEG压缩的图像数据。</li>
</ul>
<p>我们一般用的就是最后一个，实现最后一个PictureCallback即可，在本demo中主要是在 PictureCallback 中进行图片的剪切。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Camera.PictureCallback() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">		camera.stopPreview();</span><br><span class="line">		<span class="comment">//子线程处理图片，防止ANR</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				Bitmap bitmap = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 计算裁剪位置</span></span><br><span class="line">				<span class="keyword">float</span> left, top, right, bottom;</span><br><span class="line">                left = ((<span class="keyword">float</span>) mLlCameraCropContainer.getLeft() - (<span class="keyword">float</span>)mCameraPreview.getLeft()) / (<span class="keyword">float</span>) mCameraPreview.getWidth();</span><br><span class="line">                top = (<span class="keyword">float</span>) mIvCameraCrop.getTop() / (<span class="keyword">float</span>) mCameraPreview.getHeight();</span><br><span class="line">                right = (<span class="keyword">float</span>) mLlCameraCropContainer.getRight() / (<span class="keyword">float</span>) mCameraPreview.getWidth();</span><br><span class="line">                bottom = (<span class="keyword">float</span>) mIvCameraCrop.getBottom() / (<span class="keyword">float</span>) mCameraPreview.getHeight();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自动裁剪</span></span><br><span class="line">                mCropBitmap = Bitmap.createBitmap(bitmap,</span><br><span class="line">                (<span class="keyword">int</span>) (left * (<span class="keyword">float</span>) bitmap.getWidth()),</span><br><span class="line">                (<span class="keyword">int</span>) (top * (<span class="keyword">float</span>) bitmap.getHeight()),</span><br><span class="line">                (<span class="keyword">int</span>) ((right - left) * (<span class="keyword">float</span>) bitmap.getWidth()),</span><br><span class="line">                (<span class="keyword">int</span>) ((bottom - top) * (<span class="keyword">float</span>) bitmap.getHeight()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 手动裁剪</span></span><br><span class="line">                runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                <span class="comment">//将裁剪区域设置成与扫描框一样大</span></span><br><span class="line">                    mCropImageView.setLayoutParams(<span class="keyword">new</span> LinearLayout.LayoutParams(mIvCameraCrop.getWidth(), mIvCameraCrop.getHeight()));</span><br><span class="line">                    setCropLayout();</span><br><span class="line">                    mCropImageView.setImageBitmap(mCropBitmap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.release();</span><br></pre></td></tr></table></figure>

<h3 id="图片截取"><a href="#图片截取" class="headerlink" title="图片截取"></a>图片截取</h3><p>上面的部分只是 Camera API的一些使用，基本上跟着文档走就可以了，也主要是为了帮助学习和熟悉 Camera API 。</p>
<p>下面回到Demo的需求，获取省份证正反两面的图片，很多时候就需要对一张现成的图片进行截取，这个时候就需要自己定义一个支持图片截图的控件了。</p>
<h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><ul>
<li>一个ImageView，用于显示拍摄的图片，作为图片截图的背景；</li>
<li>一个截取控件：含有四个可自由移动的顶点（一个新的控件），顶点间构成一个矩形，通过移动顶点控制上面 ImageView 的显示范围，达到截取的效果；</li>
</ul>
<p>对于截取控件，总体思路：四个顶点（Point）类 + 相互连线的边</p>
<ul>
<li>canvas.drawLine(topLeft.x, topLeft.y, topRight.x, topRight.y, paint); </li>
<li>canvas.drawLine(top.x, top.y, bottom.x, bottom.y, paint);</li>
</ul>
<p>这样，对于截取，重要的就是确定截取后四个顶点的位置，然后再重新绘图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//图片裁剪的核心功能</span><br><span class="line">Bitmap.createBitmap(originalBitmap,//原图</span><br><span class="line">                 cropX,//图片裁剪横坐标开始位置</span><br><span class="line">                 cropY,//图片裁剪纵坐标开始位置</span><br><span class="line">                 cropWidth,//要裁剪的宽度</span><br><span class="line">                 cropHeight);//要裁剪的高度</span><br></pre></td></tr></table></figure>

<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><ul>
<li>四个顶点(左上，左下，右上，右下)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Point topLeft, topRight, bottomLeft, bottomRight;</span><br></pre></td></tr></table></figure></li>
<li>原图 Bitmap<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 确定要截取的范围后在原Bitmap的基础上创建一个新的Bitmap</span><br><span class="line">private Bitmap bitmap;</span><br></pre></td></tr></table></figure></li>
<li>绘制背景</li>
</ul>
<p>Paint + Path + Canvas</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void drawBackground(Canvas canvas) &#123;</span><br><span class="line">	Paint paint = new Paint();</span><br><span class="line">    paint.setColor(Color.parseColor(&quot;#66000000&quot;));</span><br><span class="line">    paint.setStyle(Paint.Style.FILL);</span><br><span class="line">    Path path = new Path();</span><br><span class="line">    path.moveTo(topLeft.x, topLeft.y);</span><br><span class="line">    path.lineTo(topRight.x, topRight.y);</span><br><span class="line">    path.lineTo(bottomRight.x, bottomRight.y);</span><br><span class="line">    path.lineTo(bottomLeft.x, bottomLeft.y);</span><br><span class="line">    path.close();</span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.clipPath(path, Region.Op.DIFFERENCE);</span><br><span class="line">    canvas.drawColor(Color.parseColor(&quot;#66000000&quot;));</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>绘制顶点</li>
</ul>
<p>Paint + Canvas</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void drawVertex(Canvas canvas) &#123;</span><br><span class="line">    Paint paint = new Paint();</span><br><span class="line">    paint.setColor(Color.WHITE);</span><br><span class="line">    paint.setStyle(Paint.Style.FILL);</span><br><span class="line"></span><br><span class="line">    canvas.drawCircle(topLeft.x, topLeft.y, vertexSize, paint);</span><br><span class="line">    canvas.drawCircle(topRight.x, topRight.y, vertexSize, paint);</span><br><span class="line">    canvas.drawCircle(bottomLeft.x, bottomLeft.y, vertexSize, paint);</span><br><span class="line">    canvas.drawCircle(bottomRight.x, bottomRight.y, vertexSize, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>绘制顶点间的连线从而构成矩形</li>
</ul>
<p>Paint + Canvas</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void drawEdge(Canvas canvas) &#123;</span><br><span class="line">    Paint paint = new Paint();</span><br><span class="line">    paint.setColor(Color.WHITE);</span><br><span class="line">    paint.setStrokeWidth(3);</span><br><span class="line">    paint.setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">    canvas.drawLine(topLeft.x, topLeft.y, topRight.x, topRight.y, paint);</span><br><span class="line">    canvas.drawLine(topLeft.x, topLeft.y, bottomLeft.x, bottomLeft.y, paint);</span><br><span class="line">    canvas.drawLine(bottomRight.x, bottomRight.y, topRight.x, topRight.y, paint);</span><br><span class="line">    canvas.drawLine(bottomRight.x, bottomRight.y, bottomLeft.x, bottomLeft.y, paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>touchEvevt 处理</li>
</ul>
<p>处理 MotionEvent.ACTION_DOWN + MotionEvent.ACTION_MOVE事件，并拦截事件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    switch (event.getAction()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(false);</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(false);</span><br><span class="line">            onActionDown(event);</span><br><span class="line">            return true;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(true);</span><br><span class="line">            onActionMove(event);</span><br><span class="line">            return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>MotionEvent.ACTION_DOWN事件的逻辑</li>
</ul>
<p>根据touchPoint确定作用的顶点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void onActionDown(MotionEvent event) &#123;</span><br><span class="line">    touchDownX = event.getX();</span><br><span class="line">    touchDownY = event.getY();</span><br><span class="line">    Point touchPoint = new Point((int) event.getX(), (int) event.getY());</span><br><span class="line">    int minDistance = distance(touchPoint, topLeft);</span><br><span class="line">    cropPosition = CropPosition.TOP_LEFT;</span><br><span class="line">    if (minDistance &gt; distance(touchPoint, topRight)) &#123;</span><br><span class="line">        minDistance = distance(touchPoint, topRight);</span><br><span class="line">        cropPosition = CropPosition.TOP_RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (minDistance &gt; distance(touchPoint, bottomLeft)) &#123;</span><br><span class="line">        minDistance = distance(touchPoint, bottomLeft);</span><br><span class="line">        cropPosition = CropPosition.BOTTOM_LEFT;</span><br><span class="line">    &#125;</span><br><span class="line">    if (minDistance &gt; distance(touchPoint, bottomRight)) &#123;</span><br><span class="line">        cropPosition = CropPosition.BOTTOM_RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>MotionEvent.ACTION_MOV</li>
</ul>
<p>根据上面确定的顶点，计算touchPoint的移动在 x 和 y方向的偏移量，然后调整作用顶点的坐标，最后调用 invalidate() 方法重新绘制View</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void onActionMove(MotionEvent event) &#123;</span><br><span class="line">    int deltaX = (int) (event.getX() - touchDownX);</span><br><span class="line">    int deltaY = (int) (event.getY() - touchDownY);</span><br><span class="line"></span><br><span class="line">    switch (cropPosition) &#123;</span><br><span class="line">        case TOP_LEFT:</span><br><span class="line">            adjustPointCoordinate(topLeft, deltaX, deltaY);</span><br><span class="line">            invalidate();</span><br><span class="line">            break;</span><br><span class="line">        case TOP_RIGHT:</span><br><span class="line">            adjustPointCoordinate(topRight, deltaX, deltaY);</span><br><span class="line">            invalidate();</span><br><span class="line">            break;</span><br><span class="line">        case BOTTOM_LEFT:</span><br><span class="line">            adjustPointCoordinate(bottomLeft, deltaX, deltaY);</span><br><span class="line">            invalidate();</span><br><span class="line">            break;</span><br><span class="line">        case BOTTOM_RIGHT:</span><br><span class="line">            adjustPointCoordinate(bottomRight, deltaX, deltaY);</span><br><span class="line">            invalidate();</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    touchDownX = event.getX();</span><br><span class="line">    touchDownY = event.getY();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 移动中调整作用顶点的坐标</span><br><span class="line"> */</span><br><span class="line">private void adjustPointCoordinate(Point point, int deltaX, int deltaY) &#123;</span><br><span class="line">    int newX = point.x + deltaX;</span><br><span class="line">    if (newX &lt; minX) newX = minX;</span><br><span class="line">    if (newX &gt; maxX) newX = maxX;</span><br><span class="line"></span><br><span class="line">    int newY = point.y + deltaY;</span><br><span class="line">    if (newY &lt; minY) newY = minY;</span><br><span class="line">    if (newY &gt; maxY) newY = maxY;</span><br><span class="line"></span><br><span class="line">    point.set(newX, newY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>crop（图片裁剪）相关：</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a target="_blank" rel="noopener" href="https://github.com/duang0626/IDCardCamera">Demo地址 ： IDCardCamera</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a33a5106fb9a04525782db5">Android平台Camera开发实践指南</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/chunqiuwei/article/details/78858192">Android自定义 view之图片裁剪从设计到实现</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/21/IdCardCamera%E2%80%94%E4%BB%8E%E4%B8%80%E4%B8%AADemo%E5%AD%A6%E4%B9%A0Android%E5%B9%B3%E5%8F%B0Camera%E5%BC%80%E5%8F%91/" data-id="ckqm6kpnf006wxxr5fv6mh1f0" data-title="IdCardCamera — 从一个Demo学习Android平台Camera开发" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Camera%E5%BC%80%E5%8F%91/" rel="tag">Camera开发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-在两个Activity之间传递Bitmap对象的方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/15/%E5%9C%A8%E4%B8%A4%E4%B8%AAActivity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92Bitmap%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-08-15T08:54:19.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/15/%E5%9C%A8%E4%B8%A4%E4%B8%AAActivity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92Bitmap%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/">在两个Activity之间传递Bitmap对象的方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="问题陈述"><a href="#问题陈述" class="headerlink" title="问题陈述"></a>问题陈述</h3><p>今天在做一个相机应用的时候，有这样一个场景，需要将一个 Bitmap 对象从一个 Activity 传递到另外一个 Activity，并且需要在另外一个 Activity 中显示出来。对于在不同的 Activity 之间传递数据这种场景，而且 Bitmap 是序列化的，所以很自然就想到使用 Intent，然后我也就这么用了，但是发现出了问题。</p>
<p>会发现跳转不过去，也就是说还是显示的之前的 Activity，我通过打 Log 发现 Intent 语句已经执行了，但是为什么跳转不过去了，然后就怀疑是 Bitmap 的问题，因为平时就使用 Intent 来传递一下字符串或者序列化对象之类。果然，我将 bitmap 换成一个字符串的话就可以成功的跳转，确定是 Bitmap 的原因。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>既然发现问题了那就去查阅解决方法嘛，一查，网上果然有人也遇到过这个问题。</p>
<p>首先引起这个问题的原因是使用 Intent 传递数据是有大小限制的，但是也没有一个确定的数值说小于这个数值就一定可以传输成功，大于这个数值就一定传输失败，一个说法是可能和运存大小有关或者是手机厂商自定义的，这个有待考证。</p>
<p>因为我发送的 Bitmap 是用2000W 像素拍摄的图片，说一肯定是因为太大了导致传输失败，那有什么就觉方法呢？</p>
<p>这里提供两个思路：</p>
<h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>将图片保存到本地然后传递图片在本地的路径，这也是推荐的方法。</p>
<p>这种方法很好想到，保存到本地化后获取到的图片路径就是一个字符串了，肯定就可以传递了，不过这种方法比较麻烦，因为需要涉及到图片的保存操作，有一定的代码量。</p>
<h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>将 bitmap 存储为 byte 数组，然后再通过Intent传递这个数组。</p>
<p>试了一下这种方法，确实可以，但是后来仔细想想，觉得还是有点疑问：将Bitmap 转化为一个 byte 数组在大小上应该不会有非常大的变化，这样按道理说还是会因为传递的数据太大而导致传输失败。或者说传递一个数组的话实际数据传递的次数增加了，这样单次传递的数据大小就更小，而一次性传递一个Bitmap对象单次传递到的数据太大？</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><p>这里主要提供一下思路2的代码</p>
<p>传递方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);</span><br><span class="line">ByteArrayOutputStream outStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">bitmap.compress(Bitmap.CompressFormat.PNG, <span class="number">100</span>, outStream);</span><br><span class="line"><span class="keyword">byte</span> [] bitmapByte = outStream.toByteArray();</span><br><span class="line">intent.putExtra(IMAGE_PATH, bitmapByte);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>接收方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> [] bis=intent.getByteArrayExtra(IMAGE_PATH);</span><br><span class="line">Bitmap bitmap=BitmapFactory.decodeByteArray(bis, <span class="number">0</span>, bis.length);</span><br><span class="line">imageView.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/15/%E5%9C%A8%E4%B8%A4%E4%B8%AAActivity%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92Bitmap%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/" data-id="ckqm6kpmb003xxxr53r317znn" data-title="在两个Activity之间传递Bitmap对象的方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Intent/" rel="tag">Intent</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-排序算法总结与java实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2018-08-15T07:22:54.000Z" itemprop="datePublished">2018-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/">排序算法总结与java实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="排序算法稳定性"><a href="#排序算法稳定性" class="headerlink" title="排序算法稳定性"></a>排序算法稳定性</h3><p>排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序通过重复地走访过要排序的元素列，一次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。</p>
<p>这个算法的名字由来是因为越大（小）的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列）。</p>
<p>冒泡排序算法的原理如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<p>用一个图来表示一下这个过程：</p>
<p><img src="http://dengw.xyz/blog/180816/bdEkD9F5E0.gif" alt="enter image description here"></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 <code>C</code>和记录移动次数 <code>M</code> 均达到最小值 <code>C</code> = n - 1 ，<code>M</code> = 0 。<br>所以，冒泡排序最好的时间复杂度为 <code>O(n)</code>。</p>
<p>若初始文件是反序的，需要进行 n - 1 趟排序。每趟排序要进行 n - i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
<p>$$ C_{max} = n(n - 1) / 2  = O(n^2) $$</p>
<p>$$ M_{max} = 3n(n - 1) / 2  = O(n^2) $$</p>
<p>冒泡排序的最坏时间复杂度为 $O(n^2)$。<br>综上，因此冒泡排序总的平均时间复杂度为$ O(n^2) $ 。</p>
<h4 id="算法稳定性"><a href="#算法稳定性" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。（这儿看一下下面代码中的注释）</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> []array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; j++) &#123;</span><br><span class="line">            <span class="comment">// 这里使用&gt;符号而不是&gt;=符号可以保证冒泡排序的稳定性</span></span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 （或者说就简单理解为每一次都从原数组中挑选出剩余部分最小的元素插入到一个新的数组中）</p>
<p>用一个图来表示一下这个过程：</p>
<p><img src="http://dengw.xyz/blog/180816/EdFiLk3f1L.gif" alt="enter image description here"></p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>选择排序的交换操作介于 0 和 (n - 1) 次之间。选择排序的比较操作为 n (n - 1) / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1) 次之间。<br>比较次数 O(n^2)，比较次数与关键字的初始状态无关，总的比较次数 $N=(n-1)+(n-2)+…+1=n*(n-1) / 2$ 交换次数 O(n)，最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。</p>
<h4 id="算法稳定性-1"><a href="#算法稳定性-1" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>选择排序是稳定的排序算法，举个例子说明它不是稳定的，有一个序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。</p>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> []array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length, temp;</span><br><span class="line">    <span class="keyword">int</span> index;   <span class="comment">// 记录当前轮最小数的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[index]) &#123;</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = array[i];</span><br><span class="line">            array[i] = array[index];</span><br><span class="line">            array[index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序工作的时候将一个数组分为两个部分：已排序序列和未排序序列，插入排序基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据序列。</p>
<p>具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<p>用一个图来表示一下这个过程：</p>
<p><img src="http://dengw.xyz/blog/180816/jaimELb72B.gif" alt="enter image description here"></p>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。</p>
<p>最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 (n-1) 次即可。<br>最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 n(n-1)/2 次。插入排序的赋值操作是比较操作的次数加上 (n-1) 次。</p>
<p>平均来说插入排序算法的时间复杂度为O(n^2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。</p>
<h4 id="算法稳定性-2"><a href="#算法稳定性-2" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> []array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length, temp;</span><br><span class="line">    <span class="keyword">int</span> index;  <span class="comment">//记录已排序部分最右边的下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        index = i - <span class="number">1</span>;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; array[index] &gt; temp) &#123;</span><br><span class="line">            array[index + <span class="number">1</span>] = array[index];</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[index + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li>
</ul>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>用一个来表示一下这个过程：</p>
<p><img src="http://dengw.xyz/blog/180816/A3CCKI4Lk9.gif" alt="enter image description here"></p>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Shell排序的时间性能优于直接插入排序</p>
<p>希尔排序的时间性能优于直接插入排序的原因：</p>
<ol>
<li>当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。</li>
<li>当n值较小时，n 和  n^2 的差别也较小，即直接插入排序的最好时间复杂度 O(n) 和最坏时间复杂度 0( n^2 ) 差别不大。</li>
<li>在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。</li>
</ol>
<p>所以当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比 o(n^2) 好一些。</p>
<h4 id="算法稳定性-3"><a href="#算法稳定性-3" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>希尔排序是非稳定排序算法，因为最开始 gap 的值是大于1的，那么就很可能让两个相等数的相对位置发生改变。</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> []array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length, tem;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">while</span>(gap &lt; len) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            index = i - gap;</span><br><span class="line">            tem = array[i];</span><br><span class="line">            <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; array[index] &gt; tem) &#123;</span><br><span class="line">                array[index + gap] = array[index];</span><br><span class="line">                index -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[index + gap] = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = (gap - <span class="number">1</span>) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p>用一个图来表示一下这个过程：</p>
<p><img src="http://dengw.xyz/blog/180816/KB7c48Lh2m.gif" alt="enter image description here"></p>
<h4 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>当基数值不能很好地分割数组，即基准值将数组分成一个子数组中有一个记录，而另一个子组组有 n -1 个记录时，下一次的子数组只比原来数组小 1，这是快速排序的最差的情况。如果这种情况发生在每次划分过程中，那么快速排序就退化成了冒泡排序，其时间复杂度为 O(n2)。</p>
<p>如果基准值都能讲数组分成相等的两部分，则出现快速排序的最佳情况。在这种情况下，我们还要对每个大小约为 n/2 的两个子数组进行排序。在一个大小为 n 的记录中确定一个记录的位置所需要的时间为 O(n)。 若T(n)为对n个记录进行排序所需要的时间，则每当一个记录得到其正确位置，整组大致分成两个相等的两部分时，我们得到快速排序算法的最佳时间复杂性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T(n) &lt;= cn + 2T(n/2)</span><br><span class="line">　　 &lt;= cn + 2(cn/2+2T(n/4)) = 2cn+ 4T(n/4)</span><br><span class="line">　　 &lt;= 2cn + 4(cn/4+ 2T(n/8)) = 3cn + 8T(n/8)</span><br><span class="line">    …… ……</span><br><span class="line">　　 &lt;= cnlogn + nT(1) = O(nlogn)</span><br></pre></td></tr></table></figure>
<p>其中cn 是一次划分所用的时间，c是一个常数.</p>
<p>最坏的情况，每次划分都得到一个子序列，时间复杂度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T(n) = cn + T(n-1)</span><br><span class="line">     = cn + c(n-1) + T(n - 2) = 2cn -c + T(n-2)</span><br><span class="line">     = 2cn -c + c(n - 2) + T(n-3) = 3cn -3c + T(n-3)</span><br><span class="line">     ……</span><br><span class="line">     = c[n(n+1)/2-1] + T(1) =  O(n^2)</span><br></pre></td></tr></table></figure>
<p>快速排序的时间复杂度在平均情况下介于最佳与最差情况之间，假设每一次分割时，基准值处于最终排序好的位置的概率是一样的，基准值将数组分成长度为0 和 n-1，1 和 n-2，…… 的概率都是 1/n。在这种假设下，快速排序的平均时间复杂性为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T(n) = cn + 1/n(T(k)+ T(n-k-1)) </span><br><span class="line"></span><br><span class="line">T(1) = c</span><br><span class="line"></span><br><span class="line">T(0) = c</span><br></pre></td></tr></table></figure>

<p>这是一个递推公式，T(k)和T(n-k-1)是指处理长度为 k 和 n-k-1 数组是快速排序算法所花费的时间， 根据公式所推算出来的时间为 O(nlogn)。因此快速排序的平均时间复杂性为O(nlogn)。</p>
<h4 id="算法稳定性-4"><a href="#算法稳定性-4" class="headerlink" title="算法稳定性"></a>算法稳定性</h4><p>因为快速排序在进行交换时，只是根据比较基数值判断是否交换，且不是相邻元素来交换，在交换过程中可能改变相同元素的顺序，因此是一种不稳定的排序算法</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> []array)</span> </span>&#123;</span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归部分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = partition(array, left, right);</span><br><span class="line">        sort(array, left, pivot - <span class="number">1</span>);</span><br><span class="line">        sort(array, pivot + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下标为l的元素为基准对数组进行分区并返回其在新数组中对应的位置下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = array[l];</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; array[r] &gt; num) r--;</span><br><span class="line">        swap(array, l, r);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; num &gt;= array[l]) l++;</span><br><span class="line">        swap(array, l ,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将特定下标的元素交换</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tem = array[l];</span><br><span class="line">    array[l] = array[r];</span><br><span class="line">    array[r] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<p>用一个图来表示一下这个过程：<br><img src="http://dengw.xyz/blog/180816/I0D6cjDgf8.gif" alt="enter image description here"></p>
<p>分治的思想：<br><img src="http://dengw.xyz/blog/180816/Kjd4bA0EbK.png?imageslim" alt="enter image description here"></p>
<h4 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>归并排序的时间复杂度是O(N*lgN)。</p>
<p>假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？<br>归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的特点可以得到遍历次数为 O(logN)<br>可以得出它的时间复杂度是 O(N*logN)。</p>
<h4 id="稳定分析"><a href="#稳定分析" class="headerlink" title="稳定分析"></a>稳定分析</h4><p>归并排序是稳定的算法，当两个元素相等时，进行相等比较不会改变他们之间的相对位置。</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序（分治的思想）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> []array)</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array.length;</span><br><span class="line">    <span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">    <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    sort(array, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// “分”的部分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []array, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> []temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 左边归并排序，使得左子序列有序</span></span><br><span class="line">        sort(array, left, mid, temp);</span><br><span class="line">        <span class="comment">// 右边归并排序，使得右子序列有序</span></span><br><span class="line">        sort(array, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 将两个有序子数组合并操作</span></span><br><span class="line">        merge(array, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// “治”的部分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span> []temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 依次将两个子数组中的较小值填入新数组</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt;= array[j]) &#123;</span><br><span class="line">            temp[index++] = array[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[index++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当其中一个子数组已经将所有数填入新数组后</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">        temp[index++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">        temp[index++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 长度为right - left</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        array[left++] = temp[index++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序也是第一次接触，贴一下自己的学习博客吧；<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/MOBIN/p/5374217.html">参考文章1</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chengxiao/p/6129630.html">参考文章2</a></p>
<p>用一张图片来表示一下这个过程：<br><img src="http://dengw.xyz/blog/180816/Gji4ajH90E.gif" alt="enter image description here"></p>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="keyword">int</span> []array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tail = array.length - <span class="number">1</span>;  <span class="comment">//当前尾部元素的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从tail / 2 - 1到0的下标对应的元素才有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = tail / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        headAdjust(array, i, tail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tail &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 堆顶元素和tail下标对应的元素交换(堆顶元素为当前0~tail中的最大值)</span></span><br><span class="line">        swap(array, <span class="number">0</span>, tail--);</span><br><span class="line">        headAdjust(array, <span class="number">0</span>, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">headAdjust</span><span class="params">(<span class="keyword">int</span> []array, <span class="keyword">int</span> index, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left, right, i;  <span class="comment">//left表示index下标对应元素的左子节点的下标，right同理</span></span><br><span class="line">    <span class="keyword">while</span>((left = <span class="number">2</span> * index + <span class="number">1</span>) &lt;= tail) &#123;</span><br><span class="line">        right = left + <span class="number">1</span>;</span><br><span class="line">        i = left;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; tail &amp;&amp; array[left] &lt; array[right]) i++;  <span class="comment">// 此时i表示两个子节点的较大值的下标</span></span><br><span class="line">        <span class="keyword">if</span>(array[index] &lt; array[i]) &#123;   <span class="comment">// 保证父节点的值大于两个子节点的值</span></span><br><span class="line">            swap(array, index, i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果父节点已经大于两个子节点直接跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 交换后的子节点还有父节点的情况</span></span><br><span class="line"><span class="comment">         * 这种情况发生在整个树的根节点发生一下交换后</span></span><br><span class="line"><span class="comment">         * 继续执行while循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将特定下标的元素交换</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tem = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = tem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E4%B8%8Ejava%E5%AE%9E%E7%8E%B0/" data-id="ckqm6kpnj0078xxr54883bti2" data-title="排序算法总结与java实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php%E5%AD%A6%E4%B9%A0/">php学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring%E5%AD%A6%E4%B9%A0/">spring学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">数据存储</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANR/" rel="tag">ANR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="tag">Android消息机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Animation/" rel="tag">Animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera%E5%BC%80%E5%8F%91/" rel="tag">Camera开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/" rel="tag">Intent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">Java内存机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%AE%B9%E5%99%A8/" rel="tag">Java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%91%BD%E4%BB%A4/" rel="tag">Linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP/" rel="tag">MVP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecylerView/" rel="tag">RecylerView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Window/" rel="tag">Window</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" rel="tag">apk反编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/" rel="tag">spring-boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag">剑指Offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0/" rel="tag">实习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">文件下载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/" rel="tag">网络框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/" rel="tag">自定义View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" rel="tag">项目总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANR/" style="font-size: 10px;">ANR</a> <a href="/tags/Activity/" style="font-size: 12.5px;">Activity</a> <a href="/tags/Android/" style="font-size: 12.5px;">Android</a> <a href="/tags/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Android消息机制</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/Camera%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Camera开发</a> <a href="/tags/Canvas/" style="font-size: 10px;">Canvas</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/HTTP/" style="font-size: 17.5px;">HTTP</a> <a href="/tags/Intent/" style="font-size: 10px;">Intent</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Java内存机制</a> <a href="/tags/Java%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">Java容器</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 17.5px;">Java虚拟机</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">Linux命令</a> <a href="/tags/MVP/" style="font-size: 10px;">MVP</a> <a href="/tags/RecylerView/" style="font-size: 10px;">RecylerView</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/View%E5%B8%83%E5%B1%80/" style="font-size: 20px;">View布局</a> <a href="/tags/Window/" style="font-size: 10px;">Window</a> <a href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" style="font-size: 10px;">apk反编译</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 10px;">spring-boot</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/vim/" style="font-size: 12.5px;">vim</a> <a href="/tags/%E5%89%91%E6%8C%87Offer/" style="font-size: 10px;">剑指Offer</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 12.5px;">反射</a> <a href="/tags/%E5%AE%9E%E4%B9%A0/" style="font-size: 12.5px;">实习</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" style="font-size: 10px;">文件下载</a> <a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 17.5px;">校招</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">泛型</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 15px;">类加载</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">网络框架</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/" style="font-size: 10px;">自定义View</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" style="font-size: 10px;">项目总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/06/Mac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/">Mac终端常用快捷键总结</a>
          </li>
        
          <li>
            <a href="/2019/06/23/%E5%85%B3%E4%BA%8Ephp%E7%9A%84empty%E5%87%BD%E6%95%B0/">关于php的empty函数</a>
          </li>
        
          <li>
            <a href="/2019/06/16/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">Spring常用注解</a>
          </li>
        
          <li>
            <a href="/2019/06/05/%E4%BD%BF%E7%94%A8-gitignore%E9%85%8D%E7%BD%AEgit%E5%BF%BD%E7%95%A5%E6%8F%90%E4%BA%A4%E8%A7%84%E5%88%99/">使用.gitignore配置git忽略提交规则</a>
          </li>
        
          <li>
            <a href="/2019/06/05/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">Mysql常用命令总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>