<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-图解HTTP学习笔记—第五章" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/14/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/" class="article-date">
  <time class="dt-published" datetime="2018-08-13T16:23:06.000Z" itemprop="datePublished">2018-08-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/14/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/">图解HTTP学习笔记—第五章</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><p>今天继续我们HTTP的学习，今天的内容是HTTP报文中一个重要的组成部分—HTTP 首部字段；</p>
<p>前面我们分析HTTP报文的时候说到HTTP报文就由首部和实体两个部分组成，而首部字段就是首部的组要组成成分之一，可以说首部字段包含了HTTP报文丰富的信息，是构成HTTP的重要要素，下面详细介绍一下：</p>
<h2 id="HTTP-首部字段的通用结构"><a href="#HTTP-首部字段的通用结构" class="headerlink" title="HTTP 首部字段的通用结构"></a>HTTP 首部字段的通用结构</h2><p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。<br><code>首部字段名: 字段值</code></p>
<p>例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。<br><code>Content-Type: text/html</code><br>就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。</p>
<p>另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。<br><code>Keep-Alive: timeout=15, max=100</code></p>
<h2 id="HTTP-首部字段的分类"><a href="#HTTP-首部字段的分类" class="headerlink" title="HTTP 首部字段的分类"></a>HTTP 首部字段的分类</h2><ul>
<li><p><strong>通用首部字段</strong><br>请求报文和响应报文两方都会使用的首部字段。</p>
</li>
<li><p><strong>请求首部字段</strong><br>从客户端向服务器端发送请求报文时使用的首部字段。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
</li>
<li><p><strong>相应首部字段</strong><br>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p>
</li>
<li><p><strong>实体首部字段</strong><br>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p>
</li>
</ul>
<p>下面就详细介绍一下 HTTP/1.1 版本中各类型都包含了哪些首部字段以及各自的含义：</p>
<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。</p>
<p>指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 CacheControl 的指令可用于请求及响应时。</p>
<h5 id="Cache-Control-指令一览"><a href="#Cache-Control-指令一览" class="headerlink" title="Cache-Control 指令一览"></a>Cache-Control 指令一览</h5><p>可用的指令按请求和响应分类如下所示。</p>
<p>缓存请求指令：<br><img src="http://dengw.xyz/blog/180814/GjlklGhAdI.png?imageslim" alt="缓存请求指令"></p>
<p>缓存响应指令：<br><img src="http://dengw.xyz/blog/180814/LHeemC3Ihk.png?imageslim" alt="enter image description here"></p>
<h6 id="表示是否能缓存的指令包括："><a href="#表示是否能缓存的指令包括：" class="headerlink" title="表示是否能缓存的指令包括："></a>表示是否能缓存的指令包括：</h6><ul>
<li><p>public 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>
<p>当指定使用 public 指令时，则明确表明其他用户也可利用缓存。 </p>
</li>
<li><p>private 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>
<p>当指定 private 指令后，响应只以特定的用户作为对象，这与 public 指令的行为相反。<br>缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送 过来的请求，代理服务器则不会返回缓存。</p>
</li>
<li><p>no-cache 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>
<p>使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。 客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接 收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发 给源服务器。<br>如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对 资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资 源有效性进行确认，且禁止其对响应资源进行缓存操作。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache=Location</span><br></pre></td></tr></table></figure>
<p>由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache 字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首 部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首 部字段可以使用缓存。只能在响应指令中指定该参数。</p>
<ul>
<li>no-store 指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store </span><br></pre></td></tr></table></figure>
当使用 no-store 指令时，暗示请求（和对应的响应）或响应中包含机密信息。</li>
</ul>
<p>从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓 存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存。</p>
<h6 id="指定缓存期限和认证的指令"><a href="#指定缓存期限和认证的指令" class="headerlink" title="指定缓存期限和认证的指令"></a>指定缓存期限和认证的指令</h6><ul>
<li><p>s-maxage 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: s-maxage=604800（单位 ：秒）</span><br></pre></td></tr></table></figure>
<p>s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何 作用。另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及 max-age 指令的处理。 </p>
</li>
<li><p>max-age 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=604800（单位：秒）</span><br></pre></td></tr></table></figure>
<p>当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。 另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发 给源服务器。<br>当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源 的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时 间。<br>应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情 况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而 HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略。</p>
</li>
<li><p>min-fresh 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: min-fresh=60（单位：秒）</span><br></pre></td></tr></table></figure>
<p>min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。 比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响 应返回了。</p>
</li>
<li><p>max-stale 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-stale=3600（单位：秒）</span><br></pre></td></tr></table></figure>
<p>使用 max-stale 可指示缓存资源，即使过期也照常接收。<br>如果指令未指定参数值，那么无论经过多久，客户端都会接收响应； 如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale 指定的时间内，仍旧会被客户端接收</p>
</li>
<li><p>only-if-cached 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: only-if-cached</span><br></pre></td></tr></table></figure>
<p>使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资 源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新 加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本 地缓存无响应，则返回状态码 504 Gateway Timeout。</p>
</li>
<li><p>must-revalidate 指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: must-revalidate</span><br></pre></td></tr></table></figure>
<p>使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响 应缓存目前是否仍然有效。<br>若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端 一条 504（Gateway Timeout）状态码。 另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已 经在首部使用了 max-stale，也不会再有效果）。</p>
</li>
<li><p>proxy-revalidate 指令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: proxy-revalidate</span><br></pre></td></tr></table></figure>

<p>proxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指 令的请求返回响应之前，必须再次验证缓存的有效性。</p>
<ul>
<li>no-transform 指令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-transform</span><br></pre></td></tr></table></figure>
使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。</li>
</ul>
<h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>Connection 首部字段具备如下两个作用。</p>
<ul>
<li><p>控制不再转发给代理的首部字段<br><img src="http://dengw.xyz/blog/180814/gDAj4083Dm.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: 不再转发的首部字段名</span><br></pre></td></tr></table></figure>
<p>在客户端发送请求和服务器返回响应内，使用 Connection 首部字 段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首 部）。</p>
</li>
<li><p>管理持久连接<br><img src="http://dengw.xyz/blog/180814/6dKcfJ4DlG.png?imageslim" alt="enter image description here"><br>HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持 久连接上连续发送请求。当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为 此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。<br>如上图①所示，客户端发送请求给服务器时，服务器端会像上图 ②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回 响应。</p>
<h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p>首部字段 Date 表明创建 HTTP 报文的日期和时间。<br>HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下 示 例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Jul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure>
<p>之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03-Jul-12 04:40:59 GMT</span><br></pre></td></tr></table></figure>
<p>除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出 格式一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue Jul 03 04:40:59 2012</span><br></pre></td></tr></table></figure>

<h4 id="Pragma-Pragma"><a href="#Pragma-Pragma" class="headerlink" title="Pragma Pragma"></a>Pragma Pragma</h4><p>是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。<br>规范定义的形式唯一，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure>
<p>该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。</p>
<p>所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 CacheControl: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握 全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的 请求会同时含有下面两个首部字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache </span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure>

<h4 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h4><p><img src="http://dengw.xyz/blog/180814/CbHA8jjk5b.png?imageslim" alt="enter image description here"><br>首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该 首部字段可应用在 HTTP/1.1 版本分块传输编码时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Date: Tue, 03 Jul 2012 04:40:56 GMT </span><br><span class="line">Content-Type: text/html</span><br><span class="line"> ... </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Trailer: Expires ...(报文主体)... 0</span><br><span class="line">Expires: Tue, 28 Sep 2004 23:59:59 GMT </span><br></pre></td></tr></table></figure>
<p> 以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后 （分块长度 0 之后）出现了首部字段 Expires。 </p>
<h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p>首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。 HTTP/1.1 的传输编码方式仅对分块传输编码有效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK </span><br><span class="line">Date: Tue, 03 Jul 2012 04:40:56 GMT </span><br><span class="line">Cache-Control: public, max-age=604800 </span><br><span class="line">Content-Type: text/javascript; charset=utf-8</span><br><span class="line">Expires: Tue, 10 Jul 2012 04:40:56 GMT </span><br><span class="line">X-Frame-Options: DENY X-XSS-Protection: 1; mode=block </span><br><span class="line">Content-Encoding: gzip </span><br><span class="line">Transfer-Encoding: chunked </span><br><span class="line">Connection: keep-alive </span><br><span class="line">cf0    ←16进制(10进制为3312) </span><br><span class="line">...3312字节分块数据... </span><br><span class="line">392    ←16进制(10进制为914) </span><br><span class="line">...914字节分块数据... </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据</p>
<h4 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h4><p>首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的 版本进行通信，其参数值可以用来指定一个完全不同的通信协议。<br><img src="http://dengw.xyz/blog/180814/2hhFg4e9if.png?imageslim" alt="enter image description here"></p>
<p>上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两 个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。 Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务 器之间。因此，使用首部字段 Upgrade 时，还需要额外指定 <code>Connection:Upgrade</code>。 对于附有首部字段 Upgrade 的请求，服务器可用 101 Switching Protocols 状态码作为响应返回。</p>
<h4 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h4><p>使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文 的传输路径。</p>
<p>报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信 息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。</p>
<p>首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。 所以必须在经过代理时附加该首部字段内容。<br><img src="http://dengw.xyz/blog/180814/FbKhJEBha2.png?imageslim" alt="enter image description here"></p>
<p>上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0 gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如 此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服 务器信息。</p>
<p>Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使 用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中 Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况 下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响 应。</p>
<h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演 变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: 113 gw.hackr.jp:8080 &quot;Heuristic expiration&quot; Tue, 03 Jul 2012 </span><br></pre></td></tr></table></figure>
<p>Warning 首部的格式如下。最后的日期时间部分可省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])</span><br></pre></td></tr></table></figure>
<p>HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。 另外，警告码具备扩展性，今后有可能追加新的警告码。</p>
<p>HTTP/1.1 警告码<br><img src="http://dengw.xyz/blog/180814/9kfjGdCIb8.png?imageslim" alt="enter image description here"></p>
<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段， 用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p>
<h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p><img src="http://dengw.xyz/blog/180814/edHDf3hm1h.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.</span><br></pre></td></tr></table></figure>

<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体 类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒 体类型。</p>
<p>下面我们试举几个媒体类型的例子。</p>
<ul>
<li>文本文件<br>text/html, text/plain, text/css … application/xhtml+xml, application/xml …</li>
<li>图片文件<br>image/jpeg, image/gif, image/png …</li>
<li>视频文件<br>video/mpeg, video/quicktime …</li>
<li>应用程序使用的二进制文件<br>application/octet-stream, application/zip …</li>
</ul>
<p>比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定 image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。 </p>
<p>若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 1，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点 后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。</p>
<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><p><img src="http://dengw.xyz/blog/180814/ff5fad71C2.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</span><br></pre></td></tr></table></figure>
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字 段 Accept 相同的是可用权重 q 值来表示相对优先级。</p>
<p>该首部字段应用于内容协商机制的服务器驱动协商。</p>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p><img src="http://dengw.xyz/blog/180814/g6fJLcg1Jm.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure>
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及 内容编码的优先级顺序。可一次性指定多种内容编码。</p>
<p>下面试举出几个内容编码的例子。</p>
<ul>
<li>gzip<br>由文件压缩程序 gzip（GNU zip）生成的编码格式 （RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余 校验（Cyclic Redundancy Check，通称 CRC）。 </li>
<li>compress<br>由 UNIX 文件压缩程序 compress 生成的编码格式，采用 LempelZiv-Welch 算法（LZW）。</li>
<li>deflate 组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法 （RFC1951）生成的编码格式。 </li>
<li>identity<br>不执行压缩或不会变化的默认编码格式</li>
</ul>
<p>采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另 外，也可使用星号（*）作为通配符，指定任意的编码格式。</p>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3</span><br><span class="line">````</span><br><span class="line">首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然 语言集（指中文或英文等），以及自然语言集的相对优先级。可一次 指定多种自然语言集。</span><br><span class="line"></span><br><span class="line">和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图 例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版 对应的响应，没有中文版时，则请求返回英文版响应。 </span><br><span class="line"></span><br><span class="line">#### Authorization</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/lCihFcF7CJ.png?imageslim)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证 书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存 在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。</span><br><span class="line"></span><br><span class="line">#### Expect</span><br></pre></td></tr></table></figure>
<p>Expect: 100-continue</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行 为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回 状态码 417 Expectation Failed。 </span><br><span class="line"></span><br><span class="line">客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规 范只定义了 100-continue（状态码 100 Continue 之意）。 </span><br><span class="line"></span><br><span class="line">等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100continue。 </span><br><span class="line"></span><br><span class="line">#### From</span><br><span class="line">首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的 电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但 可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段 内）。</span><br><span class="line"></span><br><span class="line">#### Host</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/GkGBgE5gLB.png?imageslim)</span><br><span class="line">图：虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以 区分</span><br></pre></td></tr></table></figure>
<p>Host: <a target="_blank" rel="noopener" href="http://www.hackr.jp/">www.hackr.jp</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端 口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请 求内的首部字段。</span><br><span class="line"></span><br><span class="line">首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制 有很密切的关联，这是首部字段 Host 必须存在的意义。 </span><br><span class="line"></span><br><span class="line">请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解 决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务 器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部 字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直 接发送一个空值即可。如下所示。</span><br></pre></td></tr></table></figure>
<p>Host:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#### If-Match</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/8d828JcJK6.png?imageslim)</span><br><span class="line">附带条件请求</span><br><span class="line"></span><br><span class="line">形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/haFIJHdbC8.png?imageslim)</span><br><span class="line">图：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>If-Match: “123456”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用 的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。</span><br><span class="line"></span><br><span class="line">服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致 时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响 应。</span><br><span class="line"></span><br><span class="line">还可以使用星号（*）指定 If-Match 的字段值。针对这种情况，服务 器将会忽略 ETag 的值，只要资源存在就处理请求。 </span><br><span class="line"></span><br><span class="line">#### If-Modified-Since</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/3B3clL8Bc9.png?imageslim)</span><br><span class="line">图：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了 更新，服务器会接受请求</span><br></pre></td></tr></table></figure>
<p>If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 IfModified-Since 字段值早于资源的更新时间，则希望能处理该请求。 而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源 都没有过更新，则返回状态码 304 Not Modified 的响应。</span><br><span class="line"></span><br><span class="line"> If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。 获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确 定。</span><br><span class="line"></span><br><span class="line">#### If-None-Match</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/I8C1lchidL.png?imageslim)</span><br><span class="line">图：只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理 该请求。与 If-Match 首部字段的作用相反</span><br><span class="line"></span><br><span class="line">首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与 请求资源的 ETag 不一致时，它就告知服务器处理该请求。 </span><br><span class="line"></span><br><span class="line">在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资 源。因此，这与使用首部字段 If-Modified-Since 时有些类似。 </span><br><span class="line"></span><br><span class="line">#### If-Range</span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/fDA2m8E1gB.png?imageslim)</span><br><span class="line"></span><br><span class="line">首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 IfRange 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一 致时，则作为范围请求处理。反之，则返回全体资源。</span><br><span class="line"></span><br><span class="line">![enter image description here](http://dengw.xyz/blog/180814/eAkI5LiHHH.png?imageslim)</span><br><span class="line"></span><br><span class="line">下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器 端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当 然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412 Precondition Failed 作为响应返回，其目的是催促客户端再次发送请 求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的 功夫。</span><br><span class="line"></span><br><span class="line">#### If-Unmodified-Since</span><br><span class="line">````</span><br><span class="line">If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure>
<p>首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相 反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定 的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定 日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应 返回。</p>
<h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><p><img src="http://dengw.xyz/blog/180814/bKi3fcK210.png?imageslim" alt="enter image description here"><br>图：每次转发数值减 1。当数值变 0 时返回响应</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forwards: 10</span><br></pre></td></tr></table></figure>
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最 大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的 值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求 时，则不再进行转发，而是直接返回响应。</p>
<p>使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中， 如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到 服务器返回的响应了。对此，我们无从可知。</p>
<p>可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展 开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回 响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状 况有所把握。<br><img src="http://dengw.xyz/blog/180814/2bBGldEkff.png?imageslim" alt="enter image description here"></p>
<p>图：代理 B 到源服务器的请求失败了，但客户端不知道<br><img src="http://dengw.xyz/blog/180814/FB6KL0eLjK.png?imageslim" alt="enter image description here"><br>图：由于未知原因，导致请求陷入代理之间的循环，但客户端不 知道</p>
<h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。 </p>
<p>这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同 之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间 的认证，使用首部字段 Authorization 可起到相同作用。</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure>
<p>对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服 务器资源的指定范围。</p>
<p>上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状 态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返 回状态码 200 OK 的响应及全部资源。</p>
<h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p><img src="http://dengw.xyz/blog/180814/e9b450hJ3I.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://www.hackr.jp/index.htm</span><br></pre></td></tr></table></figure>
<p>首部字段 Referer 会告知服务器请求的原始资源的 URI。 客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器 的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字 段。</p>
<p>因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信 息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的 泄露。</p>
<p>另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直 沿用这个错误的拼写。</p>
<h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate;q=0.5</span><br></pre></td></tr></table></figure>
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相 对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于 传输编码。</p>
<p>首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分 块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: trailers</span><br></pre></td></tr></table></figure>

<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010</span><br></pre></td></tr></table></figure>
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传 达给服务器。</p>
<p>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件 地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服 务器的名称。 </p>
<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段， 用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p>
<h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><p><img src="http://dengw.xyz/blog/180814/H1f57jFldI.png?imageslim" alt="enter image description here"><br>图：当不能处理范围请求时，Accept-Ranges: none</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>
<p>首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请 求，以指定获取服务器端某个部分的资源。</p>
<p>可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则 指定其为 none。 </p>
<h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><p><img src="http://dengw.xyz/blog/180814/8C1Fb7gCGF.png?imageslim" alt="enter image description here"></p>
<p>首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值 的单位为秒。</p>
<p>若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次 发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。 </p>
<h4 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h4><p><img src="http://dengw.xyz/blog/180814/H5DGaBaIG7.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;82e22293907ce725faf67773957acd12&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串 形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。</p>
<p>另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有 统一的算法规则，而仅仅是由服务器来分配</p>
<p><img src="http://dengw.xyz/blog/180814/bf6ClBl94A.png?imageslim" alt="enter image description here"></p>
<p>资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览 器访问 <a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com/</a> 时，就会返回中文版对应的资源，而 使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的 URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下 载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。</p>
<p>强 ETag 值和弱 Tag 值 : ETag 中有强 ETag 值和弱 ETag 值之分。 </p>
<ul>
<li><p>强 ETag 值<br>强 ETag 值，不论实体发生多么细微的变化都会改变其值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>弱 ETag 值<br>弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产 生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: W/&quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p><img src="http://dengw.xyz/blog/180814/EgblJ49c5k.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.usagidesign.jp/sample.html</span><br></pre></td></tr></table></figure>
<p>使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置 不同的资源。</p>
<p>基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI。 几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强 制性地尝试对已提示的重定向资源的访问。</p>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure>

<p>首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送 给客户端。</p>
<p>它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在 于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间 进行认证时，首部字段 WWW-Authorization 有着相同的作用。</p>
<h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><p><img src="http://dengw.xyz/blog/180814/9gDiD7A7ih.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 120</span><br></pre></td></tr></table></figure>
<p>首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要 配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使 用。</p>
<p>字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24 GMT 等格式），也可以是创建响应后的秒数。 </p>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><img src="http://dengw.xyz/blog/180814/8DgmmKBdla.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache/2.2.17 (Unix)</span><br></pre></td></tr></table></figure>
<p>首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程 序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版 本号和安装时启用的可选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache/2.2.6 (Unix) PHP/5.2.5</span><br></pre></td></tr></table></figure>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><p><img src="http://dengw.xyz/blog/180814/fFE3hbf2FE.png?imageslim" alt="enter image description here"><br>图：当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓 存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure>
<p>首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关 于本地缓存使用方法的命令。</p>
<p>从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若 再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回 缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相 同，因此必须要从源服务器重新获取资源。</p>
<h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authenticate: Basic realm=&quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure>
<p>首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端 适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和 带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中， 肯定带有首部字段 WWW-Authenticate。 </p>
<p>上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。</p>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><p><img src="http://dengw.xyz/blog/180814/cif77Ghaj5.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure>
<p>首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所 有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支 持的 HTTP 方法写入首部字段 Allow 后返回。 </p>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip`</span><br></pre></td></tr></table></figure>
<p>首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p>
<p>主要采用以下 4 种内容编码的方式。（各方式的说明请参考请求首部字段中 Accept-Encoding 字段）。</p>
<ul>
<li>gzip</li>
<li>compress</li>
<li> deflate</li>
<li> identity </li>
</ul>
<h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure>
<p>首部字段 Content-Language 会告知客户端，实体主体使用的自然语言 （指中文或英文等语言）。</p>
<h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Length: 15000</span><br></pre></td></tr></table></figure>
<p>首部字段 Content-Length 表明了实体主体部分的大小（单位是字 节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。</p>
<h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Location: http://www.hackr.jp/index-ja.html</span><br></pre></td></tr></table></figure>
<p>首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。 比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当 返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 <a target="_blank" rel="noopener" href="http://www.hackr.jp/">http://www.hackr.jp/</a> 返回的对象却是 <a target="_blank" rel="noopener" href="http://www.hackr.jp/index-ja.html">http://www.hackr.jp/index-ja.html</a> 等类似情况） </p>
<h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><p><img src="http://dengw.xyz/blog/180814/c70A6j3A9F.png?imageslim" alt="enter image description here"><br>图：客户端会对接收的报文主体执行相同的 MD5 算法，然后与首 部字段 Content-MD5 的字段值比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure>
<p>首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检 查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
<p>对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编 码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进 制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接 收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。</p>
<p>采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出 恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味 着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户 端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过 的。</p>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p><img src="http://dengw.xyz/blog/180814/6FhfB3241j.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure>
<p>针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客 户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为 单位，表示当前发送部分及整个实体大小。</p>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>
<p>首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字 段 Accept 一样，字段值用 type/subtype 形式赋值。 </p>
<p>参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。 </p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><img src="http://dengw.xyz/blog/180814/jHg7ekA857.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>
<p>首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接 收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过 指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求 资源。</p>
<p>源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。 </p>
<p>但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字 段 Expires，会优先处理 max-age 指令。 </p>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p><img src="http://dengw.xyz/blog/180814/Ki1fECLmfD.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure>
<p>首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个 值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进 行动态数据处理时，该值有可能会变成数据最终修改时的时间。 </p>
<h3 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h3><p>上面列的这些首部字段都是被编入标准化 HTTP/1.1 的 RFC2616 中的字段，但是还有一些很重要的，经常使用的，却没有列入该标准的字段，管理服务器与客户端之间状态的 Cookie 就包括了这些字段。</p>
<p>Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的 状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。 </p>
<p>调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路 径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。<br>为 Cookie 服务的首部字段包括：</p>
<ul>
<li>Set-Cookie：开始状态管理所使用的Cookie信息，是一种响应首部字段 </li>
<li>Cookie：服务器接收到的Cookie信息，是一种请求首部字段</li>
</ul>
<h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path</span><br></pre></td></tr></table></figure>
<p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p>
<p>下面的表格列举了 Set-Cookie 的字段值。<br>| 属性 | 说明 |<br>| :——– | :——– |<br>| NAME=VALUE | 赋予 Cookie 的名称和其值（必需项）|<br>| expires=DATE | Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）|<br>| path=PATH | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默 认为文档所在的文件目录）|<br>| domain=域名 | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名）|<br>| Secure | 仅在 HTTPS 安全通信时才会发送 Cookie |<br>| HttpOnly | 加以限制，使 Cookie 不能被 JavaScript 脚本访问 |</p>
<ul>
<li>expires 属性</li>
</ul>
<p>Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。 </p>
<p>当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session） 时间段内。这通常限于浏览器应用程序被关闭之前。</p>
<p>另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可 以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对 客户端 Cookie 的实质性删除操作。</p>
<ul>
<li>path 属性</li>
</ul>
<p>Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。 不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱 有期待。</p>
<ul>
<li>domain 属性 </li>
</ul>
<p>通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比 如，当指定 example.com 后，除 example.com 以外，<a target="_blank" rel="noopener" href="http://www.example.com/">www.example.com</a> 或 www2.example.com 等都可以发送 Cookie。 </p>
<p>因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定 domain 属性显得更安全。</p>
<ul>
<li>secure 属性 </li>
</ul>
<p>Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才 可以发送 Cookie。</p>
<p>发送 Cookie 时，指定 secure 属性的方法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=value; secure</span><br></pre></td></tr></table></figure>
<p>以上例子仅当在 <a target="_blank" rel="noopener" href="https://www.example.com/%EF%BC%88HTTPS%EF%BC%89%E5%AE%89%E5%85%A8%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5">https://www.example.com/（HTTPS）安全连接的情况</a> 下才会进行 Cookie 的回收。也就是说，即使域名相同， <a target="_blank" rel="noopener" href="http://www.example.com/%EF%BC%88HTTP%EF%BC%89%E4%B9%9F%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F">http://www.example.com/（HTTP）也不会发生</a> Cookie 回收行为。 </p>
<p>当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行 回收。</p>
<ul>
<li>HttpOnly 属性 </li>
</ul>
<p>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本 无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。 </p>
<p>发送指定 HttpOnly 属性的 Cookie 的方法如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=value; HttpOnly</span><br></pre></td></tr></table></figure>
<p>通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。 但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后 的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持 Cookie 了。</p>
<p> 虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的 主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了 防止 XSS 而开发的。 </p>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure>
<p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支 持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/14/%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E7%AC%AC%E4%BA%94%E7%AB%A0/" data-id="ckqm6kpnp007lxxr598s49qt9" data-title="图解HTTP学习笔记—第五章" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树三种遍历方式的Java实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2018-08-10T06:53:09.000Z" itemprop="datePublished">2018-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/">二叉树三种遍历方式的Java实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>之前学习数据结构的时候使用过 C++ 实现过二叉树的三种遍历方法，其中包括递归实现和非递归实现。现在在准备秋招，感觉这部分还是非常重要的，就想用 java 再实现一下。</p>
<p>这里就不再对什么是现需、中序和后序遍历解释了，着重代码实现，一些重要的代码会给出注释。</p>
<p>树的节点定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	TreeNode left = <span class="keyword">null</span>;</span><br><span class="line">	TreeNode right = <span class="keyword">null</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><h5 id="实现方法1"><a href="#实现方法1" class="headerlink" title="实现方法1"></a>实现方法1</h5><p>　　根据前序遍历访问的顺序，优先访问根结点，然后再分别访问左孩子和右孩子。即对于任一结点，其可看做是根结点，因此可以直接访问，访问完之后，若其左孩子不为空，按相同规则访问它的左子树；当访问其左子树时，再访问它的右子树。因此其处理过程如下：</p>
<p>　　对于任一结点P：</p>
<ol>
<li>访问结点P，并将结点P入栈;</li>
<li>判断结点P的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点P，循环至1);若不为空，则将P的左孩子置为当前的结点P;</li>
<li>直到P为NULL并且栈为空，则遍历结束。</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrder1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode tem = root;</span><br><span class="line">    <span class="keyword">while</span>(tem != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>( tem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(tem.val);</span><br><span class="line">            stack.push(tem);</span><br><span class="line">            tem = tem.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack.empty()) &#123;</span><br><span class="line">            tem = stack.pop();</span><br><span class="line">            tem = tem.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实现方法2"><a href="#实现方法2" class="headerlink" title="实现方法2"></a>实现方法2</h5>这就是充分利用栈的特点了，体会一下先进后出的体现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历的非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrder2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode tem;</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty()) &#123;    <span class="comment">// 进入循环的条件是栈不为空</span></span><br><span class="line">        tem = stack.pop();     <span class="comment">// 获取并弹出栈顶元素</span></span><br><span class="line">        res.add(tem.val);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 注意因为使用的是栈结构，先入后出,</span></span><br><span class="line"><span class="comment">         * 所以先把右边的节点入栈</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (tem.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tem.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tem.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tem.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>递归就很简单了，直接在代码层面就可以体现出前序遍历的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">preOrder_recursion</span><span class="params">(TreeNode root)</span>  </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始递归调用</span></span><br><span class="line">    preOrder_recursion_body(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder_recursion_body</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        preOrder_recursion_body(root.left, res);</span><br><span class="line">        preOrder_recursion_body(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><h4 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h4><h5 id="实现方法1-1"><a href="#实现方法1-1" class="headerlink" title="实现方法1"></a>实现方法1</h5><p>　　根据中序遍历的顺序，对于任一结点，优先访问其左孩子，而左孩子结点又可以看做一根结点，然后继续访问其左孩子结点，直到遇到左孩子结点为空的结点才进行访问，然后按相同的规则访问其右子树。因此其处理过程如下：</p>
<p>　　对于任一结点P: </p>
<ol>
<li>若其左孩子不为空，则将P入栈并将P的左孩子置为当前的P，然后对当前结点P再进行相同的处理；</li>
<li>若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的P置为栈顶结点的右孩子；</li>
<li>直到P为NULL并且栈为空则遍历结束。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">inOrder1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode tem = root;</span><br><span class="line">    <span class="keyword">while</span>(tem != <span class="keyword">null</span> || !stack.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(tem != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tem);</span><br><span class="line">            tem = tem.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!stack.empty()) &#123;</span><br><span class="line">            tem = stack.pop();</span><br><span class="line">            res.add(tem.val);</span><br><span class="line">            tem = tem.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实现方法2-1"><a href="#实现方法2-1" class="headerlink" title="实现方法2"></a>实现方法2</h5>跟上面的思路类似，只是实现方式有点区别。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">inOrder2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;    <span class="comment">//一直遍历左节点</span></span><br><span class="line">            stack.push(temp.left);</span><br><span class="line">            temp.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode p = stack.pop();</span><br><span class="line">            res.add(p.val);</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h4>很形象了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">inOrder_recursion</span><span class="params">(TreeNode root)</span>  </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    inOrder_recursion_body(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder_recursion_body</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        inOrder_recursion_body(root.left, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        inOrder_recursion_body(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><h4 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h4><p>思路: 要保证根结点在其左孩子和右孩子访问之后才能访问，因此对于任一结点p，先将其入栈。如果 p 不存在左孩子和右孩子（左子树和右子树都指向空的时候），则可直接访问；否则将 p 的右孩子和左孩子依次入栈然后把 p 的左右孩子结点赋值null，这样就保证了每次取栈顶的元素的时候左孩子在右孩子前面被访问, 左孩子和右孩子都在根结点前面被访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历的非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        temp = stack.peek();</span><br><span class="line">        <span class="keyword">if</span> (temp.left == <span class="keyword">null</span> &amp;&amp; temp.right == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode pop = stack.pop();</span><br><span class="line">            res.add(pop.val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(temp.right);</span><br><span class="line">                temp.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(temp.left);</span><br><span class="line">                temp.left = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">postOrder_recursion</span><span class="params">(TreeNode root)</span>  </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    postOrder_recursion_body(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder_recursion_body</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrder_recursion_body(root.left, res);</span><br><span class="line">        postOrder_recursion_body(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/10/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E7%9A%84Java%E5%AE%9E%E7%8E%B0/" data-id="ckqm6kplq002ixxr53dyth80o" data-title="二叉树三种遍历方式的Java实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-剑指Offer刷题总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/09/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-08-09T15:50:11.000Z" itemprop="datePublished">2018-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/09/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/">剑指Offer刷题总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>今天开始刷算法题了，本来想刷LeetCode上面的题的，但是想到时间比较紧，LeetCode上的题太多了，剑指Offer上面的66道题涵盖的题型也比较全，对付秋招应该足够了，本博客主要记录一下自己的答案，如果有什么比较新奇的想法的话也记录一下，希望能有收获。</p>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>第一天刷了4道题，还是挺快的，前3道都是十分钟之内AC，第4题花的时间稍长一点。</p>
<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = array.length;</span><br><span class="line">        <span class="keyword">int</span> n = array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[i][j] &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        String strs = str.toString();</span><br><span class="line">        <span class="keyword">return</span> strs.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用了一个比较巧妙的方法，直接只用 java 中 String 类的 replaceAll 函数，作用是将一个字符串中某个字符串用另外一个字符串代替。</p>
<h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)  &#123;</span><br><span class="line">            list.add(<span class="number">0</span>, listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">        TreeNode root = run(pre, 0, pre.length - 1, in, 0, pre.length - 1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        public static TreeNode run(int [] pre, int pl, int pr, int [] in, int il, int ir) &#123;</span><br><span class="line">        if(pl &gt; pr || il &gt; ir) return null;</span><br><span class="line">        TreeNode node = new TreeNode(pre[pl]);</span><br><span class="line">        int i;</span><br><span class="line">        for(i = il; i&lt;= ir; i++) &#123;</span><br><span class="line">            if(pre[pl] == in[i]) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = i - il;</span><br><span class="line">        node.left = run(pre, pl + 1, pl + len, in, il, i - 1);</span><br><span class="line">        node.right = run(pre, pl + len + 1, pr, in, i + 1, ir);</span><br><span class="line">        </span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先求出根节点（前序序列第一个元素）。</li>
<li>将根节点带入到中序遍历序列中求出左右子树的中序遍历序列。</li>
<li>通过左右子树的中序序列元素集合带入前序遍历序列可以求出左右子树的前序序列。</li>
<li>左右子树的前序序列第一个元素分别是根节点的左右儿子</li>
<li>求出了左右子树的4种序列可以递归上述步骤</li>
</ol>
<h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>今天没什么事就多做了几道题，总的来说不难，花的时间都不多，不过还是发现了问题，个人对java中的引用感觉还不是很熟悉，感觉和 C++ 中的指针挺像的，在链表中结构中两个对象赋值传递还分不太清楚，还需要额外花一点时间练习一下。</p>
<h3 id="用两个栈来实现一个队列"><a href="#用两个栈来实现一个队列" class="headerlink" title="用两个栈来实现一个队列"></a>用两个栈来实现一个队列</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size() &gt; <span class="number">0</span>) <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接把stack1当作队列尾，stack2当作队列头，具体的做法就是添加元素的时候直接加到stack1中，取出元素的时候做一个判断，如果stack2中没有元素的话就把stack1中的所有元素倒腾到stack2中，如果stack2中还有元素的话就直接pop栈顶部的元素。</p>
<h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] &gt; array[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题时间复杂度为 O(N) 的方法有很多，一种方法就是直接查找数组的最小数字即可。但是为了使用到旋转数组的特点，我们知道一个旋转数组套么就是一个非完全递增数组，要么就是两个非完全递增数组组合起来的并且前一个数组的每一个值都大于后面一个数组的值，利用这个特点构建算法。</p>
<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>; <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = a;</span><br><span class="line">            a += b;</span><br><span class="line">            b = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>f(n) = f(n - 1) + f(n - 2)</p>
<p>###跳台阶</p>
<h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = a;</span><br><span class="line">            a += b;</span><br><span class="line">            b = tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>斐波那契数列的应用</p>
<h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int jumpFloorII(int number) &#123;</span><br><span class="line">        if(number == 1) return 1;</span><br><span class="line">        return 2 * jumpFloorII(number- 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>f(0) = 1;<br>f(1) = f(0);<br>f(2) = f(0) + f(1) ;<br>f(3) = f(0) + f(1) + f(2);<br>….<br>f(n - 1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2);<br>f(n) = f(0) + f(1) + f(2) + f(3) +…+ f(n-2) + f(n - 1) = f(n - 1) + f(n - 1) = 2 f(n - 1);</p>
<h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><h4 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h4><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>) <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">return</span> rectCover(number-<span class="number">1</span>) + rectCover(number-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>斐波那契数列的应用</p>
<h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><h4 id="描述-10"><a href="#描述-10" class="headerlink" title="描述"></a>描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位运算，想通了就很简单了</p>
<h3 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h3><h4 id="描述-11"><a href="#描述-11" class="headerlink" title="描述"></a>描述</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                list2.add(array[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list1.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = list1.size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            array[i] = list1.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            array[i + n] = list2.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表中倒数第k个结点"><a href="#链表中倒数第k个结点" class="headerlink" title="链表中倒数第k个结点"></a>链表中倒数第k个结点</h3><h4 id="描述-12"><a href="#描述-12" class="headerlink" title="描述"></a>描述</h4><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;ListNode&gt; list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            list.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; k) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((k - <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            list.pop();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><h4 id="描述-13"><a href="#描述-13" class="headerlink" title="描述"></a>描述</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// pre和pos分别为链表翻转前head的前一个节点和后一个节点</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>, pos;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pos = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><h4 id="描述-14"><a href="#描述-14" class="headerlink" title="描述"></a>描述</h4><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则</p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><ul>
<li>递归版本<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        ListNode head;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">            list1.next = Merge(list1.next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>非递归版本<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">    ListNode tem = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head = tem;</span><br><span class="line">    <span class="keyword">while</span>(list1 != <span class="keyword">null</span> || list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tem.next = list2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tem.next = list1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">                tem.next = list1;</span><br><span class="line">                tem = tem.next;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tem.next = list2;</span><br><span class="line">                tem = tem.next;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
重点注意一下这种操作对象引用进行传递的方法。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/09/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" data-id="ckqm6kplz0033xxr51br4f2pd" data-title="剑指Offer刷题总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag">剑指Offer</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java泛型总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/08/01/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-08-01T06:34:47.000Z" itemprop="datePublished">2018-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/08/01/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/">Java泛型总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>贴几篇博客，介绍的很详细，也就不增加学习成本了</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000005179142">Java 泛型总结（一）：基本用法与类型擦除</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000005179147">Java 泛型总结（二）：泛型与数组</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000005337789">Java 泛型总结（三）：通配符的使用</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/s10461/article/details/53941091">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/08/01/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/" data-id="ckqm6kpl5000sxxr5aw00cpat" data-title="Java泛型总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-结合反射机制理解动态代理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/31/%E7%BB%93%E5%90%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2018-07-31T06:23:37.000Z" itemprop="datePublished">2018-07-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/31/%E7%BB%93%E5%90%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">结合反射机制理解动态代理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>先给一个动态代理的实例，按照下面这种姿势来使用动态调用，可以很好地体现出动态调用的特性。</p>
<p>先定义两个父接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sub1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub1Act</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sub2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub2Act</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个父接口各自的实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSub1</span> <span class="keyword">implements</span> <span class="title">Sub1</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub1Act</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;act2 of sub1 in realSub1：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSub2</span> <span class="keyword">implements</span> <span class="title">Sub2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub2Act</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;act2 of sub2 in realSub2：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(subject.getClass().getClassLoader(),</span><br><span class="line">                subject.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(subject, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DynamicProxy proxy = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理Sub1</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理Sub1接口&quot;</span>);</span><br><span class="line">        Sub1 obj1 = (Sub1) proxy.newProxyInstance(<span class="keyword">new</span> RealSub1());</span><br><span class="line">        System.out.println(obj1.getClass().getName());</span><br><span class="line">        obj1.sub1Act(<span class="string">&quot;参数 for sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 代理 Sub2</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代理Sub2接口&quot;</span>);</span><br><span class="line">        Sub2 obj2 = (Sub2) proxy.newProxyInstance(<span class="keyword">new</span> RealSub2());</span><br><span class="line">        System.out.println(obj2.getClass().getName());</span><br><span class="line">        obj2.sub2Act(<span class="string">&quot;参数 for sub2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h3><p>每一个动态代理类都必须要实现 InvocationHandler 这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由 InvocationHandler 这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">	<span class="keyword">throws</span> Throwable</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数 proxy：代理类实例，<strong>注意这里不是被代理类</strong>，很容易用错</li>
<li>第二个参数 method：被调用的方法</li>
<li>第三参数 args： method 方法的参数</li>
</ul>
<h3 id="Proxy类"><a href="#Proxy类" class="headerlink" title="Proxy类"></a>Proxy类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>loader：加载代理对象的类加载器</li>
<li>interfaces：一个Interface对象的数组，表示将要给需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法</li>
<li>InvocationHandler 对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler 对象上</li>
</ul>
<h3 id="动态代理过程分析"><a href="#动态代理过程分析" class="headerlink" title="动态代理过程分析"></a>动态代理过程分析</h3><p>我们先看一下上面的 Main 方法的输出结果，然后根据结果分析动态代理的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理Sub1接口</span><br><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">act2 of sub1 in realSub1：参数 for sub1</span><br><span class="line"></span><br><span class="line">代理Sub2接口</span><br><span class="line">com.sun.proxy.$Proxy1</span><br><span class="line">act2 of sub2 in realSub2：参数 for sub2</span><br></pre></td></tr></table></figure>

<p>首先看看<code>com.sun.proxy.$Proxy0</code>和<code>com.sun.proxy.$Proxy1</code>，通过 Proxy.newProxyInstance 创建的代理对象是在 jvm 运行时动态生成的一个对象，它并不是我们的 InvocationHandler 类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p>
<p>然后我们再思考一个问题：为什么我们这里可以将 Proxy.newProxyInstance 创建的对象转化为 Sub1  类型或者 Sub2类型的对象呢？原因就是在 newProxyInstance 这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是被代理类类型的，所以就可以将其转化为被代理类的类型。</p>
<p>然后当我们使用  Proxy.newProxyInstance 创建的代理对象来调用被代理类的方法时，会告诉 InvocationHandler 具体执行哪一个函数，然后在 InvocationHandler 内部的 invoke方法，通过反射执行真实对象的该方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/31/%E7%BB%93%E5%90%88%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" data-id="ckqm6kpmh004hxxr561it57e8" data-title="结合反射机制理解动态代理" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java类加载之类加载器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2018-07-30T06:51:57.000Z" itemprop="datePublished">2018-07-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">Java类加载之类加载器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在前面介绍类加载过程中的加载步骤时提到“通过一个类的全限定名来获取描述此类的二进制字节流‘，这个操作就是类加载器完成的。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确定其在 Java 虚拟机中的唯一性，每一个类加载器都有唯一的标识，拥有一个独立的类名称空间。要比较两个类是否”相等“，只有在这两个类是由同一个类加载器加载的前提下才有意义。不然，即使两个类源于同一个Class文件，这两个类也不相等。</p>
<p>注：这里说的相等包括类的 Class 对象的 equals() 方法、isAssignableFrom()方法、isInstance() 方法返回的结果。</p>
<h3 id="类加载器的层次结构—双亲委派模型"><a href="#类加载器的层次结构—双亲委派模型" class="headerlink" title="类加载器的层次结构—双亲委派模型"></a>类加载器的层次结构—双亲委派模型</h3><h4 id="启动（Bootstrap）类加载器"><a href="#启动（Bootstrap）类加载器" class="headerlink" title="启动（Bootstrap）类加载器"></a>启动（Bootstrap）类加载器</h4><p>启动类加载器主要加载的是 JVM 自身需要的类，它负责将 <code>&lt;JAVA_HOME&gt;/lib</code>路径下的核心类库或 -Xbootclasspath 参数指定的路径下的 jar 包加载到内存中，注意必须是由虚拟机按照文件名识别加载 jar 包的，如rt.jar，我们非常熟悉的 Object 类就位于 rt.jar 包中。如果文件名不被虚拟机识别，名字不符合的即使把 jar 包丢到 lib 目录下也不会被加载(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。启动类加载器无法被 java 程序直接打开。</p>
<h4 id="扩展（Extension）类加载器"><a href="#扩展（Extension）类加载器" class="headerlink" title="扩展（Extension）类加载器"></a>扩展（Extension）类加载器</h4><p>扩展类加载器是指 Sun 公司实现的 sun.misc.Launcher$ExtClassLoader 类，由 Java 语言实现的，是 Launcher 的静态内部类，它负责加载<code>&lt;JAVA_HOME&gt;/lib/ext</code>目录下或者由系统变量 -Djava.ext.dir 指定位路径中的类库。开发者可以直接使用扩展类加载器。</p>
<h4 id="系统（System）类加载器"><a href="#系统（System）类加载器" class="headerlink" title="系统（System）类加载器"></a>系统（System）类加载器</h4><p>也称应用程序加载器，是由 Sun 公司实现的 sun.misc.Launcher$AppClassLoader 。它负责加载系统类路径 java -classpath 或 -D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过 ClassLoader#getSystemClassLoader() 方法可以获取到该类加载器。 </p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>Java 应用程序的加载几乎是由上述 3 种类加载器相互配合执行的，如果有必要，我们还可以自定义类加载器，需要注意的是，Java 虚拟机对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成 class 对象。加载某个具体类的 class 文件时，Java 虚拟机采用的是双亲委派模型，下面我们进一步了解它。</p>
<p><img src="http://dengw.xyz/blog/180731/5gE6ld6BCe.png?imageslim" alt="enter image description here"></p>
<p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。除了顶层的类加载器之外，其余的类加载器都有自己的父类加载器。</p>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是 Java 类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证 Java 程序的稳定运作很重要。例如，类java.lang.Object 类存放在 JDK\jre\lib 下的 rt.jar 之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了 Object 类在程序中的各种类加载器中都是同一个类。</p>
<h4 id="双亲委派模型的优点"><a href="#双亲委派模型的优点" class="headerlink" title="双亲委派模型的优点"></a>双亲委派模型的优点</h4><p>双亲委派模型使 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父类加载器已经加载了该类时，就没有必要让子类加载器再加载一次。其次是考虑到安全因素，java核心 api 中定义类型不会被随意替换，假设通过网络传递一个名为 java.lang.Integer 的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的 java.lang.Integer，而直接返回已加载过的 Integer.class，这样便可以防止核心API库被随意篡改。</p>
<h4 id="双亲委派模型的代码实现"><a href="#双亲委派模型的代码实现" class="headerlink" title="双亲委派模型的代码实现"></a>双亲委派模型的代码实现</h4><p><img src="http://dengw.xyz/blog/180731/LLj42C2HIi.png?imageslim" alt="enter image description here"></p>
<p>从图可以看出顶层的类加载器是一个抽象类，其后所有的类加载器都继承自该类加载器（不包括启动类加载器），我们介绍一下几个比较重要的方法。</p>
<ul>
<li>loadClass(String)<br>该方法加载指定名称（包括包名）的二进制类型，该方法在JDK1.2之后不再建议用户重写但用户可以直接调用该方法，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，其源码如下，loadClass(String name, boolean resolve)是一个重载方法，resolve参数代表是否生成class对象的同时进行解析相关操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">      <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 先从缓存查找该class对象，找到就不用重新加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果找不到，则委托给父类加载器去加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果没有父类，则委托给启动加载器去加载</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// 如果都没有找到，则通过自定义实现的findClass去查找并加载</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否需要在加载时进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>findClass(String)<br>在JDK1.2之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖 loadClass() 方法，而是建议<strong>把自定义的类加载逻辑写在 findClass() 方法中</strong>，从前面的分析可知，findClass() 方法是在 loadClass() 方法中被调用的，当 loadClass() 方法中父加载器加载失败后，则会调用自己的 findClass() 方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。需要注意的是 ClassLoader 类中并没有实现 findClass() 方法的具体代码逻辑，取而代之的是抛出 ClassNotFoundException 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法一起使用的，ClassLoader类中findClass()方法源码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接抛出异常</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>defineClass(byte[] b, int off, int len)<br>defineClass() 方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象**(ClassLoader中已实现该方法逻辑)**，通过这个方法不仅能够通过 class 文件实例化 class 对象，也可以通过其他方式实例化 class 对象，如通过网络接收一个类的字节码，然后转换为 byte 字节流创建对应的 Class 对象，defineClass() 方法通常与 findClass() 方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖 ClassLoader 的 findClass() 方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用 defineClass()方法生成类的Class对象，简单例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="comment">// 获取类的字节数组</span></span><br><span class="line">      <span class="keyword">byte</span>[] classData = getClassData(name);  </span><br><span class="line">      <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">          <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果直接调用defineClass()方法生成类的Class对象，这个类的Class对象并没有解析(也可以理解为链接阶段，毕竟解析是链接的最后一步)，其解析操作需要等待初始化阶段进行。</p>
</li>
<li><p>resolveClass(Class≺?≻ c)<br>使用该方法可以使用类的Class对象创建完成也同时被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
</li>
</ul>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>一个比较好的自定义类加载器的实践就是直接继承 URLClassLoader 类，URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节码流等功能，在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p>需要注意的是如果我们在定义类加载器时选择继承 ClassLoader 类而非 URLClassLoader，必须手动编写 findclass() 方法的加载逻辑以及获取字节码流的逻辑。</p>
<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><img src="http://dengw.xyz/blog/180731/54f3593fm9.png?imageslim" alt="enter image description here"></p>
<p>从类图结构看出 URLClassLoader 内部存在一个 URLClassPath 类，通过这个类就可以找到要加载的字节码流，也就是说 URLClassPath 类负责找到要加载的字节码，再读取成字节流，最后通过 defineClass() 方法创建类的Class对象。从 URLClassLoader 类的结构图可以看出其构造方法都有一个必须传递的参数 URL[]，该参数的元素是代表字节码文件的路径，换句话说在创建 URLClassLoader 对象时必须要指定这个类加载器到哪个目录下找 class 文件。同时也应该注意 URL[] 也是 URLClassPath 类的必传参数，在创建 URLClassPath 对象时，会根据传递过来的 URL 数组中的路径判断是文件还是 jar 包，然后根据不同的路径创建 FileLoader 或者 JarLoader 或默认 Loader 类去加载相应路径下的 class 文件，而当 JVM 调用 findClass() 方法时，就由这3个加载器中的一个将 class 文件的字节码流加载到内存中，最后利用字节码流创建类的 class 对象。</p>
<p>下面是一些需要自定义类加载器场景：</p>
<ul>
<li><p>当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。</p>
</li>
<li><p>当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。</p>
</li>
<li><p>当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。</p>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/javazejian/article/details/73413292">大部分内容从这儿搬的： 深入理解Java类加载器(ClassLoader)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/30/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" data-id="ckqm6kpl80011xxr55b1jh36f" data-title="Java类加载之类加载器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类加载</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java类加载之类加载过程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2018-07-28T06:51:43.000Z" itemprop="datePublished">2018-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">Java类加载之类加载过程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>现在还记得春招的时候有一个面试官问过我一个问题：你了解过Java的类加载过程吗？</p>
<p>现在来看觉得当初自己答得并不是很好，如果现在让我来回答这个问题，我想这样回答应该还算比较满意。</p>
<p>首先，我们写好一个 java 程序，从编码到最终的执行，一般包括两个过程：编译和运行。</p>
<p>编译阶段的主要任务就是把我们写好的 java 代码通过 javac 命令编译成字节码，输出保存到一个 <code>.class</code> 文件。<br>运行阶段就是 jvm 虚拟机把<code>.class</code>文件执行并输出最终的结果。一个类从被加载到 JVM 中开始到最后卸载，整个生命周期包括：加载、验证、准备、解析、初始化、使用以及卸载七个阶段。</p>
<p>而类加载过程就是指在运行阶段 JVM 虚拟机把 .class 文件中类信息加载进内存，并进行解析生成对应的 class 对象的过程，包括：加载、链接、初始化三个步骤。</p>
<ul>
<li><p>加载：类加载过程的第一个阶段，通过一个类的完全限定符查找此类字节码文件，并利用字节码文件创建一个Class对象。</p>
</li>
<li><p>链接：验证字节码的安全性和完整性，准备阶段正式为静态域分配存储空间，注意此时只是分配静态成员变量的存储空间，不包含实例成员变量，如果必要的话，解析这个类创建的对其他类的所有引用。</p>
</li>
<li><p>初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量。</p>
</li>
</ul>
<p><img src="http://dengw.xyz/blog/180730/9C2a0DbBB6.png?imageslim" alt="enter image description here"></p>
<p>下面就详细分析一下整个过程。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在 Java 堆中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>注意，这里第 1 条中的二进制字节流并不只是单纯地从 Class 文件中获取，比如它还可以从 Jar 包中获取、从网络中获取（最典型的应用便是 Applet）、由其他文件生成（JSP 应用）等。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。关于类加载器的介绍将放在本系列的第三篇博客<a target="_blank" rel="noopener" href="https://www.dengw.xyz/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">Java类加载之类加载器</a>中详细介绍。</p>
<p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中也创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>从上面画的图可以看出，链接又可以分为：验证、准备、解析三个步骤。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>验证阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<h5 id="文件格式的验证"><a href="#文件格式的验证" class="headerlink" title="文件格式的验证"></a>文件格式的验证</h5><p>这一阶段主要验证字节流是否符合 Class 文件格式的规范，验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，可能包括以下验证点：</p>
<ul>
<li>魔数是否以 0xCAFFBABE 开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量和不符合类型的常量</li>
<li>CONSTRANT_Utf8_info 型的常量是否有不符合 Utf8 编码的数据</li>
<li>Class 文件中的各个部分及其文件本身是否有被删除的或者附加的信息<br>……</li>
</ul>
<h5 id="元数据的验证"><a href="#元数据的验证" class="headerlink" title="元数据的验证"></a>元数据的验证</h5><p>这一阶段是对字节码描述的信息进行<strong>语义分析</strong>，以保证不存在不符合 Java 语言规范的元数据信息。这个阶段可能的验证点如下：</p>
<ul>
<li>这个类是否有父类（除了 Object 之外，所有类都应该有父类） </li>
<li>这个类的是否继承了不允许被继承的类（被 final 修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或者出现了不符合规则的重载等）<br>……</li>
</ul>
<h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>这一阶段的主要目的是通过数据流和控制流分析，确定程序的语义是合法的、符合逻辑的。在上一阶段对元数据信息的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。可能的验证点包括：</p>
<ul>
<li> 保证任何时候，操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放入了一个int类型数据，使用时却按 long 类型加载到本地变量表中</li>
<li> 保证跳转指令不会跳转到方法体外的字节码指令上</li>
<li>保证方法体中类型转换是有效的(比如把父类对象赋值给子类型数据，甚至把两个不相关的数据类型进行赋值，是危险和不合法的)<br>……</li>
</ul>
<h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>这个阶段发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在链接的第三个阶段—解析阶段中发生，符号引用验证主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验，可能包括的验证点有：</p>
<ul>
<li>符号引用中通过字节符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问<br>……</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。有两点需要注意：</p>
<ul>
<li>这阶段进行内存分配的仅包括类变量（即被 static 修饰的变量），不包括实例变量，实例变量会在对象实例化时随着对象一起分配在 Java 堆中；</li>
<li>这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义如下：  <pre> public static int value = 123;</pre>
那变量 value 在准备阶段过后的零值为 0 而不是 123，因为这时候并未执行任何Java方法，把 value 赋值为123的动作是在初始化阶段才会进行。对于“非通常情况”，是指定义为常量的那些变量（即final修饰的），会在这一阶段就被赋值，如：  <pre> public static final int value = 123;</pre>
此时在准备阶段过后，value的值将会被赋值为123。</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在 Class 文件结构中多次提到过符号引用，它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。在解析阶段的符号引用和直接引用的区别如下：</p>
<ul>
<li><p>符号引用（Symbolic References）：符号引用以一组符号来描述索引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用都是一样的。</p>
</li>
<li><p>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局有关的，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不相同。如果有了直接引用，那么引用的目标一定在内存中。</p>
</li>
</ul>
<p>需要注意的是解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。</p>
<p>对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。</p>
<p>解析动作主要是对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行解析，分别对应CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info7种常量类型。这里仅仅介绍前四种，因为后三种和动态类型语言支持有关。</p>
<ol>
<li>类或接口的解析<br>假设当前代码处于类 D 中，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，虚拟机将经历如下的过程：</li>
</ol>
<ul>
<li>如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器区加载这个类。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载，比如这个类的父类或实现的接口。如果加载过程出现异常，解析过程就失败。</li>
<li>如果 C 是一个数组类型，并且数组的元素类型是对象，就会按照第一点加载数组元素类型。接着由虚拟机生成一个代表着数组维度和元素的数组对象。</li>
<li>如果上面的步骤没有异常，那么C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。</li>
</ul>
<ol start="2">
<li>字段解析<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内 class_index项中索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或借口的符号引用。如果解析这个类或接口时发生异常，都会导致解析字段的失败。如果解析成功，才会继续解析这个字段。具体的规则如下：</li>
</ol>
<ul>
<li>如果类或接口 C 本身就包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束；</li>
<li>否则，如果在 C 中实现了接口，将会按照继承关系从下到上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束；</li>
<li>否则，如果 C 不是 Object 的话，将会按照继承关系从下到上递归搜索父类，如果父类中包含了简单名称和字段描述符都与目标匹配的字段，返回这个字段的直接引用，查找结束；</li>
<li>否则，查找失败。</li>
</ul>
<p> 之后，还会对返回的字段进行权限验证，如果不具备对字段的访问权限，将抛出 java.lang.IllegalAccessError 异常。</p>
<ol start="3">
<li>类方法解析<br>类方法解析的第一个步骤和字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，按照如下步骤继续（同样以 C 来表示这个类）：</li>
</ol>
<ul>
<li>类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现 class_index 中索引的 C 是一个接口，直接失败；</li>
<li>如果通过第一步，接着会在类 C 中查找这个方法，如果有则直接返回这个方法的直接引用，查找结束</li>
<li>否则，在类 C 的父类中递归查找这个方法，如果有则直接返回这个方法的直接引用，查找结束</li>
<li>否则，在类 C 实现的接口列表中递归查找这个方法。如果找到一个匹配的方法，说明类 C 是一个抽象类，查找结束，抛出 java.lang.AbstractMethodError 异常；</li>
<li>否则，查找失败，抛出 java.lang.NoSuchMethodError 异常。</li>
</ul>
<p> 同样，成功返回后还要进行权限验证。</p>
<ol start="4">
<li>接口方法解析<br>接口方法也要解析接口方法表的 class_index 所属的类或接口引用，如果解析成功，用 C 表示这个类或接口，虚拟机按照如下的规则搜索：</li>
</ol>
<ul>
<li>与类方法解析不同，如果在接口方法表中发现 class_index 是一个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError 异常；</li>
<li>否则，在接口 C 中查找这个方法；</li>
<li>否则，在接口 C 的父接口中递归查找；</li>
<li>否则，查找失败，抛出 java.lang.NoSuchMethodError 异常。</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序（或者说字节码）。</p>
<p>前面已经知道，在准备阶段变量已经赋值过一次系统初始值了，而在初始化阶段，则会根据程序员通过程序制定的主观计划去初始化类变量和其它内容。或者可以从另一个角度来表达：初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code>方法的过程。下面是<code>&lt;clinit&gt;()</code>方法的特点：</p>
<ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中 (static {}) 的语句合并产生的，编译器收集的顺序由语句块在源文件中的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在之后的变量不能访问，但能赋值(参考下面的代码清单#1)。</li>
<li><code>&lt;clinit&gt;()</code>方法与类构造器<code>&lt;init&gt;()</code>不同，它不需要显式调用父类的<code>&lt;clinit&gt;()</code>方法，虚拟机保证在子类<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。这一点可以确保虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是 java.lang.Object.</li>
<li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li>
<li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变脸的赋值操作，那么编译器就不会生成<clinit>()方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。即，只有使用一个接口中的变量时，才会执行这个接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境下中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程会去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 代码清单#<span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                  <span class="comment">// 给变量的赋值可以正常编译过</span></span><br><span class="line">        System.out.println(i);  <span class="comment">// 访问编辑器会报“非法向前引用”的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;           <span class="comment">// 静态语句块之后的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" data-id="ckqm6kpl90015xxr52stefeo1" data-title="Java类加载之类加载过程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类加载</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java类加载之Class文件结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8BClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2018-07-28T06:47:48.000Z" itemprop="datePublished">2018-07-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8BClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">Java类加载之Class文件结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>抱着《深入理解Java虚拟机》这本书啃了两天时间，再结合网上相关的博客，虽然好几次看着看着就差点就睡着了，不过坚持下来终于对这部分的内容终于有一个大致的了解了，今天下午借着这个空闲时间，就把这部分内容总结一下，希望有所收获。</p>
<h3 id="关于Class文件"><a href="#关于Class文件" class="headerlink" title="关于Class文件"></a>关于Class文件</h3><p>我们现在知道在Java中每个类都会对应一个Class对象，每当我们编写并且编译一个新创建的类就会产生一个对应Class对象并且这个Class对象会被保存在同名.class文件里(编译后的字节码文件保存的就是Class对象)。当我们new 一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。</p>
<p>所以在使用一个类时，类加载器首先会检查这个类的 Class 对象是否已被加载，如果还没有加载，默认的类加载器就会先根据类名查找.class文件，加载完成后 Class 对象也就被载入内存，也就可以被用来创建这个类的所有实例对象。</p>
<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>根据《深入理解Java虚拟机》一书上的说法，Class 文件是由一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序<strong>紧凑地</strong>排列在Class文件之中，中间没有任何分隔符，这样整个Class文件全都是程序运行时的必要数据。</p>
<p>对于那些空间大于8位的数据则会分为若干个8位字节按照”高位在前(Big-Endian)”进行存储，比如的16位、32位和64位长度的数据将被构造成 2个、4个和8个8字节单位来表示。</p>
<p><strong>NOTE</strong>: 注意：Big-Endian 顺序是指按高位字节在地址最低位，最低字节在地址最高位来存储数据，它是 SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处理器则是使用了相反的Little-Endian顺序来存储数据。</p>
<p>Class文件格式采用类似C语言结构体的伪结构来描述Class文件格式。在这种结构体只有两种数据类型：无符号数和表。</p>
<p>其中无符号数属于基本的数据类型，以u1、u2、u4、u8来分别表示1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。表是由多个无符号或者其他表作为数据项构成的复合数据类型，习惯性地以”_info”结尾，这样来看，整个Class文件本质上也就是一张表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123; </span><br><span class="line">    u4 magic; </span><br><span class="line">    u2 minor_version; </span><br><span class="line">    u2 major_version; </span><br><span class="line">    u2 constant_pool_count; </span><br><span class="line">    cp_info constant_pool[constant_pool_count<span class="number">-1</span>]; </span><br><span class="line">    u2 access_flags; </span><br><span class="line">    u2 this_class; </span><br><span class="line">    u2 super_class; </span><br><span class="line">    u2 interfaces_count; </span><br><span class="line">    u2 interfaces[interfaces_count]; </span><br><span class="line">    u2 fields_count; </span><br><span class="line">    field_info fields[fields_count]; </span><br><span class="line">    u2 methods_count; </span><br><span class="line">    method_info methods[methods_count]; </span><br><span class="line">    u2 attributes_count; </span><br><span class="line">    attribute_info attributes[attributes_count]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用表格的形式表示一下：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">名称</th>
<th align="left">描述</th>
<th align="left">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">U4</td>
<td align="left">magic</td>
<td align="left">魔数</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">minor_version</td>
<td align="left">副版本号</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">major_version</td>
<td align="left">主版本号</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">constant_pool_count</td>
<td align="left">常量池计数器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">cp_info</td>
<td align="left">constant_pool</td>
<td align="left">常量池</td>
<td align="left">constant_pool_count - 1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">access_flags</td>
<td align="left">访问标志</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">this_class</td>
<td align="left">类索引</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">super_class</td>
<td align="left">父类索引</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">interfaces_count</td>
<td align="left">接口索引计数器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">interfaces</td>
<td align="left">接口索引</td>
<td align="left">interfaces_count</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">fields_count</td>
<td align="left">字段表计数器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">field_info</td>
<td align="left">fields</td>
<td align="left">字段表</td>
<td align="left">fields_count</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">methods_count</td>
<td align="left">方法表计数器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">method_info</td>
<td align="left">methods</td>
<td align="left">方法表</td>
<td align="left">methods_count</td>
</tr>
<tr>
<td align="left">U2</td>
<td align="left">attributes_count</td>
<td align="left">属性表计数器</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">attribute_info</td>
<td align="left">attributes</td>
<td align="left">属性表</td>
<td align="left">attributes_count</td>
</tr>
</tbody></table>
<p>而我们接下要做的就是结合一个实际的Class文件字节码来逐个理解这些字段。</p>
<h5 id="测试类代码："><a href="#测试类代码：" class="headerlink" title="测试类代码："></a>测试类代码：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calcM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Test-class对应的二进制流（使用WinHex软件打开）"><a href="#Test-class对应的二进制流（使用WinHex软件打开）" class="headerlink" title="Test.class对应的二进制流（使用WinHex软件打开）"></a>Test.class对应的二进制流（使用WinHex软件打开）</h5><p><img src="http://dengw.xyz/blog/180728/K9c9Lef045.png?imageslim" alt="enter image description here"></p>
<h4 id="使用javap反汇编命令生成的字节码："><a href="#使用javap反汇编命令生成的字节码：" class="headerlink" title="使用javap反汇编命令生成的字节码："></a>使用<code>javap</code>反汇编命令生成的字节码：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator\Desktop&gt; Javap -verbose Test</span><br><span class="line">Classfile /C:/Users/Administrator/Desktop/Test.class</span><br><span class="line">  Last modified 2018-7-28; size 395 bytes</span><br><span class="line">  MD5 checksum edee74c07502d68f5e7aea198366f496</span><br><span class="line">  Compiled from &quot;Test.java&quot;</span><br><span class="line">public class Test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #4.#21         // Test.name:Ljava/lang/String;</span><br><span class="line">   #3 = Fieldref           #4.#22         // Test.m:I</span><br><span class="line">   #4 = Class              #23            // Test</span><br><span class="line">   #5 = Class              #24            // java/lang/Object</span><br><span class="line">   #6 = Utf8               name</span><br><span class="line">   #7 = Utf8               Ljava/lang/String;</span><br><span class="line">   #8 = Utf8               m</span><br><span class="line">   #9 = Utf8               I</span><br><span class="line">  #10 = Utf8               &lt;init&gt;</span><br><span class="line">  #11 = Utf8               ()V</span><br><span class="line">  #12 = Utf8               Code</span><br><span class="line">  #13 = Utf8               LineNumberTable</span><br><span class="line">  #14 = Utf8               setName</span><br><span class="line">  #15 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               calcM</span><br><span class="line">  #17 = Utf8               ()I</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Test.java</span><br><span class="line">  #20 = NameAndType        #10:#11        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = NameAndType        #6:#7          // name:Ljava/lang/String;</span><br><span class="line">  #22 = NameAndType        #8:#9          // m:I</span><br><span class="line">  #23 = Utf8               Test</span><br><span class="line">  #24 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public Test();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public void setName(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #2                  // Field name:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 8: 5</span><br><span class="line"></span><br><span class="line">  public int calcM();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #3                  // Field m:I</span><br><span class="line">         4: iconst_1</span><br><span class="line">         5: iadd</span><br><span class="line">         6: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 11: 0</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Test.java&quot;</span><br></pre></td></tr></table></figure>
<p>准备工作做完了下面就开始解析了：</p>
<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>class文件的头4个字节称为魔数，它的唯一作用就是确定这个文件时候是一个能被虚拟机接受的class文件。使用魔数而不是用文件扩展名来区别Class文件的原因在于魔数不可更改，而文件扩展名可以随意更改。在java中魔数为一个常量: 0xCAFEBABE</p>
<p><img src="http://dengw.xyz/blog/180728/K2dl8FG5D7.png?imageslim" alt="enter image description here"></p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>接下来就是class文件的版本号，第5、6个字节是次版本号，第7、8个字节是主版本号。</p>
<p>如上图所示，副版本号是：0x0000，主版本号是 0x0034，也就是十进制的52，java 的版本号是从45开始，高版本的 JDK 能向下兼容以前版本的 Class 文件，虚拟机拒绝执行超过其版本号的 Class 文件。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>常量池的数量不是固定的，所以常量池的入口需要放置一个u2类型的数据来代表常量池的容量计数器。由于这个容器的计数是从1开始的而不是从0开始的，常量池的常量个数与常量池计数器的关系是 <code>count = counter - 1</code>。根据 WinHex 软件打开看到的字节流显示容量计数器的十六进制数为 0x0019，即十进制的25，这就代表常量池中有24项常量，索引范围是1~24。这个也可以从我们上面的 <code>javap</code> 反汇编命令生成的字节码中看到。</p>
<p>常量池可以理解为结构中文件之中的资源仓库，主要存放两大类常量：字面量和符号引用。</p>
<blockquote>
<p>字面量：接近java语言层面的常量概念，如文本字符串、final常量值等。</p>
</blockquote>
<blockquote>
<p>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</p>
</blockquote>
<p>常量池中的每一项都是一个表，现在的 JDK 版本中一共有14种表。这14个表都有一个特点，第一项均为 u1 类型的 tag，代表常量池项目的类型，这14种常量类型所代表的具体含义如下：<br><img src="http://dengw.xyz/blog/180728/A3Lkidc9Hm.png?imageslim" alt="enter image description here"><br><img src="http://dengw.xyz/blog/180728/391KEbGbkg.png?imageslim" alt="enter image description here"></p>
<p>下面来根据我们的字节码来分析常量池（蓝色背景部分）。<br><img src="http://dengw.xyz/blog/180728/EI0BH4JFim.png?imageslim" alt="enter image description here"></p>
<p>然后把每个常量的字节流截取出来，显示如下(实际上字节之间是不存在空格的，这里方便查看)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#1: 0A 00 05 00 14</span><br><span class="line">#2: O9 00 04 00 15</span><br><span class="line">#3: 09 00 04 00 16</span><br><span class="line">#4: 07 00 17</span><br><span class="line">#5: 07 00 18</span><br><span class="line">#6: 01 00 04 6E 61 6D 65</span><br><span class="line">#7: 01 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B</span><br><span class="line">#8: 01 00 01 6D</span><br><span class="line">#9: 01 00 01 49</span><br><span class="line">#10: 01 00 06 3C 69 6E 69 74 3E</span><br><span class="line">#11: 01 00 03 28 29 56</span><br><span class="line">#12: 01 00 04 43 6F 64 65</span><br><span class="line">#13: 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65</span><br><span class="line">#14: 01 00 07 73 65 74 4E 61 6D 65</span><br><span class="line">#15: 01 00 15 28 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56</span><br><span class="line">#16: 01 00 05 63 61 6C 63 4D</span><br><span class="line">#17: 01 00 03 28 29 49 </span><br><span class="line">#18: 01 00 0A 53 6F 75 72 63 65 46 69 6C 65</span><br><span class="line">#19: 01 00 09 54 65 73 74 2E 6A 61 76 61</span><br><span class="line">#20: 0C 00 0A 00 0B</span><br><span class="line">#21: 0C 00 06 00 07</span><br><span class="line">#22: 0C 00 08 00 09</span><br><span class="line">#23: 01 00 04 54 65 73 74</span><br><span class="line">#24: 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74</span><br></pre></td></tr></table></figure>

<p>可以看到第一项常量的 tag 为 0x0A，即十进制的10，查表得知这个常量属于 CONSTANT_Methordref_info 类型，表示对一个类中方法的符号引用，该项常量占用的字节流为 0x0A(tag)、 0x0005(index)、0x0014(index)，即分别指向第5个常量和第20个常量，对应的字节流分别为 0x07 00 18 和 0x0C 00 0A 00 0B，然后通过 tag 又知道了这两个常量的类型分别为CONSTANT_Class_info 和 CONSTANT_NameAndType_info 类型，这样第一个常量就解析完成了。而我们再看一下反编译结果中的常量表发现确实也是这样。</p>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><p>在常量池结束之后，紧接着的两个字节代表访问标志，用于识别类或接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public 类型、abstract 类型等等。具体的标志位以及标志的含义见下表：</p>
<table>
<thead>
<tr>
<th align="left">标志名称</th>
<th align="left">标志值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACC_PUBLIC</td>
<td align="left">0x0001</td>
<td align="left">是否为public类型</td>
</tr>
<tr>
<td align="left">ACC_FINAL</td>
<td align="left">0x0010</td>
<td align="left">是否被声明为final，只有类可设置</td>
</tr>
<tr>
<td align="left">ACC_SUPER</td>
<td align="left">0x0020</td>
<td align="left">是否允许使用invokespecial字节码指令的新语义，JDK1.0.2之后编译出来的类这个标志必须为真</td>
</tr>
<tr>
<td align="left">ACC_INTERFACE</td>
<td align="left">0x0200</td>
<td align="left">标识这是一个接口</td>
</tr>
<tr>
<td align="left">ACC_ABSTRACT</td>
<td align="left">0x0400</td>
<td align="left">是否为abstract类型，对于接口或抽象类来说此值为真，其他类值为假</td>
</tr>
<tr>
<td align="left">ACC_SYNTHETIC</td>
<td align="left">0x1000</td>
<td align="left">标识这个类并非由用户代码产生的</td>
</tr>
<tr>
<td align="left">ACC_ANNOTATION</td>
<td align="left">0x2000</td>
<td align="left">标识这个一个注解</td>
</tr>
<tr>
<td align="left">ACC_ENUM</td>
<td align="left">0x4000</td>
<td align="left">标识这是一个枚举</td>
</tr>
</tbody></table>
<p>我们定义的 Test 类被 public 关键字修饰，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，因此其 access_flags 值应为<code>0x0001|0x0020=0x0021</code>,字节流显示的也确实是<code>0x0021</code><br><img src="http://dengw.xyz/blog/180728/a4689fG3Gf.png?imageslim" alt="enter image description here"></p>
<h4 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h4><p>在访问标志 access_flags 后接下来就是类索引（this_class）和父类索引（super_class），这两个数据都是u2类型的，他们各自指向一个类型为  CONSTANT_Class_info 的类描述符常量，而接下来的接口索引集合是一个 u2 类型的集合，class 文件由这三个数据项来确定类的继承关系。由于 Java 中是单继承，所以父类索引只有一个；但Java类可以实现多个接口，所以接口索引是一个集合。</p>
<p>类索引用来确定这个类的全限定名，父类索引确定这个类的父类的全限定名，除了 Object 之外，所有的类都有父类，接口索引集合存储了implements 语句后面按照从左到右的顺序的接口。</p>
<p><img src="http://dengw.xyz/blog/180728/KBda0EIfjj.png?imageslim" alt="enter image description here"></p>
<p>从上图可以看出3个 u2 类型的值分别为 0x0004、0x0005、0x0000。也就是类索引指向常量表的第4个常量，父类索引指向常量表的第5个常量，接口索引为0，也就是没有实现接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#4 = Class              #23            // Test</span><br><span class="line">#5 = Class              #24            // java/lang/Object</span><br></pre></td></tr></table></figure>

<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>字段表用来描述接口或类中声明的变量。字段包括类级变量和实例级变量，但不包括方法内变量，也就是局部变量。所谓的类级变量就是静态变量，这个变量不属于这个类的任何实例，可以不用定义类实例就可以使用；实例级变量不是静态变量，是和类实例相关联的，需要定义类实例才能使用。</p>
<p>我们可以先想一下一个字段包含有哪些信息呢？</p>
<p>可以包含的信息有：字段的作用域（public、private和protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final修饰符）、并发可见性（volatile修饰符）、是否可被序列化（transient修饰符）、字段的数据类型（基本类型、对象、数组）以及字段名称。对于上述这些信息，每一个修饰符都是布尔值，有或者没有，字段名引用常量池的常量来进行描述。下表是字段表的最终格式：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">名称</th>
<th align="left">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">u2</td>
<td align="left">access_flags</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">name_index</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">descriptor_index</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">u2</td>
<td align="left">attributes_count</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">attribute_info</td>
<td align="left">attributes</td>
<td align="left">attributes_count</td>
</tr>
</tbody></table>
<p>其中的字段修饰符 access_flags，和类中的 access_flags 类似，对于字段来说可以设置的标志位及含义如下：</p>
<table>
<thead>
<tr>
<th align="left">标志名称</th>
<th align="left">标志值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ACC_PUBLIC</td>
<td align="left">0x0001</td>
<td align="left">字段是否是public</td>
</tr>
<tr>
<td align="left">ACC_PRIVATE</td>
<td align="left">0x0002</td>
<td align="left">字段是否是private</td>
</tr>
<tr>
<td align="left">ACC_PROTECTED</td>
<td align="left">0x0004</td>
<td align="left">字段是否是protected</td>
</tr>
<tr>
<td align="left">ACC_STATIC</td>
<td align="left">0x0008</td>
<td align="left">字段是否是static</td>
</tr>
<tr>
<td align="left">ACC_FINAL</td>
<td align="left">0x0010</td>
<td align="left">字段是否是final</td>
</tr>
<tr>
<td align="left">ACC_VOLATILE</td>
<td align="left">0x0040</td>
<td align="left">字段是否是volatile</td>
</tr>
<tr>
<td align="left">ACC_TRANSIENT</td>
<td align="left">0x0080</td>
<td align="left">字段是否是transient</td>
</tr>
<tr>
<td align="left">ACC_SYNTHETIC</td>
<td align="left">0x1000</td>
<td align="left">字段是否是由编译器自动产生的</td>
</tr>
<tr>
<td align="left">ACC_ENUM</td>
<td align="left">0x4000</td>
<td align="left">字段是否是enum</td>
</tr>
</tbody></table>
<p>显然，ACC_PUBLIC、ACC_PRIVATE 和 ACC_PROTECTED 只能选择一个，ACC_FINAL 和 ACC_VOLATILE 不能同时选择。接口中的字段必须有 ACC_PUBLIC、ACC_STATIC 和 ACC_FINAL 标志，这是Java语言本身的规则决定的。</p>
<p>access_flags 后面的是 name_index 和descriptor_index，前者是字段简单名称名的常量池索引，后者是字段描述符的常量池索引。</p>
<blockquote>
<p>全限定名：就是把带路径类名中的”.”替换成“/”后的字符串，比如<code>java/lang/Object</code>或者<code>Test</code>就是两个全限定名。</p>
<p>简单名称：是指没有类型和参数修饰的方法或者字段名称。</p>
<p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。</p>
</blockquote>
<p>对于方法的描述符，参数类型都使用一个大写字母来表示，具体表示如下表：<br><img src="http://dengw.xyz/blog/180728/fh36JhJ0ga.png?imageslim" alt="enter image description here"></p>
<p>对于数组类型，每一个维度将使用一个前置的“[”字符来描述。比如定义一个<code>java.lang.String[][]</code>类型的二维数组，将记录为<code>[[Ljava/lang/String</code>，一个 double 数组<code>double[]</code>将标记为<code>[D</code>。</p>
<p>当描述符用来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号<code>()</code>内。比如方法<code>void setName(String name)</code>的描述符是<code>(S)V</code>。方法<code>java.lang.String toString()</code>的描述符是<code>()Ljava/lang/String</code>；方法<code>int indexOf(char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex)</code>的描述符是<code>([CII[CIII)I</code>。</p>
<p>descriptor_info后面是属性信息，对于字段，可以使用属性表描述一下额外信息，比如如果将字段<code>m</code>的声明改为<code>final static int m = 123;</code>，那就会存在一个项名称为<code>ConstantValue</code>的属性，值指向常量123。关于属性表后面还会详细介绍。</p>
<p>我们回到字节流中再详细地分析一下：<br><img src="http://dengw.xyz/blog/180728/dJ6hijm4am.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00 02  // fileds_count:代表有两个字段</span><br><span class="line">// 第一个字段，下同</span><br><span class="line">00 02  // access_flag: 具备的所有访问权限按位或运算的结果</span><br><span class="line">00 06  // name_index: 指向常量池的第6个常量</span><br><span class="line">00 07  // description_index: 指向常量池的第7个常量</span><br><span class="line">00 00  // attribute_count: 属性数量</span><br><span class="line">// 第二个字段</span><br><span class="line">00 02 </span><br><span class="line">00 08 </span><br><span class="line">00 09</span><br><span class="line">00 00</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是字段表集合中不会列出从父类或接口中继承来的字段，但有可能会出现原本Java程序中没有的字段。比较典型的例子是内部类，为了在内部类中保持对外部类的访问性，会增加一个指向外部类实例的字段<code>this</code>。另外，在Java语言中字段无法重载，也就是字段名不能重复，即使两个字段的数据类型、修饰符都不相同。不过对于字节码来说，如果两个字段的描述符不一致，那么就可以有重复的字段名。</p>
<h4 id="方法集合"><a href="#方法集合" class="headerlink" title="方法集合"></a>方法集合</h4><p>class文件存储格式中对方法的描述和对字段的描述几乎相同，方法表的结构也和字段表相同。</p>
<p>不过因为 volatile 和 transient 关键字不能修饰方法，而synchronized、native、strictfp 和 abstract 关键字可以修饰方法，所以方法表的标志位及其取值如下：<br><img src="http://dengw.xyz/blog/180728/B96a8GAgig.png?imageslim" alt="enter image description here"></p>
<p>另外一点方法肯定就包括代码了，如果方法表和字段表的结构相同，那代码去哪儿了呢？答案是经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为<code>Code</code>的属性里面，关于属性表后面再详细介绍。</p>
<p>我们再结合字节流详细了解一下：</p>
<p><img src="http://dengw.xyz/blog/180728/c3c6G06F40.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 03 //表示有三个方法，这里只介绍第一个方法</span><br><span class="line">00 01 // 访问标志： 具备的所有访问权限按位或运算的结果</span><br><span class="line">00 0A // 名称索引：指向第10个常量</span><br><span class="line">00 0B // 描述符索引：指向第11个常量</span><br><span class="line">00 01 // 有一项属性</span><br><span class="line">00 0C //属性名称索引，指向第12个常量，值为&quot;Code&quot;,即方法的字节码描述</span><br></pre></td></tr></table></figure>

<p>在Java中，要重载一个方法，除了要与原方法具有相同的方法名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是特征签名只包含参数个数和类型，并不包含返回值类型，所以Java语言中是无法仅仅依靠返回值的不同来对一个方法重载的。但是在class文件格式中，特征签名还包括返回值类型，也就是说只有返回值类型不同的两个方法也可以存在。这一点在泛型中编译后类型擦除后生成的桥接方法上有所体现。不过这里就不过多介绍了。</p>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>属性表在前面出现了多次，在class文件、字段表和方法表都可以携带自己的属性表集合，来描述某些场景专有的信息。</p>
<p>与class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制比较少，不要求严格的顺序，只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自定义的属性信息，Java虚拟机会在运行时忽略掉那些不认识的信息。为了能正确解析class文件，《Java虚拟机规范（第二版）》中预定义了9项虚拟机应当识别的属性。现在，属性已经达到了21项。具体信息如下表：<br><img src="http://dengw.xyz/blog/180730/6G557DKfGj.png?imageslim" alt="enter image description here"><br><img src="http://dengw.xyz/blog/180730/I2GllEllmf.png?imageslim" alt="enter image description here"><br><img src="http://dengw.xyz/blog/180730/2fF1EFG133.png?imageslim" alt="enter image description here"></p>
<p>从上表可以看出，属性表集合存在的位置也是不确定的，不仅可以存储在class文件结尾处，还可以作为数据项存在于类、方法表集合和字段表集合中。对于存在于class类文件中的属性表集合很好理解，毕竟在开头的class文件结构图中的最后一部分就是属性表集合，这时属性表集合作为构成class文件结构的一个大部分。剩下的存在于类中、方法表集合与字段表集合中的属性表集合，其实是作为它们的一个数据项存在的。</p>
<p>存在于类中的属性表集合，存储了关于这个类的一些信息。比如这个类是否是过时的（Deprecated）、在泛型中保存类的类型参数（由于生成class文件后会进行类型擦除，Java中的泛型是一种伪泛型）和动态注解等信息；存放在方法表集合中的属性表集合存储了关于方法的信息，最主要的就是Code属性，存储了字节码指令；存放于字段表集合中的属性表集合存储了关于字段的信息，我们这里的例子没有涉及到字段的属性，不过当在类中定义了静态常量（static final）并且这个常量有初始值时会将这个值作为属性存储在字段表中的属性表集合中。</p>
<p>对于每个属性，class文件规定的属性格式只有前6个字节：2字节的属性名称的索引和4个字节的属性长度，名称是指向 CONSTANT_Utf8_info 类型常量的索引，一个 u4 的长度属性 attribute_length 说明属性值作用的占用位数，接下来就要按照这个长度存储属性值。一个符合规则的属性表的结构如下：<br><img src="http://dengw.xyz/blog/180730/Fd3hDFcA7J.png?imageslim" alt="enter image description here"></p>
<p>下面我们着重学习一下 Code 属性。</p>
<h5 id="属性表集合之Code属性"><a href="#属性表集合之Code属性" class="headerlink" title="属性表集合之Code属性"></a>属性表集合之Code属性</h5><p>Java 程序方法体中的代码经过 Javac 编译处理后，最终变为字节码指令存储在 Code 属性中，Code 属性出现在方法表的属性集合之中。但是需要注意的是也并非所有方法表都有 Code 属性，例如抽象类或接口，Code 属性的结构如下：<br><img src="http://dengw.xyz/blog/180730/BhIcG6G9kk.png?imageslim" alt="enter image description here"></p>
<p>其中 attribute_name_index 和 attribute_length 前面已经介绍过了。</p>
<p>max_stack代表了操作数栈的最大深度。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机执行时需要根据这个值来分配栈帧中的操作栈深度。</p>
<p>max_locals代表了局部变量表所需要的存储空间。在这里，max_locals的单位是slot，HotSpot虚拟机在分配对象时使用的单位就是slot。方法参数（包括隐式参数this）、显式异常处理器的参数（try-catch块中catch块中定义的异常）以及方法体中定义的局部变量都需要局部变量表来存放。需要注意的是，由于局部变量表中的slot可以重用，所以并不是所有的局部变量的总slot就是max_locals。编译器会根据变量的作用域来分配 slot 给各个变量使用，然后计算 max_locals 的大小。</p>
<p>code_length 和code用来存储字节码指令。Java的字节码指令的长度都是一个字节，即最多可以有256个指令，实际上一共有大约200条指令。对于字节码指令这里不过多介绍。</p>
<p>code_length和 code是用来存储 Java源程序编译后产生的字节码指令，code_length代表字节码长度。既然叫字节码，每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。一个字节取值范围为0~255，所以字节码指令肯定不会超过256个指令，目前Java虚拟机规范定义了其中约200条编码值对应指令的含义。</p>
<p>因为 code_length 是一个 u4 类型，所以理论上每个方法的字节长度不能超过2^23-1，但是虚拟机规范中明确限定了一个方法不能超过65535条字节码指令，即实际只用到了u2的长度，如果超过这个限制，Javac 编译器会拒绝编译。</p>
<p>最后我们再结合 Test.Class 文件的二进制流来具体分析一下。</p>
<p>上面我们分析方法表的时候，看到有一个指向常量池中值为 Code 的索引值，这就是该方法 Code 表的 attribute_name_index 属性，下面我们接着那儿分析吧：<br><img src="http://dengw.xyz/blog/180730/Df4Ck86AAC.png?imageslim" alt="enter image description here"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00 0C // attribute_name_index</span><br><span class="line">00 00 00 1D // attribute_length</span><br><span class="line">00 01 // max_stack</span><br><span class="line">00 01 // max_locals</span><br><span class="line">00 00 00 05 // code_length</span><br><span class="line">2A B7 00 01 B1 // code(对应指令)</span><br><span class="line">00000001000D00000006000100000001  // 剩下的部分</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/28/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B9%8BClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" data-id="ckqm6kpng006xxxr503we82t1" data-title="Java类加载之Class文件结构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类加载</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Java反射机制的初步了解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/25/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2018-07-25T07:46:06.000Z" itemprop="datePublished">2018-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/25/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/">Java反射机制的初步了解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>RTTI（Run-Time Type Identification）运行时类型识别，其作用是在运行时识别一个对象的类型和类的信息。这里分两种：传统的”RRTI”，它假定我们在编译期已知道了所有类型(如new对象时该类必须已定义好)，另外一种是反射机制，它允许我们在运行时发现和使用类型的信息。</p>
<p>JAVA反射机制是在<strong>运行状态</strong>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种<strong>动态获取</strong>的信息以及<strong>动态调用</strong>对象的方法的功能称为java语言的反射机制，即采用动态编译的方式。</p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。</p>
<p><strong>反射的本质</strong>：就是在得到类的<code>class</code>文件后，反响获取类对象的各种信息。</p>
<h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><p>在使用Java反射机制时，主要步骤包括： </p>
<ol>
<li>获取 目标类型的Class对象 </li>
<li>通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象 </li>
<li>通过 Constructor类对象、Method类对象、Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</li>
</ol>
<p>获取到 Class 对象，有以下三种方式：</p>
<ul>
<li>Object 类中的 getClass 方法</li>
<li>任何数据类型（包括基本数据类型）都有一个“静态”的class属性</li>
<li>通过Class类的静态方法：forName（String  className）(常用)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fanshe</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// way1		Student stu1 = new Student();</span></span><br><span class="line">		Class class1 = stu1.getClass();</span><br><span class="line">		System.out.println(<span class="string">&quot;way1: &quot;</span> + class1.getName());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// way2</span></span><br><span class="line">		Class class2 = Student.class;</span><br><span class="line">		System.out.println(<span class="string">&quot;way2: &quot;</span> + class2.getName());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// way3</span></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Class class3 = Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;way3: &quot;</span> + class3.getName());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;way3: &quot;</span> + <span class="string">&quot;Class not found&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种方式常用第三种，第一种方法对象都有了还要反射干什么，反射的目的就是回去类的对象。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>
<h4 id="获取构造方法并调用"><a href="#获取构造方法并调用" class="headerlink" title="获取构造方法并调用"></a>获取构造方法并调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有&quot;公有的&quot;构造方法</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getConstructors()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的构造方法(包括私有、受保护、默认、公有)</span></span><br><span class="line"><span class="keyword">public</span> Constructor[] getDeclaredConstructors()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单个的&quot;公有的&quot;构造方法，参数是构造方法中参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有，参数是构造方法中参数类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor <span class="title">getDeclaredConstructor</span><span class="params">(Class... parameterTypes)</span></span></span><br></pre></td></tr></table></figure>

<p>示例：Student类中有一个参数为<code>int</code>类型的私有构造函数，而其他类型的构造函数与私有构造函数相比处理要更简单，因此拿私有构造函数来进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Student(int grade) &#123;</span><br><span class="line">	this.grade = grade;</span><br><span class="line">	System.out.println(&quot;调用了私有构造方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用反射使用该构造函数实例化一个Student的示例并输出 grade 参数的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Class class3 = Class.forName(<span class="string">&quot;Student&quot;</span>);</span><br><span class="line">	Constructor con = class3.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">	con.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Student obj = (Student) con.newInstance(<span class="number">2</span>);</span><br><span class="line">	System.out.println(obj.getGrade());</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用到 Constructor 类的一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新设置该构造函数的访问权限</span></span><br><span class="line">setAccessible(<span class="keyword">boolean</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造器构造一个示例，参数与你调用的构造函数的参数相同</span></span><br><span class="line">newInstance()</span><br></pre></td></tr></table></figure>
<h4 id="获取成员变量并调用"><a href="#获取成员变量并调用" class="headerlink" title="获取成员变量并调用"></a>获取成员变量并调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的公有字段</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有字段，包括：私有、受保护、默认、公有</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个&quot;公有的&quot;字段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getField</span><span class="params">(String fieldName)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取所有类型中的某个字段(私有、受保护、默认、公有)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Field <span class="title">getDeclaredField</span><span class="params">(String fieldName)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：Student 类中有一个私有参数：name，其他类型的参数与私有参数相比处理更简单一点，因此拿私有参数来举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>
<p>然后使用反射机制，不调用Student 类提供的 setName() 函数，直接改变 name 字段的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Object obj = class3.getConstructor().newInstance();</span><br><span class="line">	Student student = (Student) obj;</span><br><span class="line">	Field name = class3.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	name.set(student, <span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line">	System.out.println(name.get(student));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用到Field 类的一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重新设置该字段的访问权限</span></span><br><span class="line">setAccessible(<span class="keyword">boolean</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新设置实例 Object 中该字段的值</span></span><br><span class="line">set(Object, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例 Object 中该字段的值</span></span><br><span class="line">get(Object)</span><br></pre></td></tr></table></figure>
<p>**NOTE:  ** 在上面的代码中<code>System.out.println(student.getName());</code>我最开始使用的是<code>System.out.println(studnet.name);</code>，我的想法是因为我已经重新设置了 name 属性的访问权限，所有可以直接访问该属性。但是发现这样会报错。之前一直觉得发射破坏了java 类的访问规则，但是现在来看，及时使用反射还是要遵守 java 的语法规则的，你不用像我这样直接使用属性名来访问字段的值，因为这样是违背java语法规则的，只能够使用反射的方法来进行访问。同理，类的私有方法也有这个规则。</p>
<h4 id="获取成员方法并调用"><a href="#获取成员方法并调用" class="headerlink" title="获取成员方法并调用"></a>获取成员方法并调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有公有方法（包含了父类的方法也包含Object类）</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的成员方法，包括私有的(不包括继承的)</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取单个公有方法 (参考上面)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span>:</span></span><br><span class="line"><span class="function">* 参数说明：</span></span><br><span class="line"><span class="function">* name : 方法名；</span></span><br><span class="line"><span class="function">* parameterTypes : 方法形参的Class类型对象</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取单个成员方法（参考上面）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure>
<p>示例：Student类中有一个私有方法 <code>funB</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">funB</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b + <span class="string">&quot;年级的&quot;</span> + a + <span class="string">&quot; 执行了私有方法：B&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用反射机制获取到该方法并执行，然后输出返回结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Object obj = class3.getConstructor().newInstance();</span><br><span class="line">	Method m = class3.getDeclaredMethod(<span class="string">&quot;funB&quot;</span>, String.class, <span class="keyword">int</span>.class);</span><br><span class="line">	System.out.println(m);</span><br><span class="line">	m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">	Object re = m.invoke(obj, <span class="string">&quot;刘德华&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	String out = (String) re;</span><br><span class="line">	System.out.println(out);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> java.lang.String Student.funB(java.lang.String,<span class="keyword">int</span>)</span><br><span class="line"><span class="number">2</span>年级的刘德华 执行了私有方法：B</span><br></pre></td></tr></table></figure>
<p>上面使用到 Method 类的一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方法，返回值是要执行方法的返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">* 参数说明：</span></span><br><span class="line"><span class="function">* obj: 要调用方法的对象实例；</span></span><br><span class="line"><span class="function">* args: 要执行方法的具体参数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 重新设置该方法的访问权限</span></span></span><br><span class="line"><span class="function"><span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span></span><br></pre></td></tr></table></figure>
</br>
</br>
**同样的，我们也可以通过反射来获取一个类的 main 方法；**
</br>
</br>

<p>假如 Student 方法中有一个如下格式的 main 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Student类的main方法执行了&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String str : args) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用反射调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	Method main = class3.getMethod(<span class="string">&quot;main&quot;</span>, String[].class);</span><br><span class="line">	main.invoke(<span class="keyword">null</span>, (Object)<span class="keyword">new</span> String[]&#123;<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;张学友&quot;</span>, <span class="string">&quot;郭富城&quot;</span>&#125; );</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student类的main方法执行了</span><br><span class="line">刘德华</span><br><span class="line">张学友</span><br><span class="line">郭富城</span><br></pre></td></tr></table></figure>

<h4 id="通过反射越过泛型检查"><a href="#通过反射越过泛型检查" class="headerlink" title="通过反射越过泛型检查"></a>通过反射越过泛型检查</h4><p>我们知道，Java 的泛型在编译期有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉。而我们的反射是动态编译的，也就是在运行期才确定类型的，通过这个原理，我们就可以通过反射来越过编译器的泛型检查。</p>
<p>示例：有一个 String 泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">	list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Class listClass = list.getClass();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Method m = listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">	m.invoke(list, <span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(Object obj : list) &#123;</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	&#125;</span><br><span class="line"> 	&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">100</span><br></pre></td></tr></table></figure>

<h4 id="反射包中的Array类"><a href="#反射包中的Array类" class="headerlink" title="反射包中的Array类"></a>反射包中的Array类</h4><p>在Java的 java.lang.reflect 包中存在着一个可以动态操作数组的类: Array，它提供了动态创建和访问 Java 数组的方法。Array 允许在执行 get 或 set 操作进行取值和赋值。在Class类中与数组关联的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回表示数组元素类型的 Class，即数组的类型</span></span><br><span class="line">Class&lt;?&gt; getComponentType()	</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判定此 Class 对象是否表示一个数组类</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	<span class="title">isArray</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>java.lang.reflect.Array中的常用静态方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定数组对象中索引组件的值。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">get</span><span class="params">(Object array, <span class="keyword">int</span> index)</span>	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 以 int 形式返回指定数组对象的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Object array)</span>	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个具有指定类型和维度的新数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span>... dimensions)</span>	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个具有指定的组件类型和长度的新数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span>	</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将指定数组对象中索引组件的值设置为指定的新值</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object array, <span class="keyword">int</span> index, Object value)</span>	</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/25/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3/" data-id="ckqm6kpl6000vxxr52ckb76ri" data-title="Java反射机制的初步了解" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-git学习总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/24/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2018-07-24T02:23:51.000Z" itemprop="datePublished">2018-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/24/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">git学习总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>##概念区分</p>
<h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><p>就是你在电脑里能看到的目录</p>
<h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="http://dengw.xyz/blog/180801/Jk8j0eFKLg.png?imageslim" alt="enter image description here"></p>
<h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>存在于本地电脑上的一个分布式 git 版本库</p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>很好理解啦，就比如你的 github 上的一个项目（repository）。远程仓库的默认名称是origin</p>
<h3 id="HEAD-和-master"><a href="#HEAD-和-master" class="headerlink" title="HEAD 和 master"></a>HEAD 和 master</h3><p>HEAD 指向当前分支，比如当你创建一个新的分支的时候，HEAD指向新的分支。<br>master 表示一个分支，一般代表的是主分支。</p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840038939c291467cc7c747b1810aab2fb8863508000">参考链接: 创建与合并分支</a></p>
<h2 id="常用Git命令"><a href="#常用Git命令" class="headerlink" title="常用Git命令"></a>常用Git命令</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><ul>
<li> git init<br>初始化一个 git 仓库，并将该文件夹格式化为一个工作区<br></li>
<li>git add file<br>添加特定文件到暂存区，其中 <code>git add .</code> 添加工作区的所有文件到暂存区<br></li>
<li>git commit -m message<br>文件提交到本地仓库的当前分支, <code>-m</code> 后面输入的是本次提交的说明<br></li>
</ul>
<h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><ul>
<li><p>git status<br>查看本地仓库当前的状态，显示工作区和暂存区是否有还没提交的内容</p>
<br></li>
<li><p>git diff<br>查看工作区和暂存区中文件的具体差异，不会显示暂存区和仓库中文件的差异</p>
<br></li>
<li><p>git log<br>显示从最近到最远的提交日志<br><img src="http://dengw.xyz/blog/180801/H9lK7egebh.png?imageslim" alt="enter image description here"></p>
</li>
<li><p>git log –pretty=oneline<br>显示从最近到最远的提交日志，差别是这里会将一次提交的日志信息在一行输出，最前面的字符串是 commit 的版本号。<br><img src="http://dengw.xyz/blog/180801/D8L4eci81H.png?imageslim" alt="enter image description here"></p>
</li>
<li><p>git reset –hard HEAD^<br>向前回退一个版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</p>
<br></li>
<li><p>git reset –hard commit_id<br>版本回退，即回退到 commit 的版本号为 commit_id 的那次提交。</p>
<br></li>
<li><p>git reflog<br>查看命令历史，注意这里指挥显示关于版本前进或者后退相关的命令，比如<code>git add .</code>这种类型的命令就不会显示。<br><img src="http://dengw.xyz/blog/180801/aCl24Hkg96.png?imageslim" alt="enter image description here"> </p>
</li>
</ul>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><ul>
<li><p>git checkout – file<br>丢弃工作区该文件的修改这里有两种情况：<br>第一种是 file 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>第二种是 file 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<br></li>
<li><p>git reset HEAD file<br>可以把暂存区的修改撤销掉（unstage），重新放回工作区（即回到git add命令之前的状态，工作区保留修改之后的状态）</p>
<br></li>
</ul>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>现在有一个场景，在上次已经把所有内容推送到仓库之中后，你删除了工作区的一个文件：</p>
<ul>
<li>git checkout – file<br>将工作区删除的文件恢复<br></li>
<li>git rm file<br>从版本库中删除该文件，然后再 git commit </li>
</ul>
<h3 id="远程仓库-1"><a href="#远程仓库-1" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>git clone URL<br>从远程仓库URL加载创建一个与远程仓库一样的本地仓库<br></li>
<li>git push -u origin master<br>第一次推送本地仓库master分支的所有内容到远程仓库<br></li>
<li>git push orign master<br>推送本地仓库master分支的所有内容到远程仓库的master分支<br></li>
<li>git push origin dev<br>推送本地仓库master分支的所有内容到远程仓库的 dev 分支</li>
</ul>
<h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h4><ul>
<li>git branch dev<br>创建一个名字为dev的分支<br></li>
<li>git checkout dev<br>切换到 dev 分支<br></li>
<li>git checkout -b dev<br>相当于上面两条命令的合集。创建并切换到 dev 分支<br></li>
<li>git branch<br>查看当前分支：会列出所有分支，当前分支前面会标一个 * 号<br></li>
<li>git merge dev<br>在 master 分支上执行这条命令的时候，相当于把 dev 分支的内容合并到 master分支上<br></li>
<li>git branch -d dev<br>删除 dev 这个分支<br></li>
</ul>
<h4 id="查看冲突"><a href="#查看冲突" class="headerlink" title="查看冲突"></a>查看冲突</h4><ul>
<li>git merge<br>如果合并过程中存在冲突的话会报错<br></li>
<li>git status<br>可以告诉我们冲突的文件<br></li>
<li>git log –graph<br>查看分支合并图<br></li>
</ul>
<h4 id="合并策略"><a href="#合并策略" class="headerlink" title="合并策略"></a>合并策略</h4><h5 id="Fast-forward模式："><a href="#Fast-forward模式：" class="headerlink" title="Fast forward模式："></a>Fast forward模式：</h5><p><img src="http://dengw.xyz/blog/180801/K9kG5JeEld.png?imageslim" alt="enter image description here"></p>
<h5 id="非-Fast-forward-模式：生成了一个新的-commit-对象"><a href="#非-Fast-forward-模式：生成了一个新的-commit-对象" class="headerlink" title="非 Fast forward 模式：生成了一个新的 commit 对象"></a>非 Fast forward 模式：生成了一个新的 commit 对象</h5><p><img src="http://dengw.xyz/blog/180801/1dde13h11J.png?imageslim" alt="enter image description here"></p>
<ul>
<li>git merge –no-ff -m “merge with no-ff” dev<br>使用非 Fast forward 模式合并一个分支<br></li>
</ul>
<h4 id="贮藏-Bug分支"><a href="#贮藏-Bug分支" class="headerlink" title="贮藏(Bug分支)"></a>贮藏(Bug分支)</h4><ul>
<li>git stash<br>把当前工作现场“储藏”起来，等以后恢复现场后继续工作，这个时候使用 git status 命令，显示是干净的，没有未提交的内容。<br></li>
<li>git stash list<br>查看保存的工作现场<br></li>
<li>git stash apply<br>恢复之前 stash 的内容，但是恢复后，stash内容并不删除，使用 git stash list 命令还是可以看到保存的工作现场，你需要用 git stash drop 来删除<br></li>
<li>git stash pop<br>恢复的同时删除保存的工作现场<br></li>
<li>git stash apply stash@{0}<br>当你你多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash<br></li>
</ul>
<h4 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<ul>
<li>git branch -D dev<br>丢弃一个没有被合并过的分支dev ，可以通过该命令强行删除，使用<code>git branch -d</code>命令不能删除没有合并的分支</li>
</ul>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><blockquote>
<p>**master分支: **主分支，要时刻与远程同步；</p>
</blockquote>
<blockquote>
<p>**dev分支: **开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>**bug分支: **只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
</blockquote>
<blockquote>
<p>**feature分支: **是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
</blockquote>
<ul>
<li>git remote<br>查看远程库的信息， <code>git remote -v </code>显示更详细的信息。<br></li>
<li>git checkout -b dev origin/dev<br>创建远程origin的dev分支到本地。当你使用git clone 命令从远程克隆到本地仓库时，默认情况下，你只能看到本地的master分支<br></li>
<li>git pull<br>把最新的提交从远程仓库拉取下来，在本地仓库合并（如果有冲突需要先在本地解决冲突）<br></li>
<li>git branch –set-upstream-to=origin/dev dev<br>指定本地dev分支与远程 origin/dev 分支的链接，不然会 git pull 失败。这个命令的使用场景是当你从远程克隆一个仓库到本地，然后新建了一个和远程仓库一样名字的仓库，比如叫做dev，当你想要 dev 推送到远程仓库的时候，使用git pull拉取就会失败，因为本地dev分支与远程 origin/dev 分支之间没有链接。<br></li>
</ul>
<h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。<strong>本质上它就是指向某个 commit的指针</strong>。</p>
<p>思考这样一个问题，已经有了 commit 为什么还要有 tag 呢？主要是 commit 的版本号是一对很长的无规则的字符串，很难记，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul>
<li>git tag tag_name<br>切换到需要打标签的分支，创建一个标签，默认标签是打在最新提交的commit上的。<br></li>
<li>git tag tag_name commit_id<br>将名字为 tag_name 的标签和 id 为 commit_id 的 commit 关联起来<br></li>
<li>git tag -a tag_name -m “commit” commit_id<br>创建带有说明的标签，<code>-m</code>指定说明文字。<br></li>
<li>git tag<br>查看所有标签，注意<strong>标签不是按时间顺序列出，而是按字母排序</strong>的<br></li>
<li>git show tag_name<br>查看对应标签的具体信息<br></li>
</ul>
<h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><ul>
<li>git tag -d tag_name<br>根据标签名删除指定标签</li>
<li>git push origin tag_name<br>推送某个标签到远程</li>
<li>git push origin –tags<br>一次性推送全部尚未推送的标签到远程</li>
</ul>
<p>一个场景：如果标签已经推送到远程，先要删除远程标签。</p>
<ul>
<li>先从本地删除：<code>git tag -d tag_name</code></li>
<li>然后，从远程删除，删除命令也是push，格式如下：<code>git push origin :refs/tags/tag_name</code><br></li>
</ul>
<h3 id="SourceTree-对应到-Git-部分名词解释"><a href="#SourceTree-对应到-Git-部分名词解释" class="headerlink" title="SourceTree 对应到 Git 部分名词解释"></a>SourceTree 对应到 Git 部分名词解释</h3><ul>
<li>克隆(clone)：从远程仓库URL加载创建一个与远程仓库一样的本地仓库</li>
<li>提交(commit)：将暂存文件上传到本地仓库（我们在Finder中对本地仓库做修改后一般都得先提交一次，再推送）</li>
<li>合并(merge)：将多个同名文件合并为一个文件，该文件包含多个同名文件的所有内容，相同内容抵消</li>
<li>抓取(fetch)：从远程仓库获取信息并同步至本地仓库</li>
<li>拉取(pull)：从远程仓库获取信息并同步至本地仓库，并且自动执行合并（merge）操作，即 pull=fetch+merge</li>
<li>推送(push)：将本地仓库同步至远程仓库，一般推送（push）前先拉取（pull）一次，确保一致</li>
<li>检出(checkout)：切换不同分支</li>
<li>添加(add)：添加文件到暂存区</li>
<li>移除(remove)：移除文件至暂存区</li>
<li>储藏/贮藏(git stash)：保存工作现场</li>
<li>重置(reset)：回到最近添加(add)/提交(commit)状态</li>
<li>分支(branch)：创建/修改/删除分支</li>
<li>标签(tag): 给项目增添标签</li>
<li>工作流(Git Flow): 团队工作时，每个人创建属于自己的分支（branch），确定无误后提交到master分枝</li>
<li>终端(terminal): 可以输入git命令行</li>
</ul>
<h3 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zyw0713/article/details/80083431">git 的工作流程（纯干货）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/07/24/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" data-id="ckqm6kplp002dxxr5fwk5a0ps" data-title="git学习总结" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Github/" rel="tag">Github</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AD%A6%E4%B9%A0/">Java学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E5%AD%A6%E4%B9%A0/">Linux学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php%E5%AD%A6%E4%B9%A0/">php学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring%E5%AD%A6%E4%B9%A0/">spring学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/">数据存储</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/">生活随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ANR/" rel="tag">ANR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity/" rel="tag">Activity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" rel="tag">Android消息机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Animation/" rel="tag">Animation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bitmap/" rel="tag">Bitmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Camera%E5%BC%80%E5%8F%91/" rel="tag">Camera开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/" rel="tag">Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intent/" rel="tag">Intent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" rel="tag">Java内存机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E5%AE%B9%E5%99%A8/" rel="tag">Java容器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">Java虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E5%91%BD%E4%BB%A4/" rel="tag">Linux命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP/" rel="tag">MVP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RecylerView/" rel="tag">RecylerView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Retrofit/" rel="tag">Retrofit</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View%E5%B8%83%E5%B1%80/" rel="tag">View布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Window/" rel="tag">Window</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" rel="tag">apk反编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/" rel="tag">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/" rel="tag">spring-boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tool/" rel="tag">tool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%91%E6%8C%87Offer/" rel="tag">剑指Offer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E4%B9%A0/" rel="tag">实习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" rel="tag">文件下载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%A1%E6%8B%9B/" rel="tag">校招</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" rel="tag">类加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/" rel="tag">网络框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/" rel="tag">自定义View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" rel="tag">项目总结</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ANR/" style="font-size: 10px;">ANR</a> <a href="/tags/Activity/" style="font-size: 12.5px;">Activity</a> <a href="/tags/Android/" style="font-size: 12.5px;">Android</a> <a href="/tags/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Android消息机制</a> <a href="/tags/Animation/" style="font-size: 10px;">Animation</a> <a href="/tags/Bitmap/" style="font-size: 10px;">Bitmap</a> <a href="/tags/Camera%E5%BC%80%E5%8F%91/" style="font-size: 10px;">Camera开发</a> <a href="/tags/Canvas/" style="font-size: 10px;">Canvas</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/HTTP/" style="font-size: 17.5px;">HTTP</a> <a href="/tags/Intent/" style="font-size: 10px;">Intent</a> <a href="/tags/Java%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Java内存机制</a> <a href="/tags/Java%E5%AE%B9%E5%99%A8/" style="font-size: 10px;">Java容器</a> <a href="/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 17.5px;">Java虚拟机</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/Linux%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">Linux命令</a> <a href="/tags/MVP/" style="font-size: 10px;">MVP</a> <a href="/tags/RecylerView/" style="font-size: 10px;">RecylerView</a> <a href="/tags/Retrofit/" style="font-size: 15px;">Retrofit</a> <a href="/tags/View%E5%B8%83%E5%B1%80/" style="font-size: 20px;">View布局</a> <a href="/tags/Window/" style="font-size: 10px;">Window</a> <a href="/tags/apk%E5%8F%8D%E7%BC%96%E8%AF%91/" style="font-size: 10px;">apk反编译</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/spring-boot/" style="font-size: 10px;">spring-boot</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/tool/" style="font-size: 10px;">tool</a> <a href="/tags/vim/" style="font-size: 12.5px;">vim</a> <a href="/tags/%E5%89%91%E6%8C%87Offer/" style="font-size: 10px;">剑指Offer</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 12.5px;">反射</a> <a href="/tags/%E5%AE%9E%E4%B9%A0/" style="font-size: 12.5px;">实习</a> <a href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">排序算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/" style="font-size: 10px;">文件下载</a> <a href="/tags/%E6%A0%A1%E6%8B%9B/" style="font-size: 17.5px;">校招</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 10px;">泛型</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/" style="font-size: 15px;">类加载</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/" style="font-size: 15px;">网络框架</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/" style="font-size: 10px;">自定义View</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" style="font-size: 10px;">项目总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/09/">September 2012</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/06/Mac%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%80%BB%E7%BB%93/">Mac终端常用快捷键总结</a>
          </li>
        
          <li>
            <a href="/2019/06/23/%E5%85%B3%E4%BA%8Ephp%E7%9A%84empty%E5%87%BD%E6%95%B0/">关于php的empty函数</a>
          </li>
        
          <li>
            <a href="/2019/06/16/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/">Spring常用注解</a>
          </li>
        
          <li>
            <a href="/2019/06/05/%E4%BD%BF%E7%94%A8-gitignore%E9%85%8D%E7%BD%AEgit%E5%BF%BD%E7%95%A5%E6%8F%90%E4%BA%A4%E8%A7%84%E5%88%99/">使用.gitignore配置git忽略提交规则</a>
          </li>
        
          <li>
            <a href="/2019/06/05/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/">Mysql常用命令总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>